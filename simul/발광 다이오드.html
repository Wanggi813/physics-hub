<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>발광다이오드</title>
  <style>
    :root {
      --bg: #fdfdfd;
      --ink: #111827;
      --muted: #6b7280;
      --card: #f9fafb;
      --brand: #4ade80;
    }

    * {
      box-sizing: border-box
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      font-family: system-ui, Segoe UI, Roboto, Noto Sans KR, sans-serif
    }

    .wrap {
      max-width: 900px;
      margin: 28px auto;
      padding: 0 16px
    }

    h1 {
      margin: 0 0 12px
    }

    .panel,
    .stage {
      background: var(--card);
      border: 1px solid #e5e7eb;
      border-radius: 14px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, .08)
    }

    .panel {
      padding: 14px;
      margin-bottom: 12px
    }

    .row {
      display: grid;
      grid-template-columns: 120px 1fr 90px;
      gap: 10px;
      align-items: center
    }

    .row3 {
      display: grid;
      grid-template-columns: 120px 1fr 120px;
      gap: 10px;
      align-items: center;
      margin-top: 10px
    }

    input[type="range"],
    select {
      width: 100%
    }

    output,
    .pill {
      background: #fff;
      border: 1px solid #d1d5db;
      border-radius: 10px;
      padding: 6px 10px;
      text-align: center;
      font-variant-numeric: tabular-nums;
      color: var(--ink)
    }

    .hint {
      color: var(--muted);
      font-size: 12px;
      margin-top: 8px;
      line-height: 1.5
    }

    .stage {
      padding: 12px
    }

    .sim {
      aspect-ratio: 16/9;
      border-radius: 10px;
      overflow: hidden;
      background: #fff;
      position: relative
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%
    }

    .legend {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 8px;
      color: var(--muted);
      font-size: 12px
    }

    .legend i {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 6px;
      vertical-align: -1px
    }

    .brand {
      margin: 18px auto 36px;
      text-align: center;
      color: var(--brand);
      font-weight: 800;
      letter-spacing: .02em;
      text-shadow: 0 1px 4px rgba(74, 222, 128, .25)
    }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>광다이오드 (정·역바이어스 직관)</h1>

    <div class="panel">
      <div class="row">
        <label for="bias">전압 V (–5 ~ +5 V)</label>
        <input id="bias" type="range" min="-5" max="5" step="0.1" value="0" />
        <output id="vOut">0.0 V</output>
      </div>

      <div class="row3">
        <label for="color">LED 색상</label>
        <select id="color">
          <option value="ir">적외(IR, 850 nm)</option>
          <option value="red" selected>적색(625 nm)</option>
          <option value="amber">호박(590 nm)</option>
          <option value="green">녹색(530 nm)</option>
          <option value="blue">청색(470 nm)</option>
          <option value="uv">자외(UV, 395 nm)</option>
          <option value="white">백색</option>
        </select>
        <output id="vfOut">Vf ≈ 2.0 V</output>
      </div>

      <div class="hint" id="hint">
        • <b>+V(정방향)</b> → 공핍층 좁아짐, <b>V ≥ Vf</b>일 때 <b>빛 방출</b><br>
        • <b>–V(역방향)</b> → 공핍층 넓어짐, <b>광자 미방출</b><br>
        • 파장이 짧을수록 에너지가 커서 Vf ↑
      </div>
    </div>

    <div class="stage">
      <div class="sim"><canvas id="sim"></canvas></div>
      <div class="legend">
        <span><i style="background:#d1d5db"></i>도핑 영역(p–n)</span>
        <span><i style="background:#facc15"></i>공핍층(폭이 전압에 따라 변화)</span>
        <span><i style="background:#34d399"></i>정방향 시 광자 방출</span>
      </div>
    </div>

    <div class="brand">왕왕물리시뮬레이션</div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('sim');
      const ctx = canvas.getContext('2d');
      const $bias = document.getElementById('bias');
      const $vOut = document.getElementById('vOut');
      const $color = document.getElementById('color');
      const $vfOut = document.getElementById('vfOut');
      const $hint = document.getElementById('hint');

      // LED 색상별 대표 파라미터 (교육용 근사치)
      // vf: 대표 순방향 전압(10~20mA급), hue: 광자 색상, name: 표기, lam: 파장
      const COLOR_PROFILES = {
        ir: { vf: 1.2, hue: 'rgba(255,90,90,', name: '적외(IR)', lam: '850 nm' },
        red: { vf: 2.0, hue: 'rgba(255,80,80,', name: '적색', lam: '625 nm' },
        amber: { vf: 2.1, hue: 'rgba(255,180,60,', name: '호박', lam: '590 nm' },
        green: { vf: 2.9, hue: 'rgba(110,231,183,', name: '녹색', lam: '530 nm' },
        blue: { vf: 3.2, hue: 'rgba(100,160,255,', name: '청색', lam: '470 nm' },
        uv: { vf: 3.4, hue: 'rgba(180,140,255,', name: '자외(UV)', lam: '395 nm' },
        white: { vf: 3.1, hue: 'rgba(255,255,220,', name: '백색', lam: '(청색칩+형광체)' },
      };
      let current = COLOR_PROFILES[$color.value];

      let V = +$bias.value;   // -5 ~ +5
      let W = 0, H = 0;
      const photons = [];

      // 공핍층 모델 (교육용)
      const BASE_DEPL = 0.18; // 폭 비율(캔버스 폭 대비)
      const K = 0.06;         // 전압에 따른 변화 민감도

      // 크기 설정
      function resize() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const rect = canvas.getBoundingClientRect();
        canvas.width = W = Math.round(rect.width * dpr);
        canvas.height = H = Math.round(rect.height * dpr);
        ctx.setTransform(1, 0, 0, 1, 0, 0);
      }
      window.addEventListener('resize', resize);

      // ‘광자’ 스폰 (정방향에서만, V >= Vf 조건)
      function spawn(dt) {
        if (V <= 0) return;
        const over = Math.max(0, V - current.vf);   // 임계 초과분
        if (over <= 0) return;                      // 임계 전까지는 방출 X

        // +5V에서 초당 60개 → 임계 초과분에 비례시킴
        // over=0일 때 0, over≈(5 - vf)일 때 ~60
        const maxOver = Math.max(0.5, 5 - current.vf);
        const rate = 60 * (over / maxOver);
        let want = rate * dt;
        let n = Math.floor(want); if (Math.random() < want - n) n++;

        for (let i = 0; i < n; i++) {
          photons.push({
            x: W * 0.5, y: H * 0.5 + (Math.random() - 0.5) * H * 0.25,
            vx: (W * 0.25) + Math.random() * W * 0.15,
            vy: (Math.random() - 0.5) * 40,
            life: 0, maxLife: 1.1 + Math.random() * 0.7
          });
        }
        // 제한
        if (photons.length > 500) photons.splice(0, photons.length - 500);
      }

      function step(dt) {
        for (let i = photons.length - 1; i >= 0; i--) {
          const p = photons[i];
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.life += dt;
          if (p.life > p.maxLife || p.x > W * 0.95) photons.splice(i, 1);
        }
      }

      function drawJunction() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);

        // 배경
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = "#000"; ctx.fillRect(0, 0, W, H);

        // p/n 영역 박스
        const left = W * 0.15, right = W * 0.85, top = H * 0.22, bottom = H * 0.78;
        const mid = (left + right) / 2;

        // p영역
        ctx.fillStyle = "#374151";
        ctx.fillRect(left, top, (mid - left) - 2, bottom - top);
        // n영역
        ctx.fillStyle = "#0f172a";
        ctx.fillRect(mid + 2, top, (right - mid) - 2, bottom - top);

        // 공핍층 폭 계산
        const raw = BASE_DEPL * W * (1 - K * V);
        const depl = Math.max(W * 0.06, Math.min(W * 0.35, raw)); // 클램프
        const dL = mid - depl / 2, dR = mid + depl / 2;

        // 공핍층
        const grad = ctx.createLinearGradient(dL, 0, dR, 0);
        grad.addColorStop(0, "rgba(251,191,36,0.20)");
        grad.addColorStop(0.5, "rgba(251,191,36,0.35)");
        grad.addColorStop(1, "rgba(251,191,36,0.20)");
        ctx.fillStyle = grad;
        ctx.fillRect(dL, top, depl, bottom - top);

        // 내부 라벨
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // P / N 라벨
        ctx.fillStyle = "#9aa0a6";
        ctx.font = `${Math.round(18 * dpr)}px system-ui`;
        ctx.fillText("P", (left + mid) / 2, (top + bottom) / 2);
        ctx.fillText("N", (mid + right) / 2, (top + bottom) / 2);

        // 공핍층 라벨 (반투명 노란색)
        ctx.fillStyle = "rgba(251,191,36,0.7)";
        ctx.font = `600 ${Math.round(18 * dpr)}px system-ui`;
        ctx.fillText("공핍층", mid, (top + bottom) / 2);

        // 전압 방향 표시 (굵기+길이 가변)
        ctx.strokeStyle = V >= 0 ? "rgba(110,231,183,0.8)" : "rgba(147,197,253,0.8)";
        ctx.lineWidth = 8;

        const trackLen = right - left;
        const maxLen = Math.min(120 * dpr, trackLen * 0.6);
        const baseLen = 30 * dpr;
        const len = baseLen + (Math.abs(V) / 5) * (maxLen - baseLen);

        const head = Math.max(10 * dpr, 1.5 * ctx.lineWidth);
        ctx.beginPath();
        const axY = top - 16 * dpr;

        if (V >= 0) {
          ctx.moveTo(left, axY);
          ctx.lineTo(left + len, axY);
          ctx.moveTo(left + len - head, axY - head * 0.66);
          ctx.lineTo(left + len, axY);
          ctx.lineTo(left + len - head, axY + head * 0.66);
        } else {
          ctx.moveTo(right, axY);
          ctx.lineTo(right - len, axY);
          ctx.moveTo(right - len + head, axY - head * 0.66);
          ctx.lineTo(right - len, axY);
          ctx.lineTo(right - len + head, axY + head * 0.66);
        }
        ctx.stroke();

        // 상태 텍스트
        ctx.fillStyle = "#e5e7eb";
        ctx.font = `${Math.round(12 * dpr)}px system-ui`;
        let status;
        if (V > 0) {
          if (V >= current.vf) status = `정방향 (+V): V ≥ Vf(≈${current.vf.toFixed(1)}V) → 방출 시작`;
          else status = `정방향 (+V): V < Vf(≈${current.vf.toFixed(1)}V) → 방출 없음`;
        } else if (V < 0) {
          status = "역방향 (−V): 공핍층 ⬆, 빛 없음";
        } else {
          status = "0 V: 거의 변화 없음";
        }
        ctx.fillText(`${status} | 선택: ${current.name} ${current.lam}`, left, bottom + 18 * dpr);
      }

      function drawPhotons() {
        if (V <= 0 || V < current.vf) return;
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        for (const p of photons) {
          const t = p.life / p.maxLife;
          const alpha = Math.max(0, 1 - t);
          // 선택한 색상에 맞는 광자 색
          ctx.fillStyle = `${current.hue}${0.85 * alpha})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, 2.4 * dpr, 0, Math.PI * 2);
          ctx.fill();

          // 꼬리
          ctx.strokeStyle = `${current.hue}${0.38 * alpha})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(p.x - p.vx * 0.02, p.y - p.vy * 0.02);
          ctx.lineTo(p.x, p.y);
          ctx.stroke();
        }
      }

      function loop() {
        const now = performance.now();
        const dt = Math.min(0.05, (now - (loop._last || now)) / 1000);
        loop._last = now;

        spawn(dt);
        step(dt);
        drawJunction();
        drawPhotons();

        requestAnimationFrame(loop);
      }

      // UI
      function refreshUITexts() {
        $vOut.textContent = V.toFixed(1) + " V";
        $vfOut.textContent = `Vf ≈ ${current.vf.toFixed(1)} V`;
        $hint.innerHTML =
          `• <b>+V(정방향)</b> → 공핍층 좁아짐, <b>V ≥ Vf</b>일 때 <b>빛 방출</b> 시작 (색에 따라 Vf 다름)<br>` +
          `• <b>–V(역방향)</b> → 공핍층 넓어짐, <b>광자 미방출</b><br>` +
          `• 참고: 대략적으로 <i>E = hc/λ</i> 이므로 파장이 짧을수록(청·자외) 에너지가 커서 대표 Vf가 큽니다.`;
      }

      $bias.addEventListener('input', e => {
        V = +e.target.value;
        refreshUITexts();
      });
      $color.addEventListener('change', e => {
        current = COLOR_PROFILES[e.target.value];
        // 색 바꾸면 기존 광자 잔상 정리
        photons.length = 0;
        refreshUITexts();
      });

      // 시작
      function init() {
        resize();
        refreshUITexts();
        requestAnimationFrame(loop);
      }
      init();
    })();
  </script>
</body>

</html>