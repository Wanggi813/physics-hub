<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>편광 필름 실험 - 최종 완성 (미세 틈 적용)</title>
    <style>
        /* Pretendard 폰트 적용 */
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');
        
        body { margin: 0; overflow: hidden; background-color: #ffffff; font-family: 'Pretendard', sans-serif; }
        
        /* UI 패널 */
        #ui-container {
            position: absolute;
            top: 20px; left: 20px;
            width: 320px;
            padding: 25px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e0e0e0;
            border-radius: 16px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.08);
            z-index: 100;
        }

        h1 { margin: 0 0 5px 0; font-size: 1.3rem; color: #111; text-align: center; font-weight: 800; letter-spacing: -0.5px;}
        p.sub { margin: 0 0 20px 0; font-size: 0.9rem; color: #666; border-bottom: 2px solid #f5f5f5; padding-bottom: 15px; text-align: center;}
        
        .control-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-size: 0.95rem; color: #333; font-weight: 700; }
        
        input[type=range] { 
            width: 100%; cursor: pointer; accent-color: #444; 
            height: 6px; background: #eee; border-radius: 5px;
        }
        
        /* 버튼 스타일 */
        .btn {
            width: 100%; padding: 14px;
            background: #f7f7f7; border: 1px solid #ddd; color: #333;
            border-radius: 10px; cursor: pointer; font-weight: 700; font-size: 0.95rem;
            transition: all 0.2s ease;
            display: flex; justify-content: center; align-items: center; gap: 8px;
            font-family: 'Pretendard', sans-serif;
            margin-bottom: 8px;
        }
        .btn:hover { background: #eee; }
        .btn.active {
            background: #333; border-color: #000; color: white;
            box-shadow: 0 4px 10px rgba(0,0,0, 0.2);
        }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; box-shadow: none; }

        .checkbox-wrapper {
            display: gap: 10px; align-items: center; margin-bottom: 8px;
            padding: 12px; background: #f9f9f9; border-radius: 8px;
            cursor: pointer; display: flex;
            transition: background 0.2s;
        }
        .checkbox-wrapper:hover { background: #f0f0f0; }

        /* 제3 편광판 강조 스타일 */
        .special-wrapper {
            background-color: #eef2ff; 
            border: 1px solid #c7d2fe;
        }
        .special-wrapper:hover { background-color: #e0e7ff; }
        .special-text { font-size: 0.8rem; color: #666; margin-top: -5px; padding-left: 5px; line-height: 1.4; }

        #graph-wrapper {
            background: #fff;
            border: 1px solid #eee;
            border-radius: 12px;
            padding: 10px;
            margin-top: 20px;
        }

        #instruction {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: #aaa; font-size: 0.85rem; pointer-events: none; font-weight: 500;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div id="ui-container">
    <h1>편광과 LCD</h1>
    <p class="sub">말뤼스 법칙과 필름의 밝기 변화</p>
    
    <div class="control-group">
        <label style="display:flex; justify-content:space-between;">
            제2 편광판 회전
            <span id="angleVal" style="color:#000; font-family:'Pretendard'; font-size:1.1rem;">0°</span>
        </label>
        <input type="range" id="angleSlider" min="0" max="90" value="0" step="1">
    </div>

    <div class="control-group">
        <label>실생활 응용 (LCD)</label>
        <div class="checkbox-wrapper">
            <input type="checkbox" id="lcdCheck" style="width:18px; height:18px; accent-color:#333; cursor:pointer;">
            <span style="font-size:0.9rem; color:#555;" onclick="document.getElementById('lcdCheck').click()">액정 분자층 보기</span>
        </div>
        <button id="voltageBtn" class="btn" disabled>
            ⚡ 전압 스위치 (꺼짐)
        </button>
    </div>

    <div class="control-group">
        <label style="color:#4f46e5;">심화 실험 (Vector)</label>
        <div class="checkbox-wrapper special-wrapper">
            <input type="checkbox" id="thirdPolCheck" style="width:18px; height:18px; accent-color:#4f46e5; cursor:pointer;">
            <span style="font-size:0.9rem; color:#4f46e5; font-weight:bold;" onclick="document.getElementById('thirdPolCheck').click()">제3의 편광판 (45°) 끼우기</span>
        </div>
        <div class="special-text">
            * 90°로 어두워진 상태에서 끼워보세요.<br>
            빛이 다시 통과하는 것을 볼 수 있습니다.
        </div>
    </div>

    <div id="graph-wrapper">
        <canvas id="graphCanvas" width="290" height="120"></canvas>
    </div>
</div>

<div id="instruction">마우스 드래그: 화면 회전 • 휠: 확대/축소</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- 1. 기본 설정 ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 3000);
    camera.position.set(180, 80, 250); 

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // --- 2. 조명 (고급 광원) ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
    dirLight.position.set(50, 200, 100);
    scene.add(dirLight);

    // --- 3. 오브젝트 생성 ---
    const X_START = -180, X_POL1 = -60, X_LCD_S = -40, X_LCD_E = 40, X_POL2 = 60, X_END = 180;
    const WAVE_RES = 0.8, AMP = 18, FREQ = 0.15;
    
    const matMol = new THREE.MeshBasicMaterial({ color: 0xaa00aa });

    // 2D 필름 생성 함수
    function createPure2DFilm(xPos, colorHex = 0x88ccff) {
        const group = new THREE.Group();
        group.position.x = xPos;

        const filmGeo = new THREE.PlaneGeometry(86, 86);
        const filmMat = new THREE.MeshStandardMaterial({ 
            color: colorHex, 
            transparent: true, 
            opacity: 0.25, 
            side: THREE.DoubleSide, 
            depthWrite: false,
            roughness: 0.3,
            metalness: 0.1
        });
        const film = new THREE.Mesh(filmGeo, filmMat);
        film.rotation.y = Math.PI / 2;
        film.name = "filmMesh";
        group.add(film);

        const lineGeo = new THREE.BufferGeometry();
        const vertices = [];
        const size = 42;
        const step = 6; 
        for(let z_loc = -size; z_loc <= size; z_loc += step) {
            vertices.push(0.1, -size, z_loc); vertices.push(0.1, size, z_loc);
            vertices.push(-0.1, -size, z_loc); vertices.push(-0.1, size, z_loc);
        }
        lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        const lineMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 1 });
        const lines = new THREE.LineSegments(lineGeo, lineMat);
        group.add(lines);

        scene.add(group);
        return group;
    }

    // 전구 생성 (예쁜 광원)
    const bulbGroup = new THREE.Group();
    bulbGroup.position.x = X_START;
    const bulbLight = new THREE.PointLight(0xfff0aa, 2.5, 300, 1);
    bulbGroup.add(bulbLight);

    const bulbGeo = new THREE.SphereGeometry(12, 32, 32);
    const bulbMat = new THREE.MeshStandardMaterial({
        color: 0xffffcc,
        emissive: 0xffcc44, 
        emissiveIntensity: 1.5,
        transparent: true,
        opacity: 0.9,
        roughness: 0.1
    });
    const bulbMesh = new THREE.Mesh(bulbGeo, bulbMat);
    bulbGroup.add(bulbMesh);

    const socketGeo = new THREE.CylinderGeometry(6, 6, 10, 16);
    const socketMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.8, roughness: 0.2 });
    const socketMesh = new THREE.Mesh(socketGeo, socketMat);
    socketMesh.rotation.z = Math.PI / 2;
    socketMesh.position.x = -12; 
    bulbGroup.add(socketMesh);
    scene.add(bulbGroup);

    // 편광판들
    const pol1 = createPure2DFilm(X_POL1);
    const pol2 = createPure2DFilm(X_POL2);
    const polMid = createPure2DFilm(0);
    polMid.rotation.x = Math.PI / 4; 
    polMid.visible = false;
    polMid.children[0].material.color.setHex(0xaaddaa); 

    // --- 4. 파동 (Waves) ---
    // 1) 소스 파동
    const srcWaves = [];
    const srcGroup = new THREE.Group();
    scene.add(srcGroup);
    for(let i=0; i<24; i++) {
        const pts = [];
        for(let x=X_START+10; x<=X_POL1; x+=WAVE_RES) pts.push(new THREE.Vector3(x,0,0));
        const line = new THREE.Line(
            new THREE.BufferGeometry().setFromPoints(pts),
            new THREE.LineBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.5 })
        );
        line.rotation.x = (i/24) * Math.PI * 2;
        srcGroup.add(line);
        srcWaves.push(line);
    }

    // 2) 중간 파동
    const midPts = [];
    for(let x=X_POL1; x<=X_POL2; x+=0.5) {
        midPts.push(new THREE.Vector3(x,0,0));
    }
    const midWave = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints(midPts),
        new THREE.LineBasicMaterial({ color: 0x00aaaa, linewidth: 2 })
    );
    scene.add(midWave);

    // 3) 결과 파동
    const endPts = [];
    for(let x=X_POL2; x<=X_END; x+=WAVE_RES) endPts.push(new THREE.Vector3(x,0,0));
    const endWave = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints(endPts),
        new THREE.LineBasicMaterial({ color: 0xaa00aa, linewidth: 2.5, transparent: true, opacity: 1.0 })
    );
    scene.add(endWave);

    const lcdGroup = new THREE.Group();
    scene.add(lcdGroup);
    const mols = [];
    const capGeo = new THREE.CapsuleGeometry(2, 10, 4, 8);
    for(let i=0; i<15; i++) {
        const m = new THREE.Mesh(capGeo, matMol);
        const t = i/14;
        m.position.x = X_LCD_S + t * (X_LCD_E - X_LCD_S);
        lcdGroup.add(m); mols.push({ mesh: m, t: t });
    }
    lcdGroup.visible = false;

    // --- 5. 로직 ---
    const clock = new THREE.Clock();
    let simTime = 0;
    const state = { angle: 0, lcd: false, voltTarget: 0.0, voltCurrent: 0.0, thirdPol: false };

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        simTime += dt * 1.8; 

        if (state.voltCurrent < state.voltTarget) state.voltCurrent = Math.min(state.voltTarget, state.voltCurrent + dt);
        else if (state.voltCurrent > state.voltTarget) state.voltCurrent = Math.max(state.voltTarget, state.voltCurrent - dt);

        srcWaves.forEach(line => {
            const pos = line.geometry.attributes.position.array;
            for(let i=0; i<pos.length/3; i++) {
                const x = (X_START+10) + i*WAVE_RES;
                pos[i*3+1] = Math.sin(x*FREQ - simTime) * AMP;
            }
            line.geometry.attributes.position.needsUpdate = true;
        });

        const twistRad = (1.0 - state.voltCurrent) * (Math.PI / 2);
        if(state.lcd) { mols.forEach(m => { m.mesh.rotation.x = m.t * twistRad; m.mesh.position.y = Math.sin(simTime + m.t*10) * 1; }); }

        // [중간 파동 업데이트]
        const midPos = midWave.geometry.attributes.position.array;
        
        for(let i=0; i<midPos.length/3; i++) {
            const x = X_POL1 + i*0.5;
            let currentAng = 0, currentAmp = AMP;
            
            if(state.lcd) { if(x >= X_LCD_S && x <= X_LCD_E) { const t = (x - X_LCD_S)/(X_LCD_E - X_LCD_S); currentAng = t * twistRad; } else if(x > X_LCD_E) currentAng = twistRad; }
            if(state.thirdPol && !state.lcd) { if (x > 0) { currentAng = Math.PI / 4; currentAmp = AMP * Math.cos(Math.PI/4); } }
            
            // [핵심 변경] 끊기는 구간을 0.3으로 줄여 시각적으로 1px처럼 보이게 함
            // x는 0.5 간격이므로 0.3으로 설정하면 x=0인 지점만 NaN 처리되어
            // -0.5와 +0.5 사이의 선 하나만 그려지지 않음 (가장 최소 단위)
            if(state.thirdPol && !state.lcd && Math.abs(x) < 0.3) { 
                midPos[i*3+1] = NaN; // Y
                midPos[i*3+2] = NaN; // Z
            } else {
                const disp = Math.sin(x*FREQ - simTime) * currentAmp; 
                midPos[i*3+1] = disp * Math.cos(currentAng); 
                midPos[i*3+2] = disp * Math.sin(currentAng);
            }
        }
        midWave.geometry.attributes.position.needsUpdate = true;

        const anaRad = state.angle * Math.PI/180; pol2.rotation.x = anaRad;
        let intensity = 0, incomingRad = state.lcd ? twistRad : 0; 
        if(state.thirdPol && !state.lcd) { intensity = 0.5 * Math.pow(Math.cos(anaRad - (Math.PI/4)), 2); } 
        else { intensity = Math.pow(Math.cos(anaRad - incomingRad), 2); }

        const endPos = endWave.geometry.attributes.position.array;
        for(let i=0; i<endPos.length/3; i++) {
            const x = X_POL2 + i*WAVE_RES;
            const disp = Math.sin(x*FREQ - simTime) * AMP * Math.sqrt(intensity); endPos[i*3+1] = disp * Math.cos(anaRad); endPos[i*3+2] = disp * Math.sin(anaRad);
        }
        endWave.geometry.attributes.position.needsUpdate = true;

        const filmMesh = pol2.getObjectByName("filmMesh");
        if(filmMesh) {
            const filmColorClear = new THREE.Color(0x88ccff), filmColorDark = new THREE.Color(0x111111);
            filmMesh.material.color.copy(filmColorDark).lerp(filmColorClear, intensity); filmMesh.material.opacity = 0.85 - (0.6 * intensity);
        }

        bulbMat.emissiveIntensity = 1.5 + Math.sin(simTime * 2) * 0.1;
        bulbLight.intensity = 2.5 + Math.sin(simTime * 2) * 0.2;

        updateGraph(intensity, state.angle); controls.update(); renderer.render(scene, camera);
    }

    // --- UI 이벤트 ---
    const slider = document.getElementById('angleSlider');
    const txtAngle = document.getElementById('angleVal');
    const checkLcd = document.getElementById('lcdCheck');
    const btnVolt = document.getElementById('voltageBtn');
    const checkThird = document.getElementById('thirdPolCheck');

    checkThird.addEventListener('change', e => { state.thirdPol = e.target.checked; polMid.visible = state.thirdPol; if(state.thirdPol && state.lcd) { checkLcd.click(); } });
    slider.addEventListener('input', e => { state.angle = Number(e.target.value); txtAngle.textContent = state.angle + "°"; });
    checkLcd.addEventListener('change', e => { state.lcd = e.target.checked; lcdGroup.visible = state.lcd; btnVolt.disabled = !state.lcd; if(state.lcd) { if(state.thirdPol) { checkThird.click(); } state.angle = 90; slider.value = 90; txtAngle.textContent = "90°"; state.voltTarget = 0.0; state.voltCurrent = 0.0; btnVolt.classList.remove('active'); btnVolt.innerText = "⚡ 전압 스위치 (꺼짐)"; } else { state.voltTarget = 0.0; state.voltCurrent = 0.0; } });
    btnVolt.addEventListener('click', () => { if(state.voltTarget === 0.0) { state.voltTarget = 1.0; btnVolt.classList.add('active'); btnVolt.innerText = "⚡ 전압 스위치 (켜짐)"; } else { state.voltTarget = 0.0; btnVolt.classList.remove('active'); btnVolt.innerText = "⚡ 전압 스위치 (꺼짐)"; } });

    // --- 그래프 ---
    const gCanvas = document.getElementById('graphCanvas'); const ctx = gCanvas.getContext('2d');
    function updateGraph(int, deg) {
        const w = gCanvas.width, h = gCanvas.height; ctx.clearRect(0,0,w,h); ctx.strokeStyle = "#ddd"; ctx.lineWidth=1; ctx.beginPath(); for(let y=20; y<=h-20; y+=20) { ctx.moveTo(40,y); ctx.lineTo(w-10,y); } ctx.stroke(); ctx.strokeStyle = "#999"; ctx.lineWidth=1.5; ctx.beginPath(); ctx.moveTo(40,15); ctx.lineTo(40,h-20); ctx.lineTo(w-10,h-20); ctx.stroke(); ctx.beginPath(); ctx.strokeStyle = "#ccc"; ctx.setLineDash([4,4]); for(let x=0; x<=w-50; x++) { const r = (x/(w-50)) * (Math.PI/2); const y = (h-20) - (Math.cos(r)**2)*(h-30); if(x===0) ctx.moveTo(40+x,y); else ctx.lineTo(40+x,y); } ctx.stroke(); ctx.setLineDash([]); const clampDeg = Math.min(deg, 90); const px = 40 + (clampDeg/90)*(w-50); const py = (h-20) - int*(h-30); const intensityColor = Math.floor(int * 150); let barColor = `rgb(${intensityColor}, 0, ${intensityColor})`; ctx.fillStyle = barColor; ctx.fillRect(40, py, px-40, (h-20)-py); ctx.fillStyle = barColor; ctx.beginPath(); ctx.arc(px,py,4,0,Math.PI*2); ctx.fill(); ctx.fillStyle = "#555"; ctx.font = "12px Pretendard"; ctx.fillText("최대", 10, 22); ctx.fillText("0°", 35, h-5); ctx.fillText("90°", w-25, h-5); ctx.fillStyle = "#333"; ctx.font = "bold 13px monospace"; ctx.fillText(`밝기: ${(int*100).toFixed(0)}%`, w-90, 20);
    }
    window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    animate();
</script>
</body>
</html>