<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ì „ê¸°ì¥ê³¼ ë“±ì „ìœ„ë©´</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Pretendard', sans-serif;
            color: white;
            user-select: none;
            touch-action: none;
            /* ë¸Œë¼ìš°ì € ê¸°ë³¸ ì œìŠ¤ì²˜ ì°¨ë‹¨ (ì¤‘ìš”) */
        }

        canvas {
            display: block;
            touch-action: none;
        }

        /* UI ë ˆì´ì–´ */
        #ui-layer {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(30, 30, 30, 0.9);
            padding: 15px 30px;
            border-radius: 50px;
            border: 1px solid #555;
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
            z-index: 100;
            /* UI ë‚´ë¶€ í„°ì¹˜ê°€ ìº”ë²„ìŠ¤ë¡œ ìƒˆì§€ ì•Šë„ë¡ ë§‰ìŒ */
            touch-action: none;
        }

        .charge-btn {
            width: 55px;
            height: 55px;
            border-radius: 50%;
            border: none;
            font-weight: bold;
            font-size: 18px;
            cursor: grab;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            position: relative;
            touch-action: none;
            /* ë²„íŠ¼ ìì²´ì˜ í„°ì¹˜ ì•¡ì…˜ ì œì–´ */
        }

        .charge-btn:active {
            transform: scale(0.9);
            cursor: grabbing;
        }

        /* ìƒ‰ìƒ ìŠ¤íƒ€ì¼ */
        .pos-1 {
            background: radial-gradient(circleAt 30% 30%, #ff6b6b, #c0392b);
            border: 2px solid #ff9999;
        }

        .neg-1 {
            background: radial-gradient(circleAt 30% 30%, #4facfe, #00f2fe);
            border: 2px solid #aaddff;
        }

        .pos-2 {
            background: radial-gradient(circleAt 30% 30%, #ff0000, #8b0000);
            border: 2px solid #ff4444;
            box-shadow: 0 0 15px #ff0000;
        }

        .neg-2 {
            background: radial-gradient(circleAt 30% 30%, #0000ff, #00008b);
            border: 2px solid #4444ff;
            box-shadow: 0 0 15px #0000ff;
        }

        /* ë“œë˜ê·¸ ì¤‘ì¸ ìœ ë ¹ ìš”ì†Œ */
        .ghost-charge {
            position: absolute;
            pointer-events: none;
            /* ì¤‘ìš”: ë“œë˜ê·¸ ì¤‘ì¸ ìš”ì†Œê°€ ì´ë²¤íŠ¸ë¥¼ ê°€ë¡œì±„ì§€ ì•Šê²Œ í•¨ */
            z-index: 999;
            opacity: 0.8;
            transform: translate(-50%, -50%);
            width: 55px;
            height: 55px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: white;
        }

        /* ìƒë‹¨ ì»¨íŠ¸ë¡¤ */
        #top-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
            z-index: 100;
        }

        .control-group {
            background: rgba(30, 30, 30, 0.9);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid #555;
            color: #ddd;
            font-size: 14px;
        }

        .control-item {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px 0;
            /* í„°ì¹˜ ì˜ì—­ í™•ë³´ */
        }

        input[type="checkbox"],
        input[type="radio"] {
            width: 20px;
            height: 20px;
            accent-color: #00ffcc;
        }

        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00ffcc;
            color: #00ffcc;
            padding: 8px 12px;
            border-radius: 6px;
            pointer-events: none;
            font-family: monospace;
            font-size: 13px;
            display: none;
            z-index: 200;
            white-space: nowrap;
        }

        #instruction {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            pointer-events: none;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 5px black;
            z-index: 50;
            width: 90%;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 5px;
        }

        #graph-overlay {
            position: absolute;
            bottom: 120px;
            right: 20px;
            width: 480px;
            height: 300px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #888;
            border-radius: 8px;
            display: none;
            padding: 10px;
            z-index: 90;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            #graph-overlay {
                width: 90%;
                left: 5%;
                bottom: 110px;
            }

            .charge-btn {
                width: 50px;
                height: 50px;
                font-size: 16px;
            }
        }
    </style>
</head>

<body>

    <div id="instruction">í„°ì¹˜í•˜ì—¬ ì‹¤í—˜í•´ë³´ì„¸ìš” (ë‘ ë²ˆ íƒ­í•˜ë©´ ì‚­ì œ)</div>
    <div id="tooltip"></div>

    <div id="top-controls" onpointerdown="event.stopPropagation()">
        <div class="control-group">
            <span style="font-weight:bold; display:block; margin-bottom:10px; color:white;">ğŸ‘ï¸ ë³´ê¸° ì„¤ì •</span>
            <label class="control-item"><input type="checkbox" id="chk-potential" checked> ë“±ì „ìœ„ë©´ (Heatmap)</label>
            <label class="control-item"><input type="checkbox" id="chk-field" checked> ì „ê¸°ì¥ (Vectors)</label>
        </div>

        <div class="control-group">
            <span style="font-weight:bold; display:block; margin-bottom:10px; color:white;">ğŸ› ï¸ ë„êµ¬ ì„ íƒ</span>
            <label class="control-item"><input type="radio" name="tool" value="cursor" checked> âœ‹ ê¸°ë³¸ (ì „í•˜ ì´ë™)</label>
            <label class="control-item"><input type="radio" name="tool" value="voltmeter"> âš¡ ì „ìœ„ì°¨ê³„ (Î”V)</label>
            <label class="control-item"><input type="radio" name="tool" value="graph"> ğŸ“ˆ ê·¸ë˜í”„ (ì„  ê¸‹ê¸°)</label>
        </div>
    </div>

    <div id="graph-overlay">
        <canvas id="graphCanvas" width="450" height="255"></canvas>
    </div>

    <canvas id="simCanvas"></canvas>

    <div id="ui-layer" onpointerdown="event.stopPropagation()">
        <div class="charge-btn pos-1" data-q="1">+1</div>
        <div class="charge-btn neg-1" data-q="-1">-1</div>
        <div class="charge-btn pos-2" data-q="2">+2</div>
        <div class="charge-btn neg-2" data-q="-2">-2</div>
    </div>

    <script>
        /** 1. ì „ì—­ ì„¤ì • ë° ë³€ìˆ˜ */
        const K = 8000;
        const FIELD_SPACING = 25;
        const MAX_ARROW_LEN = FIELD_SPACING * 0.95;
        const GRID_BACKGROUND_SPACING = 66;

        let charges = [];
        let testCharges = [];
        let canvas, ctx;
        let graphCanvas, graphCtx;
        let width, height;

        // í†µí•© ì¸í„°ë™ì…˜ ìƒíƒœ ê´€ë¦¬
        const InteractionState = {
            IDLE: 0,
            DRAGGING_CHARGE: 1,
            DRAGGING_NEW_CHARGE: 2,
            DRAGGING_VOLTMETER: 3,
            DRAWING_GRAPH: 4
        };

        let currentState = InteractionState.IDLE;
        let draggedObj = null;
        let dragOffsetX = 0, dragOffsetY = 0;
        let needsRedraw = true;
        let cachedBackground = null;
        let lastTapTime = 0;
        let newChargeQ = 0; // ìƒˆë¡œ ìƒì„± ì¤‘ì¸ ì „í•˜ëŸ‰

        let showPotential = true;
        let showField = true;
        let currentTool = 'cursor';

        const voltmeter = {
            probeA: { x: 100, y: 100, color: '#333333', label: 'COM' },
            probeB: { x: 200, y: 100, color: '#ff3333', label: '+' }
        };

        const graphTool = {
            startX: 0, startY: 0, endX: 0, endY: 0,
            data: []
        };

        /** 2. ì´ˆê¸°í™” */
        function init() {
            canvas = document.getElementById('simCanvas');
            ctx = canvas.getContext('2d', { alpha: false });

            graphCanvas = document.getElementById('graphCanvas');
            graphCtx = graphCanvas.getContext('2d');

            resize();
            window.addEventListener('resize', () => { resize(); needsRedraw = true; });

            // ì´ˆê¸° ì „í•˜ ë°°ì¹˜
            charges.push({ x: window.innerWidth / 2 - 100, y: window.innerHeight / 2, q: 1, r: 20 });
            charges.push({ x: window.innerWidth / 2 + 100, y: window.innerHeight / 2, q: -1, r: 20 });

            setupUI();
            setupPointerEvents(); // ì¤‘ìš”: ëª¨ë“  ì´ë²¤íŠ¸ëŠ” Pointer Eventë¡œ í†µí•©
            loop();
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;

            // ì „ìœ„ì°¨ê³„ ìœ„ì¹˜ í™”ë©´ ì•ˆìœ¼ë¡œ ë³´ì •
            voltmeter.probeA.x = Math.max(50, Math.min(width - 50, width / 2 - 60));
            voltmeter.probeA.y = Math.max(50, Math.min(height - 150, height - 150));
            voltmeter.probeB.x = Math.max(50, Math.min(width - 50, width / 2 + 60));
            voltmeter.probeB.y = Math.max(50, Math.min(height - 150, height - 150));
        }

        /** 3. ë¬¼ë¦¬ ì—”ì§„ */
        function getFieldAndPotential(x, y) {
            let Ex = 0, Ey = 0, V = 0;
            for (let c of charges) {
                let dx = x - c.x;
                let dy = y - c.y;
                let distSq = dx * dx + dy * dy;
                let dist = Math.sqrt(distSq);
                if (dist < 5) dist = 5;
                let E = (K * c.q) / Math.max(distSq, 25);
                Ex += E * (dx / dist);
                Ey += E * (dy / dist);
                V += (K * c.q) / dist;
            }
            return { Ex, Ey, V };
        }

        /** 4. ë©”ì¸ ë£¨í”„ */
        function loop() {
            if (needsRedraw) {
                drawBackground();
                needsRedraw = false;
            } else {
                if (cachedBackground) ctx.putImageData(cachedBackground, 0, 0);
                else { ctx.fillStyle = "#050505"; ctx.fillRect(0, 0, width, height); }
            }

            if (showField) drawFieldVectors();
            updateAndDrawTestCharges();
            drawCharges();

            if (currentTool === 'voltmeter') drawVoltmeter();
            if (currentState === InteractionState.DRAWING_GRAPH) drawGraphLine();

            // ëª¨ë°”ì¼ í„°ì¹˜ ì‹œì—ëŠ” íˆ´íŒ ìˆ¨ê¹€ (ì†ê°€ë½ì— ê°€ë¦¼ ë°©ì§€)
            // ë§ˆìš°ìŠ¤(hover)ì¼ ë•Œë§Œ í‘œì‹œí•˜ë„ë¡ ë¡œì§ ë³€ê²½ ê°€ëŠ¥í•˜ë‚˜, í˜„ì¬ëŠ” ìƒì‹œ ì—…ë°ì´íŠ¸
            // updateTooltip()ì€ pointermoveì—ì„œ ì²˜ë¦¬

            requestAnimationFrame(loop);
        }

        /** 5. ê·¸ë¦¬ê¸° í•¨ìˆ˜ë“¤ */
        function drawBackground() {
            if (!showPotential) {
                ctx.fillStyle = "#050505"; ctx.fillRect(0, 0, width, height);
            } else {
                const imgData = ctx.createImageData(width, height);
                const data = imgData.data;
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let { V } = getFieldAndPotential(x, y);
                        const idx = (y * width + x) * 4;
                        let intensity = Math.min(200, Math.abs(V) * 0.6);
                        let r = 0, g = 0, b = 0;
                        if (V > 0) { r = intensity; g = intensity * 0.1; b = intensity * 0.1; }
                        else { r = intensity * 0.1; g = intensity * 0.1; b = intensity; }

                        // ë“±ì „ìœ„ì„  íš¨ê³¼
                        let lineInterval = 40;
                        let lineFactor = (Math.abs(V) % lineInterval);
                        if (lineFactor < 2 || lineFactor > lineInterval - 2) { r += 50; g += 50; b += 50; }

                        data[idx] = r; data[idx + 1] = g; data[idx + 2] = b; data[idx + 3] = 255;
                    }
                }
                ctx.putImageData(imgData, 0, 0);
            }
            // ê·¸ë¦¬ë“œ
            ctx.save();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.1)"; ctx.lineWidth = 1;
            for (let x = GRID_BACKGROUND_SPACING; x < width; x += GRID_BACKGROUND_SPACING) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke();
            }
            for (let y = GRID_BACKGROUND_SPACING; y < height; y += GRID_BACKGROUND_SPACING) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke();
            }
            ctx.restore();
            cachedBackground = ctx.getImageData(0, 0, width, height);
        }

        function drawFieldVectors() {
            ctx.lineWidth = 1.0;
            for (let x = FIELD_SPACING / 2; x < width; x += FIELD_SPACING) {
                for (let y = FIELD_SPACING / 2; y < height; y += FIELD_SPACING) {
                    let { Ex, Ey } = getFieldAndPotential(x, y);
                    let E_mag = Math.hypot(Ex, Ey);
                    if (E_mag < 0.01) continue;
                    let ux = Ex / E_mag, uy = Ey / E_mag;
                    let len = MAX_ARROW_LEN * (E_mag / (E_mag + 0.6));
                    if (len > MAX_ARROW_LEN) len = MAX_ARROW_LEN;
                    if (len < 3) continue;

                    const halfLen = len / 2;
                    ctx.strokeStyle = `rgba(255, 240, 50, ${Math.min(1, len / 10)})`;
                    ctx.fillStyle = ctx.strokeStyle;

                    ctx.beginPath();
                    ctx.moveTo(x - ux * halfLen, y - uy * halfLen);
                    ctx.lineTo(x + ux * halfLen, y + uy * halfLen);
                    ctx.stroke();

                    // í™”ì‚´í‘œ ë¨¸ë¦¬
                    const headSize = Math.max(2, len * 0.25);
                    const endX = x + ux * halfLen, endY = y + uy * halfLen;
                    ctx.beginPath();
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(endX - headSize * ux + headSize * 0.5 * uy, endY - headSize * uy - headSize * 0.5 * ux);
                    ctx.lineTo(endX - headSize * ux - headSize * 0.5 * uy, endY - headSize * uy + headSize * 0.5 * ux);
                    ctx.fill();
                }
            }
        }

        function drawCharges() {
            ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.font = "bold 16px Arial";
            charges.forEach(c => {
                ctx.beginPath(); ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
                if (c.q > 0) { ctx.fillStyle = "#ff3333"; ctx.shadowColor = "#ff0000"; }
                else { ctx.fillStyle = "#3333ff"; ctx.shadowColor = "#0000ff"; }
                ctx.shadowBlur = 15; ctx.fill(); ctx.shadowBlur = 0;
                ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.stroke();
                ctx.fillStyle = "white"; ctx.fillText(c.q > 0 ? "+" + c.q : c.q, c.x, c.y);
            });
        }

        function updateAndDrawTestCharges() {
            ctx.fillStyle = "#ffff00";
            for (let i = testCharges.length - 1; i >= 0; i--) {
                let p = testCharges[i];
                let { Ex, Ey } = getFieldAndPotential(p.x, p.y);
                p.vx += Ex * 0.1; p.vy += Ey * 0.1;
                let speed = Math.hypot(p.vx, p.vy);
                if (speed > 12) { p.vx = (p.vx / speed) * 12; p.vy = (p.vy / speed) * 12; }
                p.x += p.vx; p.y += p.vy; p.life--;

                // ì¶©ëŒ ê²€ì‚¬
                let hit = false;
                for (let c of charges) if (Math.hypot(p.x - c.x, p.y - c.y) < c.r) hit = true;

                if (p.life <= 0 || hit || p.x < -50 || p.x > width + 50 || p.y < -50 || p.y > height + 50) {
                    testCharges.splice(i, 1);
                } else {
                    ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI * 2); ctx.fill();
                }
            }
        }

        function drawVoltmeter() {
            const probes = [voltmeter.probeA, voltmeter.probeB];
            const values = [];

            ctx.save();
            ctx.setLineDash([5, 5]); ctx.strokeStyle = "rgba(255,255,255,0.4)";
            ctx.beginPath(); ctx.moveTo(probes[0].x, probes[0].y); ctx.lineTo(probes[1].x, probes[1].y); ctx.stroke();
            ctx.restore();

            probes.forEach(p => {
                ctx.beginPath(); ctx.arc(p.x, p.y, 16, 0, Math.PI * 2);
                ctx.fillStyle = p.color; ctx.fill();
                ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.stroke();
                // í•€ ëª¨ì–‘
                ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y + 22); ctx.stroke();

                const { V } = getFieldAndPotential(p.x, p.y);
                values.push(V);
                ctx.fillStyle = "white"; ctx.font = "12px monospace";
                ctx.fillText(`${V.toFixed(1)}V`, p.x, p.y - 25);
            });

            // ì¤‘ì•™ ê³„ê¸°íŒ
            const cx = (probes[0].x + probes[1].x) / 2;
            const cy = (probes[0].y + probes[1].y) / 2;
            const diff = values[1] - values[0];

            ctx.fillStyle = "rgba(0,0,0,0.85)"; ctx.fillRect(cx - 60, cy - 15, 120, 30);
            ctx.strokeStyle = "#00ffcc"; ctx.lineWidth = 1; ctx.strokeRect(cx - 60, cy - 15, 120, 30);
            ctx.fillStyle = "#00ffcc"; ctx.font = "bold 14px monospace";
            ctx.fillText(`Î”V: ${diff.toFixed(2)}`, cx, cy);
        }

        function drawGraphLine() {
            ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.setLineDash([4, 4]);
            ctx.beginPath(); ctx.moveTo(graphTool.startX, graphTool.startY);
            ctx.lineTo(graphTool.endX, graphTool.endY); ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = "white";
            ctx.beginPath(); ctx.arc(graphTool.startX, graphTool.startY, 4, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(graphTool.endX, graphTool.endY, 4, 0, Math.PI * 2); ctx.fill();
        }

        /** 6. UI ë° ì´ë²¤íŠ¸ ì²˜ë¦¬ (í•µì‹¬ ë³€ê²½ ë¶€ë¶„) */
        function setupUI() {
            // 1. ë„êµ¬ ë¼ë””ì˜¤ ë²„íŠ¼
            document.getElementsByName('tool').forEach(r => {
                r.addEventListener('change', (e) => {
                    currentTool = e.target.value;
                    const instruction = document.getElementById('instruction');
                    const graphOverlay = document.getElementById('graph-overlay');

                    if (currentTool === 'cursor') {
                        instruction.innerText = "ê¸°ë³¸ ëª¨ë“œ: ì „í•˜ ë“œë˜ê·¸ / ë¹ˆ ê³³ í„°ì¹˜í•˜ì—¬ ì‹œí—˜ì „í•˜";
                        graphOverlay.style.display = 'none';
                    } else if (currentTool === 'voltmeter') {
                        instruction.innerText = "ì „ìœ„ì°¨ê³„: íƒì¹¨ì„ ë“œë˜ê·¸í•˜ì—¬ ì „ìœ„ì°¨ ì¸¡ì •";
                        graphOverlay.style.display = 'none';
                    } else if (currentTool === 'graph') {
                        instruction.innerText = "ê·¸ë˜í”„: í™”ë©´ì„ ë“œë˜ê·¸í•˜ì—¬ ì„  ê¸‹ê¸°";
                        graphOverlay.style.display = 'block';
                        // ê·¸ë˜í”„ ì´ˆê¸°í™”
                        graphCtx.clearRect(0, 0, 450, 255);
                    }
                });
            });

            // 2. ì²´í¬ë°•ìŠ¤
            document.getElementById('chk-potential').addEventListener('change', e => { showPotential = e.target.checked; needsRedraw = true; });
            document.getElementById('chk-field').addEventListener('change', e => { showField = e.target.checked; });

            // 3. í•˜ë‹¨ ì „í•˜ ë²„íŠ¼ (Pointer Eventë¡œ ì²˜ë¦¬)
            document.querySelectorAll('.charge-btn').forEach(btn => {
                btn.addEventListener('pointerdown', (e) => {
                    // UI ë ˆì´ì–´ì˜ stopPropagationì—ë„ ë¶ˆêµ¬í•˜ê³ , ë²„íŠ¼ ìì²´ ë™ì‘ ì •ì˜
                    e.preventDefault();
                    const q = parseInt(btn.getAttribute('data-q'));
                    startDraggingNewCharge(e, q, btn);
                });
            });
        }

        // ìƒˆ ì „í•˜ ë“œë˜ê·¸ ì‹œì‘
        function startDraggingNewCharge(e, q, sourceBtn) {
            currentState = InteractionState.DRAGGING_NEW_CHARGE;
            newChargeQ = q;

            // ìœ ë ¹ ìš”ì†Œ ìƒì„±
            const ghost = sourceBtn.cloneNode(true);
            ghost.id = 'ghost-charge';
            ghost.classList.add('ghost-charge');
            // ì´ˆê¸° ìœ„ì¹˜
            const rect = sourceBtn.getBoundingClientRect();
            ghost.style.left = (rect.left + rect.width / 2) + 'px';
            ghost.style.top = (rect.top + rect.height / 2) + 'px';

            // ë°°ê²½ìƒ‰ ë“± ìŠ¤íƒ€ì¼ ê°•ì œ ë³µì‚¬ (cloneNode ë²„ê·¸ ë°©ì§€)
            const computedStyle = window.getComputedStyle(sourceBtn);
            ghost.style.background = computedStyle.background;
            ghost.style.borderColor = computedStyle.borderColor;

            document.body.appendChild(ghost);
        }

        // í†µí•© Pointer Event ë¦¬ìŠ¤ë„ˆ (Canvasê°€ ì•„ë‹Œ Window ì „ì²´ì—ì„œ ì²˜ë¦¬í•˜ì—¬ ëŠê¹€ ë°©ì§€)
        function setupPointerEvents() {

            // Canvas ëˆ„ë¦„ (ì‹œì‘)
            canvas.addEventListener('pointerdown', (e) => {
                if (currentState !== InteractionState.IDLE) return;

                e.preventDefault();
                const { x, y } = getPointerPos(e);
                const now = Date.now();

                // ë”ë¸” íƒ­ ì‚­ì œ (ì „í•˜ ì‚­ì œ)
                if (currentTool === 'cursor' && now - lastTapTime < 300) {
                    for (let i = 0; i < charges.length; i++) {
                        if (Math.hypot(x - charges[i].x, y - charges[i].y) < charges[i].r * 1.5) {
                            charges.splice(i, 1);
                            needsRedraw = true;
                            return;
                        }
                    }
                }
                lastTapTime = now;

                // 1. ì „ìœ„ì°¨ê³„ ë“œë˜ê·¸
                if (currentTool === 'voltmeter') {
                    if (Math.hypot(x - voltmeter.probeA.x, y - voltmeter.probeA.y) < 40) {
                        currentState = InteractionState.DRAGGING_VOLTMETER;
                        draggedObj = voltmeter.probeA;
                    } else if (Math.hypot(x - voltmeter.probeB.x, y - voltmeter.probeB.y) < 40) {
                        currentState = InteractionState.DRAGGING_VOLTMETER;
                        draggedObj = voltmeter.probeB;
                    }
                    return;
                }

                // 2. ê¸°ì¡´ ì „í•˜ ë“œë˜ê·¸
                if (currentTool === 'cursor') {
                    for (let c of charges) {
                        if (Math.hypot(x - c.x, y - c.y) < c.r * 2) {
                            currentState = InteractionState.DRAGGING_CHARGE;
                            draggedObj = c;
                            dragOffsetX = x - c.x;
                            dragOffsetY = y - c.y;
                            return;
                        }
                    }
                    // ì•„ë¬´ê²ƒë„ ì•ˆ ì¡ì•˜ìœ¼ë©´ ì‹œí—˜ ì „í•˜ ë°œì‚¬
                    testCharges.push({ x, y, vx: 0, vy: 0, life: 400 });
                }

                // 3. ê·¸ë˜í”„ ê·¸ë¦¬ê¸°
                if (currentTool === 'graph') {
                    currentState = InteractionState.DRAWING_GRAPH;
                    graphTool.startX = x; graphTool.startY = y;
                    graphTool.endX = x; graphTool.endY = y;
                }
            });

            // Window ì „ì²´ì—ì„œ ì›€ì§ì„ ê°ì§€
            window.addEventListener('pointermove', (e) => {
                const { x, y } = getPointerPos(e); // Canvas ê¸°ì¤€ ì¢Œí‘œ

                // íˆ´íŒ ì—…ë°ì´íŠ¸ (ëª¨ë°”ì¼ì´ ì•„ë‹ ë•Œ í˜¹ì€ ë“œë˜ê·¸ ì•ˆí•  ë•Œ)
                if (currentState === InteractionState.IDLE) {
                    updateTooltip(x, y);
                } else {
                    document.getElementById('tooltip').style.display = 'none';
                }

                // ìƒíƒœë³„ ì²˜ë¦¬
                if (currentState === InteractionState.DRAGGING_NEW_CHARGE) {
                    // ìœ ë ¹ ìš”ì†Œ ì´ë™ (Client ì¢Œí‘œ ì‚¬ìš©)
                    const ghost = document.getElementById('ghost-charge');
                    if (ghost) {
                        ghost.style.left = e.clientX + 'px';
                        ghost.style.top = e.clientY + 'px';
                    }
                }
                else if (currentState === InteractionState.DRAGGING_CHARGE && draggedObj) {
                    draggedObj.x = x - dragOffsetX;
                    draggedObj.y = y - dragOffsetY;
                    needsRedraw = true;
                }
                else if (currentState === InteractionState.DRAGGING_VOLTMETER && draggedObj) {
                    draggedObj.x = x; draggedObj.y = y;
                }
                else if (currentState === InteractionState.DRAWING_GRAPH) {
                    graphTool.endX = x; graphTool.endY = y;
                }
            }, { passive: false });

            // ë“œë˜ê·¸ ì¢…ë£Œ (Window ì „ì²´)
            window.addEventListener('pointerup', (e) => {
                if (currentState === InteractionState.IDLE) return;

                // ìƒˆ ì „í•˜ ë°°ì¹˜ ë¡œì§
                if (currentState === InteractionState.DRAGGING_NEW_CHARGE) {
                    const ghost = document.getElementById('ghost-charge');
                    if (ghost) ghost.remove();

                    // ìº”ë²„ìŠ¤ ì˜ì—­ ìœ„ì¸ì§€ í™•ì¸
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX;
                    const y = e.clientY;

                    if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                        charges.push({
                            x: x - rect.left,
                            y: y - rect.top,
                            q: newChargeQ,
                            r: 20 + Math.abs(newChargeQ) * 5
                        });
                        needsRedraw = true;
                    }
                }
                // ê·¸ë˜í”„ ê³„ì‚°
                else if (currentState === InteractionState.DRAWING_GRAPH) {
                    calculateAndDrawGraph();
                }

                // ìƒíƒœ ì´ˆê¸°í™”
                currentState = InteractionState.IDLE;
                draggedObj = null;
            });
        }

        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        function updateTooltip(x, y) {
            // Canvas ë²”ìœ„ ë°–ì´ë©´ ìˆ¨ê¹€
            if (x < 0 || x > width || y < 0 || y > height) {
                document.getElementById('tooltip').style.display = 'none';
                return;
            }

            // ëª¨ë°”ì¼(í„°ì¹˜ ì§€ì›)ì—ì„œëŠ” ë“œë˜ê·¸ ì¤‘ì´ ì•„ë‹ˆë©´ êµ³ì´ íˆ´íŒì„ ë„ìš°ì§€ ì•Šê±°ë‚˜ ìœ„ì¹˜ ì¡°ì •
            const isTouch = (navigator.maxTouchPoints > 0);
            if (isTouch) {
                // ëª¨ë°”ì¼ì—ì„œëŠ” ê·¸ëƒ¥ ìˆ¨ê¸°ëŠ”ê²Œ ì¡°ì‘ê°ì´ ë” ì¢‹ìŒ (ì†ê°€ë½ì— ê°€ë¦¼)
                // í•„ìš”í•˜ë©´ ì£¼ì„ í•´ì œ
                // return; 
            }

            let { Ex, Ey, V } = getFieldAndPotential(x, y);
            let E_mag = Math.hypot(Ex, Ey).toFixed(2);
            let tooltip = document.getElementById('tooltip');

            tooltip.style.display = 'block';
            tooltip.style.left = (x + 20 + canvas.getBoundingClientRect().left) + 'px';
            tooltip.style.top = (y - 40 + canvas.getBoundingClientRect().top) + 'px';
            tooltip.innerHTML = `ì „ìœ„(V): ${V.toFixed(2)}<br>ì „ê¸°ì¥(E): ${E_mag}`;
        }

        // ê·¸ë˜í”„ ê³„ì‚° (ì´ì „ ì½”ë“œì™€ ë™ì¼ ë…¼ë¦¬)
        function calculateAndDrawGraph() {
            const p1 = { x: graphTool.startX, y: graphTool.startY };
            const p2 = { x: graphTool.endX, y: graphTool.endY };
            const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            if (dist < 10) return;

            const dx = p2.x - p1.x, dy = p2.y - p1.y;
            const ux = dx / dist, uy = dy / dist;
            const samples = 150;
            const data = [];
            let maxV = 1, maxE = 1;

            for (let i = 0; i <= samples; i++) {
                let t = i / samples;
                let x = p1.x + dx * t, y = p1.y + dy * t;
                let { Ex, Ey, V } = getFieldAndPotential(x, y);
                let E_proj = Ex * ux + Ey * uy;
                if (Math.abs(V) > maxV) maxV = Math.abs(V);
                if (Math.abs(E_proj) > maxE) maxE = Math.abs(E_proj);
                data.push({ t, V, E: E_proj });
            }

            const gw = graphCanvas.width, gh = graphCanvas.height;
            const cy = gh / 2;
            graphCtx.clearRect(0, 0, gw, gh);

            // ì¶• ê·¸ë¦¬ê¸°
            graphCtx.strokeStyle = "#555"; graphCtx.lineWidth = 1;
            graphCtx.beginPath(); graphCtx.moveTo(40, 10); graphCtx.lineTo(40, gh - 10);
            graphCtx.moveTo(40, cy); graphCtx.lineTo(gw - 10, cy); graphCtx.stroke();
            graphCtx.fillStyle = "#888"; graphCtx.font = "12px sans-serif"; graphCtx.fillText("0", 25, cy + 4);

            const scaleV = (gh * 0.4) / (maxV > 0.1 ? maxV : 1);
            const scaleE = (gh * 0.4) / (maxE > 0.1 ? maxE : 1);

            // V ê·¸ë˜í”„
            graphCtx.beginPath(); graphCtx.strokeStyle = "#ff4444"; graphCtx.lineWidth = 2;
            for (let i = 0; i < data.length; i++) {
                let px = 40 + data[i].t * (gw - 50);
                let py = cy - (data[i].V * scaleV);
                py = Math.max(5, Math.min(gh - 5, py));
                if (i === 0) graphCtx.moveTo(px, py); else graphCtx.lineTo(px, py);
            }
            graphCtx.stroke();

            // E ê·¸ë˜í”„
            graphCtx.beginPath(); graphCtx.strokeStyle = "#ffff00"; graphCtx.lineWidth = 2;
            for (let i = 0; i < data.length; i++) {
                let px = 40 + data[i].t * (gw - 50);
                let py = cy - (data[i].E * scaleE);
                py = Math.max(5, Math.min(gh - 5, py));
                if (i === 0) graphCtx.moveTo(px, py); else graphCtx.lineTo(px, py);
            }
            graphCtx.stroke();

            // ë²”ë¡€
            graphCtx.textAlign = "left";
            graphCtx.fillStyle = "#ff4444"; graphCtx.fillText(`V (Max: Â±${maxV.toFixed(1)})`, 50, 20);
            graphCtx.fillStyle = "#ffff00"; graphCtx.fillText(`E (Max: Â±${maxE.toFixed(1)})`, 50, 38);
        }

        init();
    </script>
</body>

</html>