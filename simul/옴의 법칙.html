<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Ïò¥Ïùò Î≤ïÏπô</title>
  <style>
    :root {
      --bg-color: #f8fafc;
      /* ÏïÑÏ£º Î∞ùÍ≥† Íπ®ÎÅóÌïú Î∞∞Í≤Ω */
      --glass: rgba(255, 255, 255, 0.9);
      /* Îçú Ìà¨Î™ÖÌïòÍ≤å ÏàòÏ†ï */
      --border: rgba(148, 163, 184, 0.4);
      --primary: #0284c7;
      --text: #0f172a;
    }

    body {
      margin: 0;
      overflow: hidden;
      background: var(--bg-color);
      color: var(--text);
      font-family: "Pretendard", system-ui, sans-serif;
      user-select: none;
      -webkit-user-select: none;
    }

    header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 24px;
      pointer-events: none;
      z-index: 10;
    }

    .brand {
      font-size: 20px;
      font-weight: 800;
      color: #334155;
      pointer-events: auto;
    }

    .brand span {
      color: var(--primary);
    }

    /* [Ï∂îÍ∞ÄÎê®] ÏûêÏú†Ïã§ÌóòÏã§ Ïù¥Îèô Î≤ÑÌäº Ïä§ÌÉÄÏùº */
    .btn-link {
      position: absolute;
      top: 60px;
      left: 24px;
      /* Ìó§Îçî Î∞îÎ°ú ÏïÑÎûò ÏúÑÏπò */
      padding: 8px 20px;
      background: #ffffff;
      border: 1px solid var(--primary);
      border-radius: 20px;
      /* Îë•Í∑º Î™®Ïñë */
      color: var(--primary);
      font-weight: 700;
      font-size: 13px;
      cursor: pointer;
      z-index: 20;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
      transition: all 0.2s ease;
    }

    .btn-link:hover {
      background: var(--primary);
      color: white;
      transform: translateY(-2px);
      box-shadow: 0 6px 15px rgba(2, 132, 199, 0.25);
    }

    /* Ïª®Ìä∏Î°§ Ìå®ÎÑê */
    .hud {
      position: absolute;
      left: 20px;
      bottom: 20px;
      width: 300px;
      background: var(--glass);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      z-index: 10;
      box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 13px;
      font-weight: 600;
      color: #64748b;
    }

    .val {
      color: var(--primary);
      font-family: monospace;
      font-size: 15px;
      font-weight: 700;
    }

    input[type=range] {
      -webkit-appearance: none;
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: #cbd5e1;
      outline: none;
      cursor: pointer;
      margin-top: 6px;
    }

    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #ffffff;
      border: 2px solid var(--primary);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    /* Í∑∏ÎûòÌîÑ Ìå®ÎÑê */
    .graph-box {
      position: absolute;
      right: 20px;
      bottom: 20px;
      width: 340px;
      height: 200px;
      /* ÌÅ¨Í∏∞ ÏïΩÍ∞Ñ ÌôïÎåÄ */
      background: var(--glass);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px;
      z-index: 10;
      box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
    }

    canvas#graph {
      width: 100%;
      height: 100%;
    }

    .btn-reset {
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 8px 16px;
      background: #fff;
      border: 1px solid #cbd5e1;
      border-radius: 8px;
      font-weight: 600;
      color: #475569;
      cursor: pointer;
      z-index: 20;
      font-size: 12px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
      transition: 0.2s;
    }

    .btn-reset:hover {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>

<body>

  <header>
    <div class="brand">‚ö° Ïò¥Ïùò Î≤ïÏπô <span>ÏãúÎÆ¨Î†àÏù¥ÏÖò</span></div>
  </header>

  <button class="btn-link" onclick="location.href='./Ïò¥Ïùò Î≤ïÏπôsb.html'">üß™ ÏûêÏú†Ïã§ÌóòÏã§ Ïù¥Îèô</button>

  <div id="scene"></div>
  <button class="btn-reset" id="btnReset">Ïπ¥Î©îÎùº Ï¥àÍ∏∞Ìôî</button>

  <div class="hud">
    <div>
      <div class="row"><span>ÎèÑÏÑ† ÎëêÍªò (Area)</span> <span class="val" id="vA">10.0 „éü</span></div>
      <input id="sA" type="range" min="1.0" max="10" step="0.5" value="10.0">
    </div>
    <div>
      <div class="row"><span>ÎèÑÏÑ† Í∏∏Ïù¥ (Length)</span> <span class="val" id="vL">10.0 „éù</span></div>
      <input id="sL" type="range" min="1" max="10" step="0.5" value="10.0">
    </div>
    <div>
      <div class="row"><span>ÏßÅÎ†¨ Ïó∞Í≤∞ (Ns)</span> <span class="val" id="vNs">1</span></div>
      <input id="sNs" type="range" min="1" max="5" step="1" value="1">
    </div>
    <div>
      <div class="row"><span>Î≥ëÎ†¨ Ïó∞Í≤∞ (Np)</span> <span class="val" id="vNp">1</span></div>
      <input id="sNp" type="range" min="1" max="4" step="1" value="1">
    </div>
  </div>

  <div class="graph-box">
    <canvas id="graph"></canvas>
  </div>

  <script>
    (function () {
      // --- 1. ÏÉÅÌÉú Î∞è ÏÉÅÏàò ---
      const V_SOURCE = 6.0;
      const SIM_RHO = 1.0; // L=10, A=10Ïùº Îïå R=1Ïò¥Ïù¥ ÎêòÎèÑÎ°ù ÏÑ§Ï†ï

      const state = { A: 10.0, L: 10.0, Ns: 1, Np: 1, I: 0 };
      let electronPaths = [];

      // --- 2. Three.js Ïî¨ ÏÑ§Ï†ï ---
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf8fafc); // ÎßëÍ≥† Íπ®ÎÅóÌïú Î∞∞Í≤Ω
      // scene.fog Ï†úÍ±∞ (Íµ¨Î¶Ñ Ìö®Í≥º ÏÇ≠Ï†ú)

      const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 15, 60);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      document.getElementById('scene').appendChild(renderer.domElement);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.maxPolarAngle = Math.PI / 1.9;

      // --- Ï°∞Î™Ö & ÌôòÍ≤Ω ---
      const ambLight = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(20, 40, 30);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      scene.add(dirLight);

      // Î∞îÎã• Í∑∏Î¶¨Îìú
      const grid = new THREE.GridHelper(200, 50, 0xcbd5e1, 0xe2e8f0);
      grid.position.y = -8;
      scene.add(grid);

      // Î∞îÎã• Ìåê
      const floorGeo = new THREE.PlaneGeometry(300, 300);
      const floorMat = new THREE.MeshStandardMaterial({ color: 0xf1f5f9, roughness: 0.8 });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -8.01;
      floor.receiveShadow = true;
      scene.add(floor);

      // --- Î®∏Ìã∞Î¶¨Ïñº ---
      const matWire = new THREE.MeshPhysicalMaterial({
        color: 0xffffff, metalness: 0.95, roughness: 0.15, clearcoat: 1.0, reflectivity: 1.0
      });
      const matJoint = new THREE.MeshStandardMaterial({ color: 0x94a3b8, metalness: 0.8, roughness: 0.3 });
      const matResistorBody = new THREE.MeshPhysicalMaterial({
        color: 0xd97706, metalness: 0.1, roughness: 0.3, clearcoat: 0.2
      });
      const matBand = new THREE.MeshBasicMaterial({ color: 0x1e293b });
      const matVoltBody = new THREE.MeshStandardMaterial({ color: 0xef4444, roughness: 0.3 });
      const matAmpBody = new THREE.MeshStandardMaterial({ color: 0x0ea5e9, roughness: 0.3 });
      const matElectron = new THREE.MeshBasicMaterial({ color: 0x0ea5e9 });

      const circuitGroup = new THREE.Group(); scene.add(circuitGroup);
      const electronGroup = new THREE.Group(); scene.add(electronGroup);

      // --- Í≥ÑÏ∏°Í∏∞ ÌÖçÏä§Ï≤ò ---
      let vTex, aTex;
      function createMeterLabel() {
        const cvs = document.createElement('canvas'); cvs.width = 256; cvs.height = 128;
        const ctx = cvs.getContext('2d');
        const tex = new THREE.CanvasTexture(cvs);
        return { ctx, tex, cvs };
      }
      vTex = createMeterLabel(); aTex = createMeterLabel();

      function updateMeter(info, val, unit, col) {
        const { ctx, tex, cvs } = info;
        ctx.fillStyle = '#e2e8f0';
        ctx.fillRect(0, 0, cvs.width, cvs.height);

        ctx.lineWidth = 4; ctx.strokeStyle = '#cbd5e1'; ctx.strokeRect(0, 0, cvs.width, cvs.height);

        ctx.font = 'bold 50px monospace'; ctx.fillStyle = '#1e293b';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(val.toFixed(2), cvs.width / 2, cvs.height / 2 - 12);

        ctx.font = 'bold 24px monospace'; ctx.fillStyle = col;
        ctx.fillText(unit, cvs.width / 2, cvs.height / 2 + 28);

        tex.needsUpdate = true;
      }

      // --- ÏßÄÏò§Î©îÌä∏Î¶¨ ÎπåÎçî ---
      function createPipe(p1, p2, radius, mat) {
        const vec = new THREE.Vector3().subVectors(p2, p1);
        const len = vec.length(); if (len < 0.001) return;
        const geo = new THREE.CylinderGeometry(radius, radius, len, 16);
        geo.rotateX(Math.PI / 2);
        const m = new THREE.Mesh(geo, mat);
        m.position.copy(p1.clone().add(p2).multiplyScalar(0.5));
        m.lookAt(p2); m.castShadow = true;
        circuitGroup.add(m);
      }

      function createJoint(pos, r) {
        const m = new THREE.Mesh(new THREE.SphereGeometry(r * 1.1, 16, 16), matJoint);
        m.position.copy(pos); m.castShadow = true;
        circuitGroup.add(m);
      }

      function createResistor(p1, p2, radius) {
        const vec = new THREE.Vector3().subVectors(p2, p1);
        const len = vec.length();
        const geo = new THREE.CylinderGeometry(radius, radius, len, 32);
        geo.rotateX(Math.PI / 2);
        const m = new THREE.Mesh(geo, matResistorBody);
        m.position.copy(p1.clone().add(p2).multiplyScalar(0.5));
        m.lookAt(p2); m.castShadow = true;
        circuitGroup.add(m);

        [0.2, 0.4, 0.6, 0.8].forEach(t => {
          const bandPos = p1.clone().lerp(p2, t);
          const bGeo = new THREE.CylinderGeometry(radius * 1.05, radius * 1.05, len * 0.06, 16);
          bGeo.rotateX(Math.PI / 2);
          const band = new THREE.Mesh(bGeo, matBand);
          band.position.copy(bandPos); band.lookAt(p2);
          circuitGroup.add(band);
        });
      }

      function createBoxMeter(pos, isV) {
        const grp = new THREE.Group(); grp.position.copy(pos);
        const mat = isV ? matVoltBody : matAmpBody;
        const box = new THREE.Mesh(new THREE.BoxGeometry(4.2, 2.6, 1.5), mat);
        box.castShadow = true;
        grp.add(box);

        const scn = new THREE.Mesh(
          new THREE.PlaneGeometry(3.6, 2.0),
          new THREE.MeshBasicMaterial({ map: (isV ? vTex.tex : aTex.tex) })
        );
        scn.position.z = 0.76;
        grp.add(scn);

        circuitGroup.add(grp);
        return { L: new THREE.Vector3(pos.x - 2.1, pos.y, pos.z), R: new THREE.Vector3(pos.x + 2.1, pos.y, pos.z) };
      }

      function createBattery() {
        const g = new THREE.Group(); g.position.y = -4;
        const b = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 6, 32), new THREE.MeshStandardMaterial({ color: 0x1e293b, roughness: 0.2 }));
        b.rotation.z = Math.PI / 2; b.castShadow = true; g.add(b);
        const p = new THREE.Mesh(new THREE.CylinderGeometry(2.1, 2.1, 1.2, 32), new THREE.MeshStandardMaterial({ color: 0xf59e0b, metalness: 1 }));
        p.rotation.z = Math.PI / 2; p.position.x = -3.1; g.add(p);
        const nub = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 0.8, 32), new THREE.MeshStandardMaterial({ color: 0xf59e0b, metalness: 1 }));
        nub.rotation.z = Math.PI / 2; nub.position.x = -4.0; g.add(nub);
        const n = new THREE.Mesh(new THREE.CylinderGeometry(2.1, 2.1, 0.5, 32), matJoint);
        n.rotation.z = Math.PI / 2; n.position.x = 3.0; g.add(n);
        circuitGroup.add(g);
        return { P: new THREE.Vector3(-4.4, -4, 0), N: new THREE.Vector3(3.25, -4, 0) };
      }

      // --- ÌöåÎ°ú Íµ¨ÏÑ± (ÏúÑÎ°ú ÏåìÍ∏∞) ---
      function rebuildCircuit() {
        while (circuitGroup.children.length > 0) circuitGroup.remove(circuitGroup.children[0]);
        electronPaths = [];

        const WIRE_R = 0.35;
        const RES_R = Math.sqrt(state.A) * 0.35;
        const RES_LEN = state.L * 1.0;
        const GAP_S = 1.5;
        const GAP_P = 4.5;

        const totalResW = (state.Ns * RES_LEN) + ((state.Ns - 1) * GAP_S);
        const frameW = Math.max(30, totalResW + 14);
        const halfW = frameW / 2;

        const bat = createBattery();
        const batY = -4;

        const volt = createBoxMeter(new THREE.Vector3(-8, batY, 0), true);
        const amp = createBoxMeter(new THREE.Vector3(8, batY, 0), false);

        const BASE_Y = 2.0;
        const TOP_Y = BASE_Y + (state.Np - 1) * GAP_P;

        const pBusL_Bot = new THREE.Vector3(-halfW, batY, 0);
        const pBusL_Top = new THREE.Vector3(-halfW, TOP_Y, 0);
        const pBusR_Bot = new THREE.Vector3(halfW, batY, 0);
        const pBusR_Top = new THREE.Vector3(halfW, TOP_Y, 0);

        createPipe(pBusL_Bot, pBusL_Top, WIRE_R, matWire);
        createPipe(pBusR_Bot, pBusR_Top, WIRE_R, matWire);
        createJoint(pBusL_Bot, WIRE_R); createJoint(pBusL_Top, WIRE_R);
        createJoint(pBusR_Bot, WIRE_R); createJoint(pBusR_Top, WIRE_R);

        createPipe(bat.P, volt.R, WIRE_R, matVoltBody);
        createPipe(volt.L, pBusL_Bot, WIRE_R, matVoltBody);
        createJoint(volt.L, WIRE_R); createJoint(volt.R, WIRE_R);

        createPipe(bat.N, amp.L, WIRE_R, matAmpBody);
        createPipe(amp.R, pBusR_Bot, WIRE_R, matAmpBody);
        createJoint(amp.L, WIRE_R); createJoint(amp.R, WIRE_R);

        for (let i = 0; i < state.Np; i++) {
          const y = BASE_Y + (i * GAP_P);
          const path = [];

          path.push(bat.P.clone());
          path.push(volt.R.clone()); path.push(volt.L.clone());
          path.push(pBusL_Bot.clone());
          path.push(new THREE.Vector3(-halfW, y, 0));

          const pLeft = new THREE.Vector3(-halfW, y, 0);
          const pResStart = new THREE.Vector3(-totalResW / 2, y, 0);
          createJoint(pLeft, WIRE_R);
          createPipe(pLeft, pResStart, WIRE_R, matWire);
          path.push(pLeft.clone());
          path.push(pResStart.clone());

          let currX = -totalResW / 2;
          for (let j = 0; j < state.Ns; j++) {
            const p1 = new THREE.Vector3(currX, y, 0);
            const p2 = new THREE.Vector3(currX + RES_LEN, y, 0);
            createResistor(p1, p2, RES_R);
            path.push(p1.clone()); path.push(p2.clone());

            currX += RES_LEN;
            if (j < state.Ns - 1) {
              const pNext = new THREE.Vector3(currX + GAP_S, y, 0);
              createPipe(p2, pNext, WIRE_R, matWire);
              path.push(pNext.clone());
              currX += GAP_S;
            }
          }

          const pResEnd = new THREE.Vector3(currX, y, 0);
          const pRight = new THREE.Vector3(halfW, y, 0);
          createPipe(pResEnd, pRight, WIRE_R, matWire);
          createJoint(pRight, WIRE_R);
          path.push(pResEnd.clone());
          path.push(pRight.clone());

          path.push(pBusR_Bot.clone());
          path.push(amp.R.clone()); path.push(amp.L.clone());
          path.push(bat.N.clone());

          electronPaths.push(path);
        }
      }

      // --- Ï†ÑÏûê Ïï†ÎãàÎ©îÏù¥ÏÖò ---
      const electrons = []; const MAX_E = 300;
      const eGeo = new THREE.SphereGeometry(0.35, 8, 8);
      for (let i = 0; i < MAX_E; i++) {
        const m = new THREE.Mesh(eGeo, matElectron);
        m.visible = false; electronGroup.add(m);
        electrons.push({ mesh: m, t: 0, pathIdx: 0, active: false });
      }

      function updateElectrons(dt) {
        const count = Math.min(MAX_E, Math.floor(state.I * 20));
        const speed = state.I * 1.5;
        let activeCnt = 0;

        if (electronPaths.length > 0) {
          for (let i = 0; i < count; i++) {
            const e = electrons[i];
            if (!e.active) {
              e.active = true; e.mesh.visible = true;
              e.pathIdx = i % electronPaths.length;
              const p = electronPaths[e.pathIdx];
              if (p) e.t = Math.random() * (p.length - 1);
            }
            const path = electronPaths[e.pathIdx];
            if (!path) { e.pathIdx = 0; continue; }

            e.t += speed * dt;
            if (e.t >= path.length - 1) e.t = 0;

            const idx = Math.floor(e.t);
            const alpha = e.t - idx;
            if (path[idx] && path[idx + 1]) e.mesh.position.lerpVectors(path[idx], path[idx + 1], alpha);
            activeCnt++;
          }
        }
        for (let i = activeCnt; i < MAX_E; i++) { electrons[i].active = false; electrons[i].mesh.visible = false; }
      }

      // --- Í∑∏ÎûòÌîÑ (Auto-Scaling & Labels) ---
      const ctxG = document.getElementById('graph').getContext('2d');
      const gData = Array(200).fill(0);

      function drawGraph() {
        const w = ctxG.canvas.width = ctxG.canvas.clientWidth;
        const h = ctxG.canvas.height = ctxG.canvas.clientHeight;
        gData.push(state.I); gData.shift();

        ctxG.clearRect(0, 0, w, h);

        // Auto-scaling: Îç∞Ïù¥ÌÑ∞ ÏµúÎåÄÍ∞í Ï∞æÍ∏∞
        let maxVal = 0;
        for (let v of gData) if (v > maxVal) maxVal = v;
        if (maxVal < 1) maxVal = 1; // ÏµúÏÜå Ïä§ÏºÄÏùº 1A
        maxVal = Math.ceil(maxVal * 1.2); // ÏïΩÍ∞ÑÏùò Ïó¨Ïú†

        // Í∑∏Î¶¨Îìú Î∞è Î∞∞Í≤Ω
        ctxG.strokeStyle = 'rgba(2, 132, 199, 0.15)';
        ctxG.beginPath(); ctxG.moveTo(30, h - 30); ctxG.lineTo(w, h - 30); ctxG.stroke(); // XÏ∂ï
        ctxG.beginPath(); ctxG.moveTo(30, 0); ctxG.lineTo(30, h - 30); ctxG.stroke(); // YÏ∂ï

        // Ï∂ï Î†àÏù¥Î∏î (Units)
        ctxG.fillStyle = '#64748b'; ctxG.font = '11px sans-serif';
        ctxG.textAlign = 'right';
        ctxG.fillText("Time ‚Üí", w - 10, h - 10);

        ctxG.save();
        ctxG.translate(15, 60);
        ctxG.rotate(-Math.PI / 2);
        ctxG.fillText("Current (A) ‚Üí", 0, 0);
        ctxG.restore();

        // Í∑∏ÎûòÌîÑ Í∑∏Î¶¨Í∏∞
        ctxG.strokeStyle = '#0284c7'; ctxG.lineWidth = 2; ctxG.beginPath();
        const plotW = w - 30;
        const plotH = h - 40; // ÏúÑ 10, ÏïÑÎûò 30 Ïó¨Î∞±

        for (let i = 0; i < gData.length; i++) {
          const x = 30 + (i / (gData.length - 1)) * plotW;
          // 0ÏùºÎïå h-30 (Î∞îÎã•), maxValÏùºÎïå 10 (Ï≤úÏû•)
          const y = (h - 30) - (gData[i] / maxVal) * plotH;
          if (i === 0) ctxG.moveTo(x, y); else ctxG.lineTo(x, y);
        }
        ctxG.stroke();

        // Max ÏàòÏπò ÌëúÏãú
        ctxG.textAlign = 'left';
        ctxG.fillText(`${maxVal}A`, 35, 15);
        ctxG.fillText(`0`, 15, h - 30);
      }

      // --- Î£®ÌîÑ ---
      let lastParams = "";
      function animate() {
        requestAnimationFrame(animate);

        state.A = parseFloat(document.getElementById('sA').value);
        state.L = parseFloat(document.getElementById('sL').value);
        state.Ns = parseInt(document.getElementById('sNs').value);
        state.Np = parseInt(document.getElementById('sNp').value);

        document.getElementById('vA').textContent = state.A.toFixed(1) + " „éü";
        document.getElementById('vL').textContent = state.L.toFixed(1) + " „éù";
        document.getElementById('vNs').textContent = state.Ns;
        document.getElementById('vNp').textContent = state.Np;

        const R1 = SIM_RHO * (state.L / state.A);
        const Req = (R1 * state.Ns) / state.Np;
        state.I = (Req > 0) ? V_SOURCE / Req : 0;

        updateMeter(vTex, V_SOURCE, "V", "#dc2626");
        updateMeter(aTex, state.I, "A", "#0284c7");

        const params = `${state.A}-${state.L}-${state.Ns}-${state.Np}`;
        if (params !== lastParams) { rebuildCircuit(); lastParams = params; }

        updateElectrons(0.016);
        drawGraph();
        controls.update();
        renderer.render(scene, camera);
      }

      document.getElementById('btnReset').onclick = () => {
        camera.position.set(0, 15, 60); controls.target.set(0, 0, 0);
      };
      window.onresize = () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      };

      animate();
    })();
  </script>
</body>

</html>