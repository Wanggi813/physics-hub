<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>ÏßÅÎ•ò Ï†ÑÎèôÍ∏∞ (ÏµúÏ¢Ö: Îë•Í∑º ÏΩîÏùº Î≥¥Ï†ï)</title>
  <style>
    :root{ 
      --ink:#334155; 
      --primary:#0284c7; 
      --danger:#d9534f;  
      --success:#16a34a; 
      --warn:#d97706;    
    }
    html, body {
      height: 100%; margin: 0; overflow: hidden;
      touch-action: none; 
      -webkit-user-select: none;
      user-select: none;
    }
    
    body {
      color: var(--ink);
      font-family: system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at 50% 30%, #f1f5f9 0%, #cbd5e1 100%);
    }

    header {
      position: absolute; top:0; left:0; width:100%;
      padding: 10px 14px;
      display: flex; justify-content: space-between; align-items: center;
      z-index: 5;
      pointer-events: none; 
    }
    .brand { pointer-events: auto; font-weight: 700; font-size: 18px; color: #1e293b; text-shadow: 0 1px 0 rgba(255,255,255,0.5); }
    .small { font-size: 12px; color: #64748b; }
    
    #scene { position: fixed; inset: 0; z-index: 0; }
    #scene canvas { display: block; width: 100vw; height: 100vh; outline: none; }

    /* HUD Ìå®ÎÑê */
    .hud {
      position: fixed; left: 14px; top: 50px; width: 320px;
      background: rgba(255, 255, 255, 0.90);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(200,200,200,0.5);
      border-radius: 12px; padding: 16px; z-index: 10;
      box-shadow: 0 10px 25px -5px rgba(0,0,0,0.05);
      max-height: 80vh; overflow-y: auto;
      -webkit-overflow-scrolling: touch; 
    }
    .row { display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center; margin: 12px 0; }
    .row label { font-size: 14px; font-weight: 600; color: #475569; }
    
    input[type=range] { width: 100%; accent-color: var(--primary); cursor: pointer; height: 24px; }
    select { padding: 8px; border-radius: 4px; border: 1px solid #cbd5e1; color: #475569; font-size: 14px; }
    
    .status-box {
      margin-top: 12px; padding-top: 12px; 
      border-top: 1px solid #e2e8f0;
      font-size: 13px; color: #64748b; line-height: 1.6;
    }
    .val-highlight { color: var(--primary); font-weight: bold; }

    /* Î≤ÑÌäº Í∑∏Î£π */
    .control-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 12px; }
    .btn {
      padding: 14px 8px; border-radius: 8px; border: none; cursor: pointer;
      font-size: 13px; font-weight: 600; color: white;
      background: #64748b; transition: all 0.2s;
      display: flex; justify-content: center; align-items: center; text-align: center;
      line-height: 1.3;
      -webkit-tap-highlight-color: transparent; 
    }
    .btn:active { transform: scale(0.98); }
    .btn.active { background: var(--primary); box-shadow: 0 0 0 2px #bae6fd; }
    
    .btn-magnet { background: #6366f1; } 
    .btn-current { background: var(--warn); } 
    .btn-pause { background: var(--danger); } 
    .btn-pause.paused { background: var(--success); }
    
    .btn-slow { background: #10b981; grid-column: span 2; font-size: 14px; padding: 14px; }
    .btn-slow.active-mode { background: #059669; box-shadow: inset 0 2px 4px rgba(0,0,0,0.2); border: 2px solid #a7f3d0; }

    /* Í∑∏ÎûòÌîÑ */
    .graphbox {
      position: fixed; right: 14px; top: 50px; width: 280px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 12px; padding: 10px; z-index: 11;
      box-shadow: 0 10px 25px -5px rgba(0,0,0,0.05);
      pointer-events: none; 
    }
    
    @media (max-width: 600px) {
      .hud { width: calc(100% - 40px); left: 20px; top: auto; bottom: 20px; max-height: 40vh; }
      .graphbox { top: 60px; right: 10px; width: 120px; opacity: 0.8; }
      .graphbox canvas { width: 100%; height: 60px; }
      header { justify-content: center; }
      .small { display: none; }
    }
  </style>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

</head>
<body>

  <header>
    <div class="brand">üî∑ ÏßÅÎ•ò Ï†ÑÎèôÍ∏∞ Ïã§ÌóòÏã§</div>
    <div class="small">Rounded Wire Joints (Tablet Touch Ready)</div>
  </header>

  <div id="scene"></div>

  <div class="hud">
    <div class="row">
      <label for="I_curr">Ï†ÑÎ•ò ÌÅ¨Í∏∞ (Current)</label>
      <span style="font-family:monospace; font-weight:bold;"><span id="Ival">0.16</span> A</span>
    </div>
    <input id="I_curr" type="range" min="0" max="0.32" step="0.01" value="0.16" />

    <div class="row">
      <label for="B_field">ÏûêÍ∏∞Ïû• ÏÑ∏Í∏∞ (B)</label>
      <span style="font-family:monospace; font-weight:bold;"><span id="Bval">0.08</span> T</span>
    </div>
    <input id="B_field" type="range" min="0" max="0.16" step="0.01" value="0.08" />

    <div class="row">
      <label>ÏΩîÏùº Í∞úÏàò</label>
      <select id="coilCount">
        <option value="1">1Í∞ú (Í∏∞Î≥∏)</option>
        <option value="2">2Í∞ú (Ïã≠Ïûê)</option>
        <option value="4">4Í∞ú (ÏõêÌòï)</option>
      </select>
    </div>

    <div class="control-grid">
      <button id="btnSlowToggle" class="btn btn-slow">üê¢ 0.1Î∞∞ÏÜç ÎäêÎ¶¨Í≤å Î≥¥Í∏∞ (OFF)</button>
      <button id="btnMagnetSwap" class="btn btn-magnet">üß≤ ÏûêÏÑù ÏúÑÏπò Î≥ÄÍ≤Ω<br>(N ‚Üî S)</button>
      <button id="btnCurrentRev" class="btn btn-current">‚ö° Ï†ÑÎ•ò Î∞©Ìñ• Î≥ÄÍ≤Ω<br>(Ï†ïÎ∞©Ìñ•)</button>
      <button id="toggleForce" class="btn active">Ìûò ÌôîÏÇ¥Ìëú Î≥¥Í∏∞</button>
      <button id="btnPause" class="btn btn-pause">‚è∏ ÏùºÏãúÏ†ïÏßÄ</button>
      <button id="resetCam" class="btn" style="grid-column: span 2;">üì∑ Ïπ¥Î©îÎùº Î¶¨ÏÖã</button>
    </div>

    <div class="status-box">
      <div>Ïã§Ï†ú ÏûÖÎ†• Ï†ÑÎ•ò = <span class="val-highlight" id="dispI">0.16</span> A</div>
      <div>ÏûêÍ∏∞Î†• F = <span class="val-highlight" id="Fval">0.00</span> N</div>
      <div>ÌöåÏ†Ñ ÏÜçÎèÑ = <span class="val-highlight" id="RPMval">0</span> RPM</div>
    </div>
  </div>

  <div class="graphbox">
    <canvas id="graph" width="300" height="120"></canvas>
    <div style="text-align:right; font-size:11px; color:#64748b; margin-top:4px;">Time ‚Üí</div>
  </div>

  <script>
  (function(){
    // 1. Î≥ÄÏàò ÏÑ§Ï†ï
    const elScene = document.getElementById('scene');
    const inputI = document.getElementById('I_curr');
    const inputB = document.getElementById('B_field');
    const selectCoils = document.getElementById('coilCount');
    
    const btnSlowToggle = document.getElementById('btnSlowToggle');
    const btnMagnetSwap = document.getElementById('btnMagnetSwap');
    const btnCurrentRev = document.getElementById('btnCurrentRev');
    const btnForce = document.getElementById('toggleForce');
    const btnPause = document.getElementById('btnPause');
    const btnResetCam = document.getElementById('resetCam');

    const dispIval = document.getElementById('Ival');
    const dispBval = document.getElementById('Bval');
    const dispI = document.getElementById('dispI');
    const dispFval = document.getElementById('Fval');
    const dispRPM = document.getElementById('RPMval');

    let angularVelocity = 0;
    let currentAngle = 0;
    
    let rawInputCurrent = 0.16; 
    let rawInputB = 0.08;
    
    let magnetDirection = 1; 
    let currentDirection = 1; 
    let isPaused = false;
    let showForceArrows = true;
    
    const NORMAL_SPEED_FACTOR = 1.0; 
    const SLOW_SPEED_FACTOR = 0.1;
    let currentSpeedFactor = NORMAL_SPEED_FACTOR;

    const gCanvas = document.getElementById('graph');
    const ctxG = gCanvas.getContext('2d');
    const gBuf = new Float32Array(300);
    let gIdx = 0;
    let maxGraphY = 10;

    // 2. 3D Ïî¨ ÏÑ§Ï†ï
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    elScene.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 1000);
    camera.position.set(20, 15, 30);
    camera.lookAt(0, 0, 0);

    // OrbircControls (ÌÑ∞Ïπò/ÎßàÏö∞Ïä§ ÏßÄÏõê Í≥µÏãù Ïª®Ìä∏Î°§Îü¨)
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; 
    controls.dampingFactor = 0.05;
    controls.enableZoom = true;
    controls.enablePan = false; 
    controls.minDistance = 10;
    controls.maxDistance = 100;

    const ambLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    // --- [ÏÉâÏÉÅ ÌÜ§ Îã§Ïö¥] ---
    // StandardMaterialÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Ï∞®Î∂ÑÌïòÍ≥† Í≥†Í∏âÏä§Îü¨Ïö¥ ÏßàÍ∞ê ÌëúÌòÑ
    const matCopper = new THREE.MeshStandardMaterial({ color: 0xa65d29, roughness: 0.3, metalness: 0.6 });
    const matSteel = new THREE.MeshStandardMaterial({ color: 0xbdc3c7, roughness: 0.4, metalness: 0.5 });
    const matBrass = new THREE.MeshStandardMaterial({ color: 0xd4af37, roughness: 0.3, metalness: 0.7 });
    
    const colRed = 0xc0392b; 
    const colBlue = 0x2980b9; 

    const matRed = new THREE.MeshStandardMaterial({ color: colRed, roughness: 0.4, metalness: 0.1 });
    const matBlue = new THREE.MeshStandardMaterial({ color: colBlue, roughness: 0.4, metalness: 0.1 });
    const matDark = new THREE.MeshStandardMaterial({ color: 0x2c3e50, roughness: 0.9 });
    const matArrow = new THREE.MeshPhongMaterial({ color: 0x2ecc71, emissive: 0x004400, shininess: 50 });

    // 3. Í∞ùÏ≤¥ ÏÉùÏÑ±
    let magnetL, magnetR;
    function createMagnetMesh(isN) {
      const g = new THREE.BoxGeometry(4, 10, 10);
      const m = new THREE.Mesh(g, isN ? matRed : matBlue);
      const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
      const ctx = cvs.getContext('2d');
      ctx.fillStyle = isN ? '#c0392b' : '#2980b9'; 
      ctx.fillRect(0,0,64,64);
      ctx.fillStyle='white'; ctx.font='bold 40px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(isN?'N':'S', 32, 32);
      const tex = new THREE.CanvasTexture(cvs);
      const label = new THREE.Mesh(new THREE.PlaneGeometry(3,3), new THREE.MeshBasicMaterial({map:tex}));
      m.add(label);
      return m;
    }
    function initMagnets() {
      magnetL = createMagnetMesh(true); magnetL.position.set(-10, 0, 0);
      magnetL.children[0].position.x = 2.1; magnetL.children[0].rotation.y = Math.PI/2;
      scene.add(magnetL);
      magnetR = createMagnetMesh(false); magnetR.position.set(10, 0, 0);
      magnetR.children[0].position.x = -2.1; magnetR.children[0].rotation.y = -Math.PI/2;
      scene.add(magnetR);
    }
    initMagnets();

    function updateMagnetVisuals() {
      const isNormal = magnetDirection === 1; 
      magnetL.material = isNormal ? matRed : matBlue;
      updateMagnetLabel(magnetL, isNormal ? 'N' : 'S', isNormal ? '#c0392b' : '#2980b9');
      magnetR.material = isNormal ? matBlue : matRed;
      updateMagnetLabel(magnetR, isNormal ? 'S' : 'N', isNormal ? '#2980b9' : '#c0392b');
    }
    function updateMagnetLabel(mesh, text, bgColor) {
      const labelMesh = mesh.children[0];
      const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
      const ctx = cvs.getContext('2d');
      ctx.fillStyle = bgColor; ctx.fillRect(0,0,64,64);
      ctx.fillStyle='white'; ctx.font='bold 40px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(text, 32, 32);
      labelMesh.material.map = new THREE.CanvasTexture(cvs);
    }

    // --- [ÏúÑÏπò ÌÜµÌï© ÏÑ§Ï†ï] ---
    const MAIN_Z = 7.0; 
    const BRUSH_Z = 7.4; 
    const COMM_CENTER_Z = MAIN_Z;
    const COIL_END_Z = MAIN_Z - 1.0; // ÏΩîÏùºÏù¥ Ï†ïÎ•òÏûêÏôÄ Í≤πÏπòÎèÑÎ°ù ÏÑ§Ï†ï

    function createCurvedBrushGeo() {
      const shape = new THREE.Shape();
      const rIn = 1.3; 
      const rOut = 1.8; 
      const ang = Math.PI / 3; 
      shape.absarc(0, 0, rIn, -ang/2, ang/2, false);
      shape.absarc(0, 0, rOut, ang/2, -ang/2, true);
      const extrudeSettings = { depth: 2.0, bevelEnabled: false, curveSegments: 16 };
      const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      geo.translate(0, 0, -1.0); 
      return geo;
    }

    const brushGeo = createCurvedBrushGeo();
    const brushGroup = new THREE.Group(); 
    scene.add(brushGroup);

    const brushR = new THREE.Mesh(brushGeo, matDark);
    brushR.position.set(0, 0, BRUSH_Z); 
    const brushL = new THREE.Mesh(brushGeo, matDark);
    brushL.position.set(0, 0, BRUSH_Z);
    brushL.rotation.z = Math.PI;
    brushGroup.add(brushL, brushR);

    const wireGeo = new THREE.CylinderGeometry(0.2, 0.2, 8); 
    const wireL = new THREE.Mesh(wireGeo, matRed);
    wireL.rotation.z = Math.PI/2; wireL.position.set(-5.8, 0, BRUSH_Z); 
    const wireR = new THREE.Mesh(wireGeo, matBlue);
    wireR.rotation.z = Math.PI/2; wireR.position.set(5.8, 0, BRUSH_Z);
    brushGroup.add(wireL, wireR);

    // --- 4. Î°úÌÑ∞ ÏÉùÏÑ± (ÏΩîÏùº Îë•Í∑º Í¥ÄÏ†à Ï†ÅÏö©) ---
    let rotorGroup = new THREE.Group();
    let arrows = []; 

    function createArrow() {
      const g = new THREE.Group();
      const cyl = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 1, 12), matArrow);
      cyl.position.y = 0.5;
      const cone = new THREE.Mesh(new THREE.ConeGeometry(0.5, 0.8, 12), matArrow);
      cone.position.y = 1.4;
      g.add(cyl, cone);
      return g;
    }

    function createRotor(n) {
      if(rotorGroup) scene.remove(rotorGroup);
      rotorGroup = new THREE.Group();
      scene.add(rotorGroup);
      arrows = [];

      const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 26, 16), matSteel);
      shaft.rotation.x = Math.PI/2;
      rotorGroup.add(shaft);

      const COMM_LEN = 4.0; 
      const segs = n * 2;
      const segmentArc = (Math.PI * 2) / segs; 
      const gapArc = 0.2; 
      const copperArc = segmentArc - gapArc; 
      const phaseFix = Math.PI / 2; 

      for(let i=0; i<segs; i++) {
        const centerAngle = i * segmentArc + phaseFix;
        const startAngle = centerAngle - (copperArc / 2);
        const geo = new THREE.CylinderGeometry(1.2, 1.2, COMM_LEN, 32, 1, false, startAngle, copperArc);
        const mesh = new THREE.Mesh(geo, matBrass);
        mesh.rotation.x = Math.PI/2; mesh.position.z = COMM_CENTER_Z; 
        rotorGroup.add(mesh);
      }

      const angStep = Math.PI / n;

      for(let i=0; i<n; i++) {
        const cGroup = new THREE.Group();
        const w=5, l=12, t=0.25; // t: Ï†ÑÏÑ† ÍµµÍ∏∞
        
        // 1) ÏΩîÏùº Ï£ºÏöî ÎºàÎåÄ (Ïã§Î¶∞Îçî)
        const sideL = new THREE.Mesh(new THREE.CylinderGeometry(t,t,l,8), matCopper); 
        sideL.rotation.x=Math.PI/2; sideL.position.x = -w/2;
        const sideR = new THREE.Mesh(new THREE.CylinderGeometry(t,t,l,8), matCopper); 
        sideR.rotation.x=Math.PI/2; sideR.position.x = w/2;
        const sideB = new THREE.Mesh(new THREE.CylinderGeometry(t,t,w,8), matCopper); 
        sideB.rotation.z=Math.PI/2; sideB.position.z = -l/2;

        const commR = 1.2;
        const armX = w/2; 
        const connLen = armX - commR; 
        const connCenter = commR + connLen/2; 

        const connL = new THREE.Mesh(new THREE.CylinderGeometry(t, t, connLen, 8), matCopper);
        connL.rotation.z = Math.PI/2; connL.position.x = -connCenter; connL.position.z = COIL_END_Z; 
        const connR = new THREE.Mesh(new THREE.CylinderGeometry(t, t, connLen, 8), matCopper);
        connR.rotation.z = Math.PI/2; connR.position.x = connCenter; connR.position.z = COIL_END_Z;

        cGroup.add(sideL, sideR, sideB, connL, connR);

        // ‚òÖ [ÏµúÏ¢Ö ÏàòÏ†ï ÌïµÏã¨] 2) Îë•Í∑º Í¥ÄÏ†à Î∂ÄÎ∂Ñ (Sphere) Ï∂îÍ∞Ä ‚òÖ
        // Ï†ÑÏÑ† Ïã§Î¶∞ÎçîÎì§Ïù¥ ÎßåÎÇòÎäî Î™®ÏÑúÎ¶¨Ïóê Íµ¨Î•º Î∞∞ÏπòÌïòÏó¨ ÎÅäÏñ¥ÏßÑ Î∂ÄÎ∂Ñ Ï∞®Îã® Î∞è Î∂ÄÎìúÎüΩÍ≤å Ïó∞Í≤∞
        const jointGeo = new THREE.SphereGeometry(t, 12, 8); // Î∞òÏßÄÎ¶Ñ t (ÍµµÍ∏∞ ÎèôÏùº)

        // Í¥ÄÏ†à 1: ÏôºÏ™Ω Ïïû Î™®ÏÑúÎ¶¨ (sideL-connL)
        const jointLFront = new THREE.Mesh(jointGeo, matCopper);
        jointLFront.position.set(-w/2, 0, COIL_END_Z);
        cGroup.add(jointLFront);

        // Í¥ÄÏ†à 2: ÏôºÏ™Ω Îí§ Î™®ÏÑúÎ¶¨ (sideL-sideB)
        const jointLBack = new THREE.Mesh(jointGeo, matCopper);
        jointLBack.position.set(-w/2, 0, -l/2);
        cGroup.add(jointLBack);

        // Í¥ÄÏ†à 3: Ïò§Î•∏Ï™Ω Îí§ Î™®ÏÑúÎ¶¨ (sideR-sideB)
        const jointRBack = new THREE.Mesh(jointGeo, matCopper);
        jointRBack.position.set(w/2, 0, -l/2);
        cGroup.add(jointRBack);

        // Í¥ÄÏ†à 4: Ïò§Î•∏Ï™Ω Ïïû Î™®ÏÑúÎ¶¨ (sideR-connR)
        const jointRFront = new THREE.Mesh(jointGeo, matCopper);
        jointRFront.position.set(w/2, 0, COIL_END_Z);
        cGroup.add(jointRFront);

        // Ìûò ÌôîÏÇ¥Ìëú
        const arrL = createArrow(); arrL.position.x = -w/2;
        const arrR = createArrow(); arrR.position.x = w/2;
        cGroup.add(arrL, arrR);

        cGroup.rotation.z = i * angStep;
        rotorGroup.add(cGroup);
        arrows.push({ group: cGroup, L: arrL, R: arrR, baseAng: i*angStep });
      }
    }

    // --- 5. Î¨ºÎ¶¨ ÏóÖÎç∞Ïù¥Ìä∏ ---
    function update() {
      rawInputCurrent = parseFloat(inputI.value);
      rawInputB = parseFloat(inputB.value);
      
      if(isPaused) return;

      const netDirection = currentDirection * magnetDirection; 
      let torqueSum = 0;
      
      arrows.forEach(obj => {
        const totalRot = rotorGroup.rotation.z + obj.baseAng;
        const normRot = totalRot % (Math.PI*2);
        const factor = Math.abs(Math.cos(normRot)); 
        const segmentTorque = factor * rawInputCurrent * rawInputB * netDirection;
        torqueSum += segmentTorque;

        if(showForceArrows && rawInputCurrent > 0.01) {
          const s = Math.abs(segmentTorque) * 20.0;
          if(s < 0.1) {
            obj.L.visible = false; obj.R.visible = false;
          } else {
            obj.L.visible = true; obj.R.visible = true;
            obj.L.scale.set(s, s, s); obj.R.scale.set(s, s, s);
            const radius = 2.5;
            const worldX_R = radius * Math.cos(totalRot);
            const worldX_L = radius * Math.cos(totalRot + Math.PI);
            const forceDirOnRightSide = (netDirection >= 0) ? 0 : Math.PI;
            const forceDirOnLeftSide = (forceDirOnRightSide === 0) ? Math.PI : 0;
            let targetR = (worldX_R >= 0) ? forceDirOnRightSide : forceDirOnLeftSide;
            let targetL = (worldX_L >= 0) ? forceDirOnRightSide : forceDirOnLeftSide;
            obj.R.rotation.z = -totalRot + targetR; obj.R.rotation.x = 0; 
            obj.L.rotation.z = -totalRot + targetL; obj.L.rotation.x = 0;
          }
        } else {
          obj.L.visible = false; obj.R.visible = false;
        }
      });

      if(rawInputCurrent < 0.01) torqueSum = 0;
      
      const frictionCoef = 0.045; friction = frictionCoef * angularVelocity; inertia = 0.5;
      alpha = (torqueSum - friction) / inertia; angularVelocity += alpha * 0.1;
      const dt = 0.05 * currentSpeedFactor; currentAngle += angularVelocity * dt;
      rotorGroup.rotation.z = currentAngle;

      const rpm = Math.round((angularVelocity/(2*Math.PI))*60);
      dispIval.textContent = rawInputCurrent.toFixed(2); dispBval.textContent = rawInputB.toFixed(2);
      dispI.textContent = (rawInputCurrent * currentDirection).toFixed(2);
      dispFval.textContent = torqueSum.toFixed(2); dispRPM.textContent = rpm;

      gBuf[gIdx] = rpm; gIdx = (gIdx + 1) % 300;
    }

    function drawGraph() {
      ctxG.clearRect(0,0,300,120); ctxG.strokeStyle = 'rgba(200,200,200,0.5)'; ctxG.lineWidth=1;
      ctxG.beginPath(); ctxG.moveTo(0, 120); ctxG.lineTo(300, 120); ctxG.stroke();
      ctxG.strokeStyle = '#0284c7'; ctxG.lineWidth = 2; ctxG.beginPath();
      let curMax = 5; for(let i=0; i<300; i++) { const v = Math.abs(gBuf[i]); if(v > curMax) curMax = v; }
      maxGraphY = curMax + 1;
      for(let i=0; i<300; i++) {
        const idx = (gIdx + i) % 300; const val = gBuf[idx];
        const y = 120 - (Math.abs(val) / maxGraphY) * 110; 
        if(i===0) ctxG.moveTo(i, y); else ctxG.lineTo(i, y);
      }
      ctxG.stroke(); ctxG.fillStyle = "#0284c7"; ctxG.font = "10px sans-serif"; ctxG.fillText("Max: " + maxGraphY.toFixed(0) + " RPM", 5, 15);
    }

    function animate() {
      requestAnimationFrame(animate);
      update(); drawGraph();
      controls.update(); // OrbitControls Í¥ÄÏÑ± ÏóÖÎç∞Ïù¥Ìä∏
      renderer.render(scene, camera);
    }
    
    selectCoils.onchange = () => createRotor(parseInt(selectCoils.value));
    btnSlowToggle.onclick = () => {
      currentSpeedFactor = (currentSpeedFactor === NORMAL_SPEED_FACTOR) ? SLOW_SPEED_FACTOR : NORMAL_SPEED_FACTOR;
      btnSlowToggle.textContent = (currentSpeedFactor === SLOW_SPEED_FACTOR) ? "üê¢ 0.1Î∞∞ÏÜç Ï†ÅÏö© Ï§ë (ÌÅ¥Î¶≠ÌïòÏó¨ Ìï¥Ï†ú)" : "üê¢ 0.1Î∞∞ÏÜç ÎäêÎ¶¨Í≤å Î≥¥Í∏∞ (OFF)";
      btnSlowToggle.classList.toggle("active-mode");
    };
    btnForce.onclick = () => { showForceArrows = !showForceArrows; btnForce.classList.toggle('active'); };
    btnResetCam.onclick = () => { camera.position.set(20, 15, 30); controls.target.set(0, 0, 0); controls.update(); }
    btnMagnetSwap.onclick = () => { magnetDirection *= -1; updateMagnetVisuals(); };
    btnCurrentRev.onclick = () => {
      currentDirection *= -1;
      const isNormal = (currentDirection === 1);
      btnCurrentRev.innerHTML = isNormal ? "‚ö° Ï†ÑÎ•ò Î∞©Ìñ• Î≥ÄÍ≤Ω<br>(Ï†ïÎ∞©Ìñ•)" : "‚ö° Ï†ÑÎ•ò Î∞©Ìñ• Î≥ÄÍ≤Ω<br>(Ïó≠Î∞©Ìñ•)";
      btnCurrentRev.style.background = isNormal ? "var(--warn)" : "#d35400";
      wireL.material = isNormal ? matRed : matBlue;
      wireR.material = isNormal ? matBlue : matRed;
    };
    btnPause.onclick = () => {
      isPaused = !isPaused;
      btnPause.innerHTML = isPaused ? "‚ñ∂ Ïû¨ÏÉù" : "‚è∏ ÏùºÏãúÏ†ïÏßÄ"; btnPause.classList.toggle("paused");
    };
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    createRotor(1);
    animate();

  })();
  </script>
</body>
</html>