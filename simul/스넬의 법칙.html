<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>ìŠ¤ë„¬ì˜ ë²•ì¹™</title>
    <script src="./libs/p5.min.js"></script>
    <style>
      html, body { height:100%; margin:0; }
      body{
        background:#eef6ff;
        font-family:"Noto Sans KR",system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
        color:#0f172a;
        overscroll-behavior: none;
      }
      header{
        padding:14px 12px;
        background:#dceeff;
        border-bottom:1px solid #c7defd
      }
      header h2{margin:0 0 6px 0;font-size:22px}
      header small{display:block;margin-top:6px;font-size:14px;color:#334155}
      #footer{
        text-align:center;
        padding:12px;
        font-size:1.1rem;
        background:#dceeff;
        color:#333
      }
      .legend{
        position:absolute;
        right:12px;
        top:78px;
        background:rgba(255,255,255,.9);
        border:1px solid #c7defd;
        border-radius:10px;
        padding:10px 12px;
        font-size:14px;
        line-height:1.5
      }
      .sw{
        display:inline-block;
        width:12px;
        height:12px;
        border-radius:3px;
        margin-right:8px;
        vertical-align:middle;
        border:1px solid #94a3b8
      }

canvas{
  touch-action: none;
  -webkit-user-select:none;
  user-select:none;
  display:block;
  position:relative;
  z-index:0;               /* âœ… ìº”ë²„ìŠ¤ëŠ” ì•„ë˜ ë ˆì´ì–´ */
}

/* #sketchì—ëŠ” touch-actionì„ ê±¸ì§€ ì•ŠëŠ”ë‹¤ (íŒ¨ë„ í„°ì¹˜ê°€ ì”¹íˆëŠ” ì›ì¸ ì¤‘ í•˜ë‚˜) */
#sketch{
  position:relative;
  z-index:0;
}
#gamePanel{
  z-index: 9999;                 /* ìº”ë²„ìŠ¤ë³´ë‹¤ ë¬´ì¡°ê±´ ìœ„ */
  pointer-events: auto;
  touch-action: manipulation;   /* íƒ­ â†’ í´ë¦­ ë³€í™˜ */
}

#gamePanel *{
  pointer-events: auto;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
}
      /* ===== ë„ì „ ëª¨ë“œ íŒ¨ë„ ===== */
 .game-panel{
  position:fixed;     /* âœ… absolute â†’ fixed ë¡œ êµì²´ */
  left:12px;
  top:auto;
  bottom:72px;
  z-index:9999;       /* âœ… ì¶”ê°€: ìº”ë²„ìŠ¤ë³´ë‹¤ ë¬´ì¡°ê±´ ìœ„ */
  max-width:360px;
  background:rgba(255,255,255,0.96);
  border:1px solid #c7defd;
  border-radius:12px;
  padding:10px 12px;
  box-shadow:0 8px 20px rgba(15,23,42,0.18);
  font-size:13px;
  line-height:1.4;
}
      .game-header{
        display:flex;
        justify-content:space-between;
        align-items:flex-start;
        gap:8px;
        margin-bottom:6px;
      }
      .game-title{
        font-weight:700;
        font-size:14px;
        color:#0f172a;
      }
      .game-round{
        font-size:12px;
        color:#475569;
        margin-top:2px;
      }

      /* ===== ìµœê³  ì ìˆ˜ ë±ƒì§€ ===== */
      .game-best-badge{
        display:inline-flex;
        align-items:center;
        gap:4px;
        padding:4px 10px;
        border-radius:999px;
        background:linear-gradient(135deg,#fff7e6,#fff);
        box-shadow:
          0 0 0 1px rgba(251,191,36,0.45),
          0 0 14px rgba(251,191,36,0.75);
        font-size:12px;
        white-space:nowrap;
      }
      .best-label{
        font-size:11px;
        color:#6b7280;
      }
      .best-icon{
        font-size:15px;
        line-height:1;
        text-shadow:0 0 6px rgba(251,191,36,0.9);
      }
      .best-value{
        font-weight:800;
        font-size:14px;
        color:#f97316;
        min-width:26px;
        text-align:right;
      }

      .game-question{
        margin:4px 0 8px;
        color:#0f172a;
      }
      .game-question b{color:#1d4ed8}
      .game-answers{
        display:flex;
        flex-wrap:wrap;
        gap:6px;
        margin-bottom:6px;
      }
      .game-btn{
        flex:1 1 calc(50% - 6px);
        min-width:120px;
        border-radius:999px;
        border:1px solid #bfdbfe;
        background:#e0edff;
        padding:6px 8px;
        font-size:12px;
        cursor:pointer;
        display:inline-flex;
        align-items:center;
        justify-content:center;
        gap:4px;
      }
      .game-btn:hover:not(:disabled){
        background:#d0e4ff;
      }
      .game-btn:disabled{
        opacity:0.45;
        cursor:not-allowed;
      }
      .game-btn.primary{
        flex:0 0 auto;
        background:#2563eb;
        border-color:#2563eb;
        color:#fff;
        font-weight:600;
        padding:7px 12px;
      }

      .game-footer{
        display:flex;
        justify-content:space-between;
        align-items:center;
        gap:8px;
        margin-top:4px;
      }
      .game-score{
        font-size:12px;
        color:#0b1120;
        white-space:nowrap;
      }
      .game-feedback{
        margin-top:4px;
        font-size:12px;
      }
      .game-feedback.ok{color:#15803d}
      .game-feedback.bad{color:#b91c1c}

      @keyframes score-bump{
        0%{transform:scale(1);}
        30%{transform:scale(1.08);}
        100%{transform:scale(1);}
      }
      .game-score.bump{
        animation:score-bump .35s ease-out;
      }

      @keyframes best-pulse{
        0%{transform:scale(1); box-shadow:
             0 0 0 1px rgba(251,191,36,0.45),
             0 0 10px rgba(251,191,36,0.7);}
        40%{transform:scale(1.06); box-shadow:
             0 0 0 2px rgba(251,191,36,0.6),
             0 0 18px rgba(251,191,36,0.9);}
        100%{transform:scale(1); box-shadow:
             0 0 0 1px rgba(251,191,36,0.45),
             0 0 10px rgba(251,191,36,0.7);}
      }
      .game-best-badge.bump{
        animation:best-pulse .5s ease-out;
      }

      @media (max-width: 768px){
        .game-panel{
          left:10px;
          right:10px;
          top:auto;
          bottom:72px;
          max-width:none;
        }
        .legend{
          top:auto;
          bottom:72px;
          right:10px;
        }
        .game-footer{
          flex-direction:column;
          align-items:flex-start;
        }
        .game-score{white-space:normal}
      }
    </style>
  </head>
  <body>
    <header>
      <h2>êµ´ì ˆÂ·ì „ë°˜ì‚¬ ì‹œë®¬ë ˆì´ì…˜</h2>
      <div id="ui"></div>
      <small>ë¹¨ê°„ ë ˆì´ì € í¬ì¸í„°(â—)ë¥¼ ë“œë˜ê·¸/í„°ì¹˜í•´ ì…ì‚¬ê°ì„ ì¡°ì ˆí•˜ì„¸ìš”. (ë„ì „ ëª¨ë“œì—ì„œëŠ” ìë™ìœ¼ë¡œ ê³ ì •ë©ë‹ˆë‹¤)</small>
    </header>

    <main id="sketch"></main>
    <div class="legend" id="legend"></div>

    <!-- ë„ì „ ëª¨ë“œ íŒ¨ë„ -->
    <div class="game-panel" id="gamePanel">
      <div class="game-header">
        <div>
          <div class="game-title">ìŠ¤ë„¬ì˜ ë²•ì¹™ ë„ì „ ëª¨ë“œ</div>
          <div class="game-round" id="gp-round">ë¼ìš´ë“œ: 0 / 10</div>
        </div>
        <!-- ëˆˆì— ë„ëŠ” ìµœê³ ì ìˆ˜ ë±ƒì§€ -->
        <div class="game-best-badge" id="gp-best">
          <span class="best-label">ìµœê³ ì ìˆ˜</span>
          <span class="best-icon">ğŸ†</span>
          <span class="best-value" id="gp-best-value">0</span>
        </div>
      </div>
      <div class="game-question" id="gp-question">
        <b>ë„ì „ ì‹œì‘</b> ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ì„ì˜ì˜ ë§¤ì§ˆÂ·ì…ì‚¬ê°ì´ ì œì‹œë©ë‹ˆë‹¤.<br>
        êµ´ì ˆê´‘Â·ë°˜ì‚¬ê´‘ì´ ë³´ì´ì§€ ì•ŠëŠ” ìƒíƒœì—ì„œ <b>ì „ë°˜ì‚¬</b> ì—¬ë¶€ì™€
        <b>êµ´ì ˆê°ì˜ ë²”ìœ„</b>ë¥¼ ë§í˜€ ë³´ì„¸ìš”.
      </div>
      <div class="game-answers">
        <!-- 1~5ë¼ìš´ë“œ: ì „ë°˜ì‚¬ ì—¬ë¶€ -->
        <button class="game-btn game-tir" id="btnTirYes">ì „ë°˜ì‚¬</button>
        <button class="game-btn game-tir" id="btnTirNo">ì „ë°˜ì‚¬ ì•„ë‹˜</button>

        <!-- 6~10ë¼ìš´ë“œ: êµ´ì ˆê° ë²”ìœ„ -->
        <button class="game-btn game-range" id="btnR0_30">Î¸â‚‚: 0Â° ~ 30Â°</button>
        <button class="game-btn game-range" id="btnR30_60">Î¸â‚‚: 30Â° ~ 60Â°</button>
        <button class="game-btn game-range" id="btnR60_90">Î¸â‚‚: 60Â° ~ 90Â°</button>
        <button class="game-btn game-range" id="btnRTIR">ì „ë°˜ì‚¬</button>
      </div>
      <div class="game-footer">
        <span class="game-score" id="gp-score">ì ìˆ˜: 0ì  / 500ì </span>
        <button class="game-btn primary" id="btnNextRound">ë„ì „ ì‹œì‘</button>
      </div>
      <div class="game-feedback" id="gp-feedback"></div>
    </div>

    <div id="footer">ì™•ì™•ë¬¼ë¦¬ì‹œë®¬ë ˆì´ì…˜</div>

    <script>
      // --- ë¬¼ì§ˆ ë°ì´í„° & ìƒ‰ìƒ ---
      const MATERIALS = {
        ê³µê¸°:1.0003, ë¬¼:1.333, ì–¼ìŒ:1.309, ì•„í¬ë¦´:1.49,
        í¬ë¼ìš´ìœ ë¦¬:1.52, í”Œë¦°íŠ¸ìœ ë¦¬:1.62, ë‹¤ì´ì•„ëª¬ë“œ:2.417
      };
      const REGION_COLORS = {
        ê³µê¸°:'#93c5fd', ë¬¼:'#60a5fa', ì–¼ìŒ:'#7dd3fc',
        ì•„í¬ë¦´:'#86efac', í¬ë¼ìš´ìœ ë¦¬:'#a78bfa',
        í”Œë¦°íŠ¸ìœ ë¦¬:'#f59e0b', ë‹¤ì´ì•„ëª¬ë“œ:'#f472b6'
      };

      const COLOR_INCIDENT = '#ff5050';
      const COLOR_REFLECT  = '#ffaa00';
      const COLOR_REFRACT  = '#2563eb';

      const R_INCIDENT = 100;
      const R_REFLECT  = 120;
      const R_REFRACT  = 100;
      const R_CRIT     = 140;

      let topName = 'ê³µê¸°';
      let botName = 'í¬ë¼ìš´ìœ ë¦¬';
      let showReflection = true;
      let selTop, selBottom, cbReflect;

      let cx, cy;
      let handle = { x:0, y:0, r:16, dragging:false };

      let canvasP5;

      // ====== ë„ì „ ëª¨ë“œ ìƒíƒœ ======
      const TOTAL_ROUNDS = 10;
      let gameRound = 0;
      let gameActive = false;
      let gameReveal = false;
      let gameState = 'idle';
      let currentScore = 0;
      let bestScore = 0;

      let currentQuestion = null;

      let gpRoundEl, gpQuestionEl, gpScoreEl, gpFeedbackEl;
      let btnNextRound, btnTirYes, btnTirNo, btnR0_30, btnR30_60, btnR60_90, btnRTIR;
      let gpBestValueEl, gpBestBadgeEl;

      function setup(){
        canvasP5 = createCanvas(windowWidth, windowHeight - 130);
        canvasP5.parent('sketch');

        canvasP5.elt.style.touchAction = 'none';
        canvasP5.elt.addEventListener('touchmove', e => e.preventDefault(), { passive:false });

        cx = width/2; cy = height/2;
        handle.x = cx - 180; handle.y = cy - 180;

        buildUI();
        initGameUI();
        drawLegend();
      }

      function buildUI(){
        const uiDiv = document.getElementById('ui'); uiDiv.innerHTML = '';

        const l1 = document.createElement('span'); l1.textContent = 'ìœ„ ë§¤ì§ˆ: '; l1.style.marginRight='6px'; uiDiv.appendChild(l1);
        selTop = createSelect(); selTop.parent(uiDiv);
        Object.keys(MATERIALS).forEach(n=> selTop.option(`${n} (n=${MATERIALS[n]})`, n));
        selTop.selected(topName);
        selTop.changed(()=>{ topName = selTop.value(); drawLegend(); });

        const gap = document.createElement('span'); gap.style.margin='0 10px'; uiDiv.appendChild(gap);
        const l2 = document.createElement('span'); l2.textContent = 'ì•„ë˜ ë§¤ì§ˆ: '; l2.style.marginRight='6px'; uiDiv.appendChild(l2);
        selBottom = createSelect(); selBottom.parent(uiDiv);
        Object.keys(MATERIALS).forEach(n=> selBottom.option(`${n} (n=${MATERIALS[n]})`, n));
        selBottom.selected(botName);
        selBottom.changed(()=>{ botName = selBottom.value(); drawLegend(); });

        const spacer = document.createElement('span'); spacer.style.margin='0 14px'; uiDiv.appendChild(spacer);
        cbReflect = createCheckbox('ë°˜ì‚¬ í‘œì‹œ', showReflection);
        cbReflect.parent(uiDiv);
        cbReflect.changed(()=> { showReflection = cbReflect.checked(); });
      }

      // ====== ë„ì „ ëª¨ë“œ UI ì´ˆê¸°í™” ======
      function initGameUI(){
        gpRoundEl    = document.getElementById('gp-round');
        gpQuestionEl = document.getElementById('gp-question');
        gpScoreEl    = document.getElementById('gp-score');
        gpFeedbackEl = document.getElementById('gp-feedback');
        btnNextRound = document.getElementById('btnNextRound');
        btnTirYes    = document.getElementById('btnTirYes');
        btnTirNo     = document.getElementById('btnTirNo');
        btnR0_30     = document.getElementById('btnR0_30');
        btnR30_60    = document.getElementById('btnR30_60');
        btnR60_90    = document.getElementById('btnR60_90');
        btnRTIR      = document.getElementById('btnRTIR');

        gpBestValueEl = document.getElementById('gp-best-value');
        gpBestBadgeEl = document.getElementById('gp-best');

        btnTirYes.addEventListener('click', ()=>handleAnswer('TIR'));
        btnTirNo.addEventListener('click',  ()=>handleAnswer('NO_TIR'));
        btnR0_30.addEventListener('click',  ()=>handleAnswer('R_0_30'));
        btnR30_60.addEventListener('click', ()=>handleAnswer('R_30_60'));
        btnR60_90.addEventListener('click', ()=>handleAnswer('R_60_90'));

        btnRTIR.addEventListener('click',   ()=>handleAnswer('R_TIR'));

        btnNextRound.addEventListener('click', ()=>{
          if (gameState === 'idle' || gameState === 'finished') {
            startNewGame();
          } else if (gameState === 'feedback') {
            if (gameRound >= TOTAL_ROUNDS) {
              endGame();
            } else {
              nextQuestion();
            }
          }
        });
const gamePanel = document.getElementById('gamePanel');
[
  'pointerdown','pointermove','pointerup',
  'touchstart','touchmove','touchend',
  'mousedown','mousemove','mouseup'
].forEach(evt=>{
  gamePanel.addEventListener(evt, (e)=>{
    e.stopPropagation(); // ğŸ”¥ ìº”ë²„ìŠ¤ë¡œ ì´ë²¤íŠ¸ê°€ ë‚´ë ¤ê°€ëŠ” ê±¸ ì°¨ë‹¨
  }, { passive:false });
});

        updateScoreUI();
        updateRoundUI();
        updateQuestionText();
        updateAnswerButtonsVisibility();
        updateBestUI();
      }

      function updateScoreUI(){
        if (!gpScoreEl) return;
        gpScoreEl.textContent = `ì ìˆ˜: ${currentScore}ì  / 500ì `;
        gpScoreEl.classList.remove('bump');
        void gpScoreEl.offsetWidth;
        gpScoreEl.classList.add('bump');
        updateBestUI();
      }

      function updateBestUI(){
        if (!gpBestValueEl || !gpBestBadgeEl) return;
        gpBestValueEl.textContent = bestScore;
        gpBestBadgeEl.classList.remove('bump');
        void gpBestBadgeEl.offsetWidth;
        gpBestBadgeEl.classList.add('bump');
      }

      function updateRoundUI(){
        if (!gpRoundEl) return;
        gpRoundEl.textContent = `ë¼ìš´ë“œ: ${gameRound} / ${TOTAL_ROUNDS}`;
      }

      function updateQuestionText(){
        if (!gpQuestionEl) return;
        if (!currentQuestion){
          gpQuestionEl.innerHTML =
            `<b>ë„ì „ ì‹œì‘</b> ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ì„ì˜ì˜ ë§¤ì§ˆÂ·ì…ì‚¬ê°ì´ ì œì‹œë©ë‹ˆë‹¤.<br>` +
            `1~5ë¼ìš´ë“œ: ì „ë°˜ì‚¬ ì—¬ë¶€, 6~8ë¼ìš´ë“œ: êµ´ì ˆê° ë²”ìœ„, 9~10ë¼ìš´ë“œ: ì„ê³„ê° ê·¼ì²˜ êµ´ì ˆê° ë²”ìœ„ë¥¼ ë§í˜€ ë³´ì„¸ìš”.`;
          return;
        }
        const { round, stageType, nTopName, nBottomName, n1, n2, theta1 } = currentQuestion;
        let typeLabel = '';
        if (stageType === 'tir') typeLabel = 'ë‚œì´ë„: í•˜ â€” ì „ë°˜ì‚¬ ì—¬ë¶€ ë§íˆê¸°';
        else if (stageType === 'range') typeLabel = 'ë‚œì´ë„: ì¤‘ â€” êµ´ì ˆê° ë²”ìœ„ ë§íˆê¸°';
        else typeLabel = 'ë‚œì´ë„: ìƒ â€” ì„ê³„ê° ê·¼ì²˜ êµ´ì ˆê° ë²”ìœ„ ë§íˆê¸°';

        const msg =
          `<b>${typeLabel}</b><br>` +
          `ë¼ìš´ë“œ ${round} / ${TOTAL_ROUNDS}<br>` +
          `ìœ„ ë§¤ì§ˆ: ${nTopName} (nâ‚=${n1.toFixed(3)}), ` +
          `ì•„ë˜ ë§¤ì§ˆ: ${nBottomName} (nâ‚‚=${n2.toFixed(3)})<br>` +
          `ì…ì‚¬ê° Î¸â‚ â‰ˆ ${theta1.toFixed(1)}Â° ì—ì„œ ` +
          (stageType === 'tir'
            ? `<b>ì „ë°˜ì‚¬ ì—¬ë¶€</b>ë¥¼ ì„ íƒí•˜ì„¸ìš”.`
            : `<b>êµ´ì ˆê° Î¸â‚‚ ì˜ ë²”ìœ„</b>ë¥¼ ì„ íƒí•˜ì„¸ìš”.`);
        gpQuestionEl.innerHTML = msg;
      }

      function updateAnswerButtonsVisibility(){
        const tirStage   = currentQuestion && currentQuestion.stageType === 'tir';
        const rangeStage = currentQuestion && currentQuestion.stageType !== 'tir';
        document.querySelectorAll('.game-tir').forEach(btn=>{
          btn.style.display = tirStage ? 'inline-flex' : 'none';
        });
        document.querySelectorAll('.game-range').forEach(btn=>{
          btn.style.display = rangeStage ? 'inline-flex' : 'none';
        });
        if (!currentQuestion){
          document.querySelectorAll('.game-range').forEach(btn=>{
            btn.style.display = 'none';
          });
          document.querySelectorAll('.game-tir').forEach(btn=>{
            btn.style.display = 'inline-flex';
          });
        }
      }

      function setAnswerButtonsDisabled(disabled){
        [btnTirYes, btnTirNo, btnR0_30, btnR30_60, btnR60_90, btnRTIR].forEach(btn=>{
          if (btn) btn.disabled = disabled;
        });
      }

      function setMaterialSelectorsEnabled(enabled){
        if (selTop && selTop.elt)    selTop.elt.disabled = !enabled;
        if (selBottom && selBottom.elt) selBottom.elt.disabled = !enabled;
        if (cbReflect && cbReflect.elt) cbReflect.elt.disabled = !enabled;
      }

      function randomChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

      function setHandleForAngle(thetaDeg, sideSign){
        const t = radians(thetaDeg);
        const r = 220;
        const vx = sideSign * Math.sin(t);
        const vy = Math.cos(t);
        handle.x = cx - r * vx;
        handle.y = cy - r * vy;
      }

      function startNewGame(){
        gameActive  = true;
        gameReveal  = false;
        gameRound   = 0;
        currentScore = 0;
        gameState   = 'feedback';
        gpFeedbackEl.textContent = '';
        gpFeedbackEl.className   = 'game-feedback';
        btnNextRound.textContent = 'ë‹¤ìŒ ë¼ìš´ë“œ';
        updateScoreUI();
        updateRoundUI();
        nextQuestion();
      }

      function nextQuestion(){
        gameRound++;
        if (gameRound > TOTAL_ROUNDS){
          endGame();
          return;
        }
        gameState  = 'question';
        gameReveal = false;
        gpFeedbackEl.textContent = '';
        gpFeedbackEl.className   = 'game-feedback';
        updateRoundUI();
        btnNextRound.disabled = true;

        currentQuestion = generateQuestionForRound(gameRound);
        updateQuestionText();
        updateAnswerButtonsVisibility();
        setAnswerButtonsDisabled(false);
        setMaterialSelectorsEnabled(false);
      }

      function endGame(){
        gameState  = 'finished';
        gameActive = false;
        gameReveal = true;
        setMaterialSelectorsEnabled(true);
        setAnswerButtonsDisabled(true);
        btnNextRound.disabled  = false;
        btnNextRound.textContent = 'ë‹¤ì‹œ ë„ì „';
        if (gpFeedbackEl){
          gpFeedbackEl.className = 'game-feedback ok';
          gpFeedbackEl.textContent =
            `ë„ì „ ì¢…ë£Œ! ì´ ì ìˆ˜ëŠ” ${currentScore}ì  / 500ì ì…ë‹ˆë‹¤. ` +
            `ë‹¤ì‹œ ë„ì „í•´ì„œ ìµœê³  ì ìˆ˜ë¥¼ ê°±ì‹ í•´ ë³´ì„¸ìš”.`;
        }
        currentQuestion = null;
        updateQuestionText();
      }

      function generateQuestionForRound(round){
        const names = Object.keys(MATERIALS);
        let stageType;
        if (round <= 5) stageType = 'tir';
        else if (round <= 8) stageType = 'range';
        else stageType = 'rangeHard';

        let nTopName, nBottomName, n1, n2, theta1, isTIR, theta2Deg = null, correctKey;

        if (stageType === 'tir'){
          const wantTIR = Math.random() < 0.5;
          while (true){
            nTopName    = randomChoice(names);
            nBottomName = randomChoice(names);
            if (nTopName === nBottomName) continue;
            n1 = MATERIALS[nTopName];
            n2 = MATERIALS[nBottomName];

            let candidateTheta;
            if (wantTIR){
              if (n1 <= n2) continue;
              const thetaC = degrees(Math.asin(n2 / n1));
              const low = Math.min(thetaC + 5, 80);
              const high = 88;
              candidateTheta = low + Math.random()*(high - low);
            } else {
              if (Math.random() < 0.5){
                if (n1 > n2) continue;
                candidateTheta = 10 + Math.random()*70;
              } else {
                if (n1 <= n2) continue;
                const thetaC = degrees(Math.asin(n2 / n1));
                const low = 10;
                const high = Math.max(thetaC - 5, 20);
                candidateTheta = low + Math.random()*(high - low);
              }
            }
            theta1 = candidateTheta;
            const sin1 = Math.sin(radians(theta1));
            const sin2 = (n1 / n2) * sin1;
            isTIR = (n1 > n2 && sin2 > 1 - 1e-12);
            if (wantTIR && isTIR) break;
            if (!wantTIR && !isTIR) break;
          }
        } else {
          while (true){
            nTopName    = randomChoice(names);
            nBottomName = randomChoice(names);
            if (nTopName === nBottomName) continue;
            n1 = MATERIALS[nTopName];
            n2 = MATERIALS[nBottomName];

            let tMin = 10, tMax = 80;
            if (stageType === 'rangeHard'){
              if (n1 > n2){
                const thetaC = degrees(Math.asin(Math.min(1, n2 / n1)));
                tMin = Math.max(5, thetaC - 8);
                tMax = Math.min(88, thetaC + 8);
              } else {
                tMin = 50;
                tMax = 85;
              }
            }
            theta1 = tMin + Math.random()*(tMax - tMin);
            const sin1 = Math.sin(radians(theta1));
            const sin2 = (n1 / n2) * sin1;
            isTIR = (n1 > n2 && sin2 > 1 - 1e-12);
            const ok = true;
            if (ok) break;
          }
        }

        if (!isTIR){
          const sin1 = Math.sin(radians(theta1));
          const sin2 = (n1 / n2) * sin1;
          theta2Deg = degrees(Math.asin(constrain(sin2, -1, 1)));
        }

        if (stageType === 'tir'){
          correctKey = isTIR ? 'TIR' : 'NO_TIR';
        } else {
          if (isTIR) correctKey = 'R_TIR';
          else if (theta2Deg < 30) correctKey = 'R_0_30';
          else if (theta2Deg < 60) correctKey = 'R_30_60';
          else correctKey = 'R_60_90';
        }

        topName = nTopName;
        botName = nBottomName;
        if (selTop && selBottom){
          selTop.selected(topName);
          selBottom.selected(botName);
        }
        drawLegend();

        const sideSign = Math.random() < 0.5 ? 1 : -1;
        setHandleForAngle(theta1, sideSign);

        draw();

        return {
          round,
          stageType,
          nTopName, nBottomName,
          n1, n2,
          theta1,
          isTIR,
          theta2Deg,
          correctKey
        };
      }

      function handleAnswer(selectedKey){
        if (!gameActive) return;
        if (gameState !== 'question') return;
        if (!currentQuestion) return;

        gameReveal = true;
        gameState  = 'feedback';
        setMaterialSelectorsEnabled(true);
        setAnswerButtonsDisabled(true);
        btnNextRound.disabled = false;

        const isCorrect = (selectedKey === currentQuestion.correctKey);
        if (isCorrect){
          currentScore += 50;
          if (currentScore > bestScore){
            bestScore = currentScore;
            if (window.saveBestScoreToFirebase){
              window.saveBestScoreToFirebase(bestScore);
            }
          }
          if (gpFeedbackEl){
            gpFeedbackEl.className = 'game-feedback ok';
            let extra = '';
            if (currentQuestion.theta2Deg != null && !currentQuestion.isTIR){
              const t2 = currentQuestion.theta2Deg.toFixed(1);
              extra = ` (ì‹¤ì œ Î¸â‚‚ â‰ˆ ${t2}Â°)`;
            }
            gpFeedbackEl.textContent = `ì •ë‹µì…ë‹ˆë‹¤! +50ì ${extra}`;
          }
        } else {
          if (gpFeedbackEl){
            gpFeedbackEl.className = 'game-feedback bad';
            let correctText = '';
            if (currentQuestion.stageType === 'tir'){
              correctText = currentQuestion.isTIR ? 'ì „ë°˜ì‚¬' : 'ì „ë°˜ì‚¬ ì•„ë‹˜';
            } else {
              const k = currentQuestion.correctKey;
              if (k === 'R_TIR') correctText = 'ì „ë°˜ì‚¬';
              else if (k === 'R_0_30') correctText = 'Î¸â‚‚: 0Â°~30Â°';
              else if (k === 'R_30_60') correctText = 'Î¸â‚‚: 30Â°~60Â°';
              else if (k === 'R_60_90') correctText = 'Î¸â‚‚: 60Â°~90Â°';
            }
            let extra = '';
            if (currentQuestion.theta2Deg != null && !currentQuestion.isTIR){
              extra = ` (ì‹¤ì œ Î¸â‚‚ â‰ˆ ${currentQuestion.theta2Deg.toFixed(1)}Â°)`;
            }
            gpFeedbackEl.textContent =
              `ì•„ì‰½ë„¤ìš”, ì˜¤ë‹µì…ë‹ˆë‹¤. ì •ë‹µì€ "${correctText}" ì…ë‹ˆë‹¤.${extra}`;
          }
        }
        updateScoreUI();
        draw();

        if (gameRound >= TOTAL_ROUNDS){
          btnNextRound.textContent = 'ìµœì¢… ê²°ê³¼ ë³´ê¸°';
        } else {
          btnNextRound.textContent = 'ë‹¤ìŒ ë¼ìš´ë“œ';
        }
      }

      // ===== ê¸°ì¡´ ì‹œë®¬ë ˆì´ì…˜ draw =====
      function draw(){
        background('#eef6ff');
        drawRegions();

        const nTop = MATERIALS[topName];
        const nBottom = MATERIALS[botName];

        stroke(120); strokeWeight(2.5); line(0, cy, width, cy);

        drawAngleTicks(R_REFLECT*1.5/2, R_REFRACT*1.5/2);

        drawDashedLine(cx, cy-160, cx, cy+160, 8);
        noStroke(); fill(50); textSize(18); text('ë²•ì„ ', cx+10, cy-130);

        noStroke(); fill(20); textSize(20);
        text(`ìœ„ ë§¤ì§ˆ nâ‚ = ${nTop.toFixed(3)} (${topName})`, 20, 22);
        text(`ì•„ë˜ ë§¤ì§ˆ nâ‚‚ = ${nBottom.toFixed(3)} (${botName})`, 20, 46);

        handle.y = Math.min(handle.y, cy-12);

        const v = createVector(cx - handle.x, cy - handle.y);
        if (v.mag() < 1) return;
        const vUnit = v.copy().normalize();
        const signX = Math.sign(vUnit.x) || 1;
        const normal = createVector(0,1);
        const cos1 = constrain(vUnit.dot(normal), -1, 1);
        const theta1 = degrees(Math.acos(cos1));
        const sin1 = Math.sin(radians(theta1));

        const sin2 = (nTop / nBottom) * sin1;
        const isTIR = (nTop > nBottom && sin2 > 1 - 1e-12);
        const theta2 = isTIR ? null : degrees(Math.asin(constrain(sin2, -1, 1)));
        let thetaC = null;
        if (nTop > nBottom) thetaC = degrees(Math.asin(constrain(nBottom / nTop, -1, 1)));

        stroke(COLOR_INCIDENT); strokeWeight(3.5);
        line(handle.x, handle.y, cx, cy);
        noStroke(); fill('#ff4444'); circle(handle.x, handle.y, handle.r*1.6);

        const effectiveShowReflection = showReflection && !(gameActive && !gameReveal);

        if (effectiveShowReflection) {
          const reflectDir = createVector(vUnit.x, -vUnit.y);
          drawRay(cx, cy, reflectDir, COLOR_REFLECT);
        }
        if (!isTIR && theta2 !== null){
          const tDir = createVector(signX * Math.sin(radians(theta2)), Math.cos(radians(theta2)));
          const allowRefract = !(gameActive && !gameReveal);
          if (allowRefract){
            drawRay(cx, cy, tDir, COLOR_REFRACT);
          }
        }

        drawAngleArcs(theta1, theta2, isTIR, signX, thetaC, effectiveShowReflection);

        fill(20); noStroke(); textSize(20);
        text(`ì…ì‚¬ê° Î¸â‚ = ${nf(theta1,1,1)}Â°`, 20, 80);
        text(`ë°˜ì‚¬ê° Î¸áµ£ = ${nf(theta1,1,1)}Â°`, 20, 105);

        if (gameActive && !gameReveal){
          text(`êµ´ì ˆê° Î¸â‚‚ = ???`, 20, 130);
        } else {
          if (isTIR) text(`êµ´ì ˆê° Î¸â‚‚ = â€” (ì „ë°˜ì‚¬)`, 20, 130);
          else text(`êµ´ì ˆê° Î¸â‚‚ = ${nf(theta2,1,1)}Â°`, 20, 130);
        }

        if (thetaC !== null) text(`ì„ê³„ê° Î¸_c = ${nf(thetaC,1,1)}Â°`, 20, 155);
        else text(`ì„ê³„ê°: ì—†ìŒ (nâ‚ â‰¤ nâ‚‚)`, 20, 155);

        textSize(22); fill(17,94,89);
        text(`ìŠ¤ë„¬ì˜ ë²•ì¹™:  nâ‚Â·sinÎ¸â‚ = nâ‚‚Â·sinÎ¸â‚‚`, 20, 185);
      }

      function drawRegions(){
        const colTop = REGION_COLORS[topName] || '#cbd5e1';
        const colBot = REGION_COLORS[botName] || '#cbd5e1';
        push(); noStroke(); fill(hexToRGBA(colTop, 0.28)); rect(0, 0, width, cy); pop();
        push(); noStroke(); fill(hexToRGBA(colBot, 0.24)); rect(0, cy, width, height-cy); pop();
      }

      function drawAngleTicks(topLen, botLen){
        const SCALE = 1.0;
        topLen *= SCALE; botLen *= SCALE;

        push();
        for (let d=5; d<=85; d+=5){
          const bold = (d % 10 === 0);
          const Ltop = bold ? topLen : topLen*0.65;
          const Lbot = bold ? botLen : botLen*0.65;
          stroke(120, bold ? 220 : 160); strokeWeight(bold ? 1.8 : 1.2);

          const aTopR = -HALF_PI + radians(d);
          const aTopL = -HALF_PI - radians(d);
          const aBotR =  HALF_PI - radians(d);
          const aBotL =  HALF_PI + radians(d);

          line(cx, cy, cx + Ltop*Math.cos(aTopR), cy + Ltop*Math.sin(aTopR));
          line(cx, cy, cx + Ltop*Math.cos(aTopL), cy + Ltop*Math.sin(aTopL));
          line(cx, cy, cx + Lbot*Math.cos(aBotR), cy + Lbot*Math.sin(aBotR));
          line(cx, cy, cx + Lbot*Math.cos(aBotL), cy + Lbot*Math.sin(aBotL));
        }
        pop();
      }

      function arcWithLabel(r, start, end, col, label, offset=14, textSizePx=18){
        push();
        noFill(); stroke(col); strokeWeight(2);
        arc(cx, cy, r*2, r*2, start, end);
        const mid = (start + end)/2;
        const lx = cx + (r + offset) * Math.cos(mid);
        const ly = cy + (r + offset) * Math.sin(mid);
        noStroke(); fill(col); textSize(textSizePx); textAlign(CENTER, CENTER);
        text(label, lx, ly);
        pop();
      }

      function drawAngleArcs(theta1, theta2, isTIR, signX, thetaC, effectiveShowReflection){
        if (signX > 0){
          arcWithLabel(R_INCIDENT, -HALF_PI - radians(theta1), -HALF_PI, COLOR_INCIDENT, 'Î¸â‚');
        } else {
          arcWithLabel(R_INCIDENT, -HALF_PI, -HALF_PI + radians(theta1), COLOR_INCIDENT, 'Î¸â‚');
        }

        if (effectiveShowReflection && !(gameActive && !gameReveal)){
          if (signX > 0){
            arcWithLabel(R_REFLECT, -HALF_PI, -HALF_PI + radians(theta1), COLOR_REFLECT, 'Î¸áµ£');
          } else {
            arcWithLabel(R_REFLECT, -HALF_PI - radians(theta1), -HALF_PI, COLOR_REFLECT, 'Î¸áµ£');
          }
        }

        if (thetaC !== null){
          const colCrit = 'rgba(80,80,80,0.7)';
          if (signX > 0){
            arcWithLabel(R_CRIT, -HALF_PI - radians(thetaC), -HALF_PI, colCrit, 'Î¸_c', 10, 14);
          } else {
            arcWithLabel(R_CRIT, -HALF_PI, -HALF_PI + radians(thetaC), colCrit, 10, 14);
          }
        }

        if (!isTIR && theta2 !== null && !(gameActive && !gameReveal)){
          if (signX > 0){
            arcWithLabel(R_REFRACT, HALF_PI - radians(theta2), HALF_PI, COLOR_REFRACT, 'Î¸â‚‚');
          } else {
            arcWithLabel(R_REFRACT, HALF_PI, HALF_PI + radians(theta2), COLOR_REFRACT, 'Î¸â‚‚');
          }
        }
      }

      function drawRay(x,y,dir,col){
        push(); stroke(col); strokeWeight(3.5);
        line(x, y, x + dir.x*240, y + dir.y*240);
        pop();
      }

      function drawDashedLine(x1,y1,x2,y2, dash=8){
        push(); stroke(100); strokeWeight(1.6);
        const dx = x2-x1, dy=y2-y1; const len = Math.hypot(dx,dy);
        const ux = dx/len, uy = dy/len;
        for(let i=0;i<len;i+=dash*2){
          const sx = x1 + ux*i; const sy = y1 + uy*i;
          const ex = x1 + ux*Math.min(i+dash, len);
          const ey = y1 + uy*Math.min(i+dash, len);
          line(sx,sy,ex,ey);
        }
        pop();
      }

      function hexToRGBA(hex, a){
        const m = /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i.exec(hex);
        if(!m) return color(0,0,0,a*255);
        const r = parseInt(m[1],16), g=parseInt(m[2],16), b=parseInt(m[3],16);
        return color(r, g, b, a*255);
      }

      // ===== ì¸í„°ë™ì…˜ =====
 function isTouchOnUI(e){
  if(!e || !e.target) return false;
  // UI ì˜ì—­ë“¤: í—¤ë”(ë§¤ì§ˆ/ë°˜ì‚¬ í‘œì‹œ), ë„ì „íŒ¨ë„, ë²”ë¡€, í‘¸í„°
  return !!(
    e.target.closest('#gamePanel') ||
    e.target.closest('#ui') ||
    e.target.closest('#legend') ||
    e.target.closest('header') ||
    e.target.closest('#footer')
  );
}
function startDrag(x, y){
  const d = dist(x, y, handle.x, handle.y);
  // ë„ì „ ëª¨ë“œì—ì„œ ì •ë‹µ ê³µê°œ ì „ì—ëŠ” ê³ ì •
  if (gameActive && !gameReveal) return;

  if (d < handle.r * 1.6){
    handle.dragging = true;
  }
}

function moveDrag(x, y){
  if (!handle.dragging) return;
  handle.x = x;
  handle.y = y;
}

function endDrag(){
  handle.dragging = false;
}

function touchStarted(e){
  // âœ… UI ìœ„ì—ì„œ í„°ì¹˜ë©´: p5ê°€ ê°€ë¡œì±„ì§€ ë§ê³  ë¸Œë¼ìš°ì €/DOMì—ê²Œ ë§¡ê¹€
  if (isTouchOnUI(e)) return true;

  const t = touches[0] || {x:mouseX,y:mouseY};
  startDrag(t.x, t.y);

  // âœ… ìº”ë²„ìŠ¤ ì¡°ì‘(ë“œë˜ê·¸)ë§Œ ê¸°ë³¸ë™ì‘ ì°¨ë‹¨
  return false;
}

function touchMoved(e){
  // âœ… UI ìœ„ì—ì„œì˜ ìŠ¤ì™€ì´í”„/ë“œë˜ê·¸ëŠ”(ìŠ¤í¬ë¡¤/ì…€ë ‰íŠ¸ ì œìŠ¤ì²˜) ë§‰ì§€ ì•ŠìŒ
  if (isTouchOnUI(e)) return true;

  const t = touches[0] || {x:mouseX,y:mouseY};
  moveDrag(t.x, t.y);

  return false;
}

function touchEnded(e){
  if (isTouchOnUI(e)) return true;

  endDrag();
  return false;
}
function mousePressed(){
  // ìº”ë²„ìŠ¤ ìœ„ ì¢Œí‘œì˜ ì‹¤ì œ DOM ìš”ì†Œë¥¼ ê°€ì ¸ì™€ì„œ UI í´ë¦­ì´ë©´ ë“œë˜ê·¸ ì‹œì‘ ì•ˆ í•¨
  const el = document.elementFromPoint(mouseX, mouseY);
  if (isTouchOnUI({ target: el })) return;

  startDrag(mouseX, mouseY);
}

function mouseDragged(){
  moveDrag(mouseX, mouseY);
  return false;
}

function mouseReleased(){
  endDrag();
}
      function windowResized(){ resizeCanvas(windowWidth, windowHeight - 130); cx = width/2; cy = height/2; }

      function drawLegend(){
        const el = document.getElementById('legend');
        const tCol = REGION_COLORS[topName];
        const bCol = REGION_COLORS[botName];
        el.innerHTML = `
          <div><span class="sw" style="background:${tCol}"></span>ìœ„ ë§¤ì§ˆ ì˜ì—­: ${topName}</div>
          <div><span class="sw" style="background:${bCol}"></span>ì•„ë˜ ë§¤ì§ˆ ì˜ì—­: ${botName}</div>
          <hr style="border:none;border-top:1px solid #c7defd;margin:8px 0;">
          <div><span class="sw" style="background:${COLOR_INCIDENT}"></span>ì…ì‚¬ì„ </div>
          <div><span class="sw" style="background:${COLOR_REFLECT}"></span>ë°˜ì‚¬ì„ </div>
          <div><span class="sw" style="background:${COLOR_REFRACT}"></span>êµ´ì ˆì„ </div>`;
      }

      window.setBestScoreFromFirebase = function(score){
        bestScore = Number(score) || 0;
        updateBestUI();
        updateScoreUI();
      };
    </script>

    <!-- ===== Firebase ì ìˆ˜ ì—°ë™ (ìŠ¤ë„¬ì˜ ë²•ì¹™) ===== -->
    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
      import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";
      import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";

      const firebaseConfig = {
        apiKey: "AIzaSyCO36JgPpNz8swADxTMVJUFVALWM5o171w",
        authDomain: "simulation-67cd3.firebaseapp.com",
        projectId: "simulation-67cd3",
        storageBucket: "simulation-67cd3.appspot.com",
        messagingSenderId: "615983461615",
        appId: "1:615983461615:web:002e07bcea878eb6d5571a",
        measurementId: "G-9RGN7LYE5W"
      };

      const app  = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const db   = getFirestore(app);

      const SIM_ID = "ìŠ¤ë„¬ì˜_ë²•ì¹™";

      let firebaseUser = null;

      async function saveBestScore(score) {
        if (!firebaseUser) return;
        try {
          const ref = doc(db, "users", firebaseUser.uid, "simulations", SIM_ID);
          await setDoc(ref, { score: Number(score) || 0 }, { merge: true });
        } catch (err) {
          console.error("[ìŠ¤ë„¬ì˜ ë²•ì¹™] ìµœê³  ì ìˆ˜ ì €ì¥ ì˜¤ë¥˜:", err);
        }
      }

      async function loadBestScore() {
        if (!firebaseUser) return;
        try {
          const ref = doc(db, "users", firebaseUser.uid, "simulations", SIM_ID);
          const snap = await getDoc(ref);
          if (snap.exists()) {
            const data  = snap.data();
            const score = Number(data.score || 0) || 0;
            if (window.setBestScoreFromFirebase) {
              window.setBestScoreFromFirebase(score);
            }
          }
        } catch (err) {
          console.error("[ìŠ¤ë„¬ì˜ ë²•ì¹™] ìµœê³  ì ìˆ˜ ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜:", err);
        }
      }

      window.saveBestScoreToFirebase = saveBestScore;

      onAuthStateChanged(auth, async (user) => {
        firebaseUser = user;
        if (user) {
          await loadBestScore();
        }
      });
    </script>
  </body>
</html>
