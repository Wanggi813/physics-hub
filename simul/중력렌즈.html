<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>중력 렌즈</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            color: #eee; 
            font-family: sans-serif;
            touch-action: none; 
        }
        canvas { display: block; }
        #info {
            position: absolute; top: 20px; width: 100%; text-align: center;
            pointer-events: none; z-index: 10;
            text-shadow: 0 0 5px black;
            font-size: 0.9rem;
            opacity: 0.8;
        }
        @media (orientation: portrait) {
            #info { top: 10%; }
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>중력 렌즈</h3>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.Camera();
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.0)); 
        document.body.appendChild(renderer.domElement);

        const loader = new THREE.TextureLoader();
        const earthTexture = loader.load('./image/세계전도.png');
        const sunTexture = loader.load('./image/태양전도.png');

        // --- [핵심 수정] 텍스처 반복 방지 설정 ---
        // 텍스처 좌표가 0~1 범위를 벗어나면 가장자리 색상을 사용하도록 설정합니다.
        earthTexture.wrapS = earthTexture.wrapT = THREE.ClampToEdgeWrapping;
        sunTexture.wrapS = sunTexture.wrapT = THREE.ClampToEdgeWrapping;
        
        // 좌표: 태양(뒤) - 블랙홀(중간) - 지구(앞)
        const bhPos = new THREE.Vector3(0.0, 0.0, 0.0);
        const earthPos = new THREE.Vector3(0.0, 0.0, -10.0);
        const sunPos = new THREE.Vector3(0.0, 0.0, 50.0);

        const fragmentShader = `
            precision highp float;

            uniform float iTime;
            uniform vec2 iResolution;
            uniform vec2 iMouse;
            uniform float uZoom;
            
            uniform sampler2D uTexEarth;
            uniform sampler2D uTexSun;
            uniform vec3 uBhPos;
            uniform vec3 uEarthPos;
            uniform vec3 uSunPos;

            #define PI 3.14159265359
            #define MAX_STEPS 200       
            #define MAX_DIST 200.0       
            #define SURF_DIST 0.005     
            #define EVENT_HORIZON 0.7 

            mat2 rot(float a) { float s = sin(a), c = cos(a); return mat2(c, -s, s, c); }

            vec2 getSphereUV(vec3 p, vec3 center) {
                vec3 n = normalize(p - center);
                float u = atan(n.z, n.x) / (2.0 * PI) + 0.5;
                float v = asin(n.y) / PI + 0.5;
                return vec2(1.0 - u, v);
            }

            float hash21(vec2 p) {
                p = fract(p * vec2(123.34, 456.21));
                p += dot(p, p + 45.32);
                return fract(p.x * p.y);
            }

            vec3 getBackground(vec3 dir) {
                vec3 bgCol = vec3(0.002, 0.003, 0.008); 
                float stars = pow(hash21(dir.xy * 200.0 + dir.z * 100.0), 300.0) * 0.8;
                float bigStar = pow(hash21(dir.xy * 50.0 + dir.z * 10.0), 100.0);
                if(bigStar > 0.99) stars += (bigStar - 0.99) * 200.0;
                return bgCol + vec3(stars);
            }

            vec3 ACESFilm(vec3 x) {
                float a = 2.51, b = 0.03, c = 2.43, d = 0.59, e = 0.14;
                return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);
            }

            void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
                vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;
                
                vec2 m = iMouse.xy / iResolution.xy;
                float camRotX = (m.y - 0.5) * 3.0;
                float camRotY = (m.x - 0.5) * 6.0;

                vec3 ro = vec3(0.0, 0.0, uZoom); 
                vec3 rd = normalize(vec3(uv, 1.8));

                ro.yz *= rot(camRotX); rd.yz *= rot(camRotX);
                ro.xz *= rot(camRotY); rd.xz *= rot(camRotY);

                float bhMass = 1.2;  
                float earthRad = 0.5; 
                float sunRad = 7.5;  

                vec3 col = vec3(0.0);
                vec3 p = ro;
                vec3 dir = rd;
                float totDist = 0.0;
                bool hitBH = false, hitObj = false;
                vec3 sunGlow = vec3(0.0);

                for(int i = 0; i < MAX_STEPS; i++) {
                    float dBH = length(p - uBhPos);

                    // 지구 + 대기권
                    float dEarth = length(p - uEarthPos) - earthRad;
                    if(dEarth < SURF_DIST) {
                        vec3 normal = normalize(p - uEarthPos);
                        vec3 lightDir = normalize(uSunPos - uEarthPos);
                        vec3 texCol = texture(uTexEarth, getSphereUV(p, uEarthPos)).rgb;
                        float diff = max(dot(normal, lightDir), 0.05);
                        float fresnel = pow(1.0 + dot(dir, normal), 3.0);
                        vec3 atmosphere = vec3(0.1, 0.4, 1.0) * fresnel * 1.5 * diff;
                        col = texCol * diff + atmosphere; 
                        hitObj = true; break;
                    }

                    if(dBH < EVENT_HORIZON) { hitBH = true; break; }

                    // 태양
                    float dSun = length(p - uSunPos) - sunRad;
                    if(dSun < SURF_DIST) {
                        col = texture(uTexSun, getSphereUV(p, uSunPos)).rgb;
                        col *= 4.0;
                        hitObj = true; break;
                    }

                    // 코로나 글로우
                    float distToSunCenter = length(p - uSunPos);
                    float glowIntensity = 1.0 / (distToSunCenter * distToSunCenter * 0.2 + 0.1);
                    sunGlow += vec3(1.0, 0.6, 0.2) * glowIntensity * 0.02;

                    // 렌즈 효과
                    vec3 gravDir = normalize(uBhPos - p);
                    float force = bhMass / (dBH * dBH + 0.05); 
                    dir = normalize(dir + gravDir * force * 0.2); 

                    float stepSize = max(SURF_DIST, dBH * 0.05); 
                    stepSize = min(stepSize, max(SURF_DIST, dEarth * 0.5)); 
                    stepSize = min(stepSize, max(SURF_DIST, dSun * 0.5)); 

                    p += dir * stepSize;
                    totDist += stepSize;
                    if(totDist > MAX_DIST) break;
                }

                if(hitBH) col = vec3(0.0);
                else if(!hitObj) col = getBackground(dir);

                col += sunGlow;
                col = ACESFilm(col);
                col = pow(col, vec3(0.4545));
                
                fragColor = vec4(col, 1.0);
            }
            void main() { mainImage(gl_FragColor, gl_FragCoord.xy); }
        `;

        const geometry = new THREE.PlaneGeometry(2, 2);
        const uniforms = {
            iTime: { value: 0 },
            iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
            iMouse: { value: new THREE.Vector2(window.innerWidth/2, window.innerHeight/2) },
            uZoom: { value: -70.0 },
            uTexEarth: { value: earthTexture },
            uTexSun: { value: sunTexture },
            uBhPos: { value: bhPos },
            uEarthPos: { value: earthPos },
            uSunPos: { value: sunPos }
        };

        const material = new THREE.ShaderMaterial({
            fragmentShader: fragmentShader, uniforms: uniforms
        });
        scene.add(new THREE.Mesh(geometry, material));

        // --- 입력 처리 (마우스 & 터치) ---

        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let initialPinchDistance = null; 

        document.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        document.addEventListener('mouseup', () => isDragging = false);
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                uniforms.iMouse.value.x += e.movementX * 2.0;
                uniforms.iMouse.value.y -= e.movementY * 2.0;
            }
        });
        document.addEventListener('wheel', (e) => {
            const zoomSpeed = 0.01;
            let newZoom = uniforms.uZoom.value - e.deltaY * zoomSpeed;
            newZoom = Math.max(-50.0, Math.min(-6.0, newZoom));
            uniforms.uZoom.value = newZoom;
        });

        document.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                previousMousePosition = { x: e.touches[0].pageX, y: e.touches[0].pageY };
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].pageX - e.touches[1].pageX;
                const dy = e.touches[0].pageY - e.touches[1].pageY;
                initialPinchDistance = Math.hypot(dx, dy);
            }
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            if (e.touches.length === 1 && isDragging) {
                const deltaX = e.touches[0].pageX - previousMousePosition.x;
                const deltaY = e.touches[0].pageY - previousMousePosition.y;
                uniforms.iMouse.value.x += deltaX * 2.0;
                uniforms.iMouse.value.y -= deltaY * 2.0;
                previousMousePosition = { x: e.touches[0].pageX, y: e.touches[0].pageY };
            } else if (e.touches.length === 2 && initialPinchDistance) {
                const dx = e.touches[0].pageX - e.touches[1].pageX;
                const dy = e.touches[0].pageY - e.touches[1].pageY;
                const currentDistance = Math.hypot(dx, dy);
                const diff = currentDistance - initialPinchDistance;
                const zoomSpeed = 0.05; 
                let newZoom = uniforms.uZoom.value + diff * zoomSpeed;
                newZoom = Math.max(-50.0, Math.min(-6.0, newZoom));
                uniforms.uZoom.value = newZoom;
                initialPinchDistance = currentDistance; 
            }
        }, { passive: false });

        document.addEventListener('touchend', () => {
            isDragging = false;
            initialPinchDistance = null;
        });

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);
        });

        function animate(time) {
            requestAnimationFrame(animate);
            uniforms.iTime.value = time * 0.001;
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>