<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>중력 렌즈 조절</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            color: #eee;
            font-family: sans-serif;
            touch-action: none;
        }

        canvas {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding-top: 20px;
            text-align: center;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.8);
        }

        h3 {
            margin: 0 0 10px 0;
        }

        .slider-container {
            pointer-events: auto;
            display: inline-block;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        input[type=range] {
            width: 40vw;
            max-width: 300px;
            min-width: 150px;
            vertical-align: middle;
            cursor: pointer;
        }

        #mass-value {
            font-weight: bold;
            color: #ffaa55;
            min-width: 30px;
            display: inline-block;
            text-align: left;
        }
    </style>
</head>

<body>
    <div id="ui-layer">
        <h3>중력 렌즈</h3>
        <div class="slider-container">
            <label for="mass-slider">블랙홀 질량: <span id="mass-value">1.2</span></label>
            <input type="range" id="mass-slider" min="0.0" max="5.0" step="0.1" value="1.2" />
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // =========================
        // three.js boilerplate
        // =========================
        const scene = new THREE.Scene();
        const camera = new THREE.Camera();
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.0));
        document.body.appendChild(renderer.domElement);

        const loader = new THREE.TextureLoader();
        const earthTexture = loader.load('./image/세계전도.png');
        const sunTexture = loader.load('./image/태양전도.png');
        earthTexture.wrapS = earthTexture.wrapT = THREE.ClampToEdgeWrapping;
        sunTexture.wrapS = sunTexture.wrapT = THREE.ClampToEdgeWrapping;

        // object positions
        const bhPos = new THREE.Vector3(0.0, 0.0, 0.0);
        const earthPos = new THREE.Vector3(0.0, 0.0, -20.0);
        const sunPos = new THREE.Vector3(0.0, 0.0, 100.0);

        // =========================
        // fragment shader
        // =========================
        const fragmentShader = `
      precision highp float;

      uniform float iTime;
      uniform vec2  iResolution;
      uniform vec2  iMouse;
      uniform float uZoom;
      uniform float uBhMass;

      uniform sampler2D uTexEarth;
      uniform sampler2D uTexSun;
      uniform vec3 uBhPos;
      uniform vec3 uEarthPos;
      uniform vec3 uSunPos;

      #define PI 3.14159265359
      #define MAX_STEPS 200
      #define MAX_DIST 400.0
      #define SURF_DIST 0.005
      #define EVENT_HORIZON 0.7

      mat2 rot(float a){ float s=sin(a), c=cos(a); return mat2(c,-s,s,c); }

      vec2 getSphereUV(vec3 p, vec3 center){
        vec3 n = normalize(p-center);
        float u = atan(n.z, n.x) / (2.0*PI) + 0.5;
        float v = asin(n.y) / PI + 0.5;
        return vec2(1.0-u, v);
      }

      float hash21(vec2 p){
        p = fract(p*vec2(123.34,456.21));
        p += dot(p, p+45.32);
        return fract(p.x*p.y);
      }

      vec3 getBackground(vec3 dir){
        vec3 bgCol = vec3(0.002,0.003,0.008);
        float stars   = pow(hash21(dir.xy*200.0 + dir.z*100.0), 300.0) * 0.8;
        float bigStar = pow(hash21(dir.xy*50.0  + dir.z*10.0), 100.0);
        if(bigStar > 0.99) stars += (bigStar-0.99)*200.0;
        return bgCol + vec3(stars);
      }

      vec3 ACESFilm(vec3 x){
        float a=2.51, b=0.03, c=2.43, d=0.59, e=0.14;
        return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);
      }

      // normalize(vec3(0.25,1.0,0.15)) 미리 계산(루프마다 normalize 제거)
      const vec3 DISK_N = vec3(0.2407717, 0.9630868, 0.1444630);

      void mainImage(out vec4 fragColor, in vec2 fragCoord){
        vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;

        // iMouse는 "회전 파라미터"로 사용
        vec2 m = iMouse.xy / iResolution.xy;
        float camRotX = (m.y - 0.5) * 3.0;
        float camRotY = (m.x - 0.5) * 6.0;

        vec3 ro = vec3(0.0, 0.0, uZoom);
        vec3 rd = normalize(vec3(uv, 1.8));

        ro.yz *= rot(camRotX); rd.yz *= rot(camRotX);
        ro.xz *= rot(camRotY); rd.xz *= rot(camRotY);

        float bhMass = uBhMass;
        if(bhMass < 0.05) bhMass = 0.0; // 0 근처 노이즈 제거

        float earthRad = 0.5;
        float sunRad   = 15.0;

        vec3 col     = vec3(0.0);
        vec3 p       = ro;
        vec3 dir     = rd;
        float totDist= 0.0;

        bool hitBH=false, hitObj=false;
        vec3 sunGlow  = vec3(0.0);
        vec3 diskGlow = vec3(0.0);

        for(int i=0;i<MAX_STEPS;i++){
          float dBH = length(p - uBhPos);

          // Earth
          float dEarth = length(p - uEarthPos) - earthRad;
          if(dEarth < SURF_DIST){
            vec3 normal   = normalize(p - uEarthPos);
            vec3 lightDir = normalize(uSunPos - uEarthPos);
            vec3 texCol   = texture(uTexEarth, getSphereUV(p,uEarthPos)).rgb;
            float diff    = max(dot(normal, lightDir), 0.05);
            float fresnel = pow(1.0 + dot(dir, normal), 3.0);
            vec3 atmosphere = vec3(0.1,0.4,1.0) * fresnel * 1.5 * diff;
            col = texCol*diff + atmosphere;
            hitObj=true; break;
          }

          // BH event horizon
          if(bhMass > 0.0 && dBH < EVENT_HORIZON){ hitBH=true; break; }

          // Sun
          float dSun = length(p - uSunPos) - sunRad;
          if(dSun < SURF_DIST){
            col = texture(uTexSun, getSphereUV(p,uSunPos)).rgb * 4.0;
            hitObj=true; break;
          }

          // Sun corona glow (accumulation)
          float distToSunCenter = length(p - uSunPos);
          float glowIntensity = 1.0 / (distToSunCenter*distToSunCenter*0.2 + 0.1);
          sunGlow += vec3(1.0,0.6,0.2) * glowIntensity * 0.02;

          // Accretion disk-ish glow (Interstellar-style)
          if(bhMass > 0.0){
            vec3 diskN = DISK_N;

            float h = dot(p - uBhPos, diskN);
            float distToPlane = abs(h);

            vec3 proj = (p - uBhPos) - diskN*h;
            float r = length(proj);

            float rIn  = 1.2;
            float rOut = 8.0 + 1.5*bhMass;

            float ringBand  = smoothstep(rOut, rOut-1.5, r) * smoothstep(rIn, rIn+0.6, r);
            float wH        = 0.25;
            float planeMask = exp(-pow(distToPlane / wH, 2.0));
            float edgeBoost = pow(1.0 - abs(dot(dir, diskN)), 2.2);

            float t = clamp((r - rIn) / (rOut - rIn), 0.0, 1.0);
            vec3 hot  = vec3(1.0, 0.85, 0.35);
            vec3 warm = vec3(1.0, 0.35, 0.06);
            vec3 diskCol = mix(hot, warm, pow(t, 0.85));

            vec3 tdir = normalize(cross(diskN, proj) + 1e-6);
            float dop = dot(tdir, dir);
            float beaming = clamp(1.0 + 1.2*dop, 0.25, 2.6);

            float falloff = 1.0 / (0.6 + 0.12*r*r);
            float mask = ringBand * planeMask * edgeBoost * beaming;

            diskGlow += diskCol * mask * falloff * (1.8 + 0.35*bhMass);
          }

          // Gravitational lens
          if(bhMass > 0.0 && p.z > uEarthPos.z){
            vec3 gravDir = normalize(uBhPos - p);
            float force = bhMass / (dBH*dBH + 0.05);
            dir = normalize(dir + gravDir * force * 0.2);
          }

          // Step size (simple but stable)
          float stepSize = max(SURF_DIST, min(dEarth, dSun));
          if(bhMass > 0.0){
            stepSize = min(stepSize, max(SURF_DIST, dBH * 0.05));
          }
          stepSize = max(stepSize, 0.02);

          p += dir * stepSize;
          totDist += stepSize;
          if(totDist > MAX_DIST) break;
        }

        if(hitBH) col = vec3(0.0);
        else if(!hitObj) col = getBackground(dir);

        col += sunGlow + diskGlow;
        col = ACESFilm(col);
        col = pow(col, vec3(0.4545)); // gamma
        fragColor = vec4(col, 1.0);
      }

      void main(){ mainImage(gl_FragColor, gl_FragCoord.xy); }
    `;

        const geometry = new THREE.PlaneGeometry(2, 2);

        const uniforms = {
            iTime: { value: 0 },
            iResolution: { value: new THREE.Vector2(1, 1) },
            iMouse: { value: new THREE.Vector2(0, 0) },
            uZoom: { value: -150.0 },
            uBhMass: { value: 1.2 },
            uTexEarth: { value: earthTexture },
            uTexSun: { value: sunTexture },
            uBhPos: { value: bhPos },
            uEarthPos: { value: earthPos },
            uSunPos: { value: sunPos }
        };

        const material = new THREE.ShaderMaterial({ fragmentShader, uniforms });
        scene.add(new THREE.Mesh(geometry, material));

        // =========================
        // UI
        // =========================
        const slider = document.getElementById('mass-slider');
        const massValueDisplay = document.getElementById('mass-value');
        slider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            uniforms.uBhMass.value = val;
            massValueDisplay.textContent = val.toFixed(1);
        });

        // =========================
        // Input (drag rotate / wheel+pinch zoom)
        // =========================
        let isDragging = false;
        let prevTouch = { x: 0, y: 0 };
        let pinch0 = null;

        // mouse
        document.addEventListener('mousedown', (e) => {
            if (e.target && e.target.id === 'mass-slider') return;
            isDragging = true;
        });
        document.addEventListener('mouseup', () => { isDragging = false; });
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            uniforms.iMouse.value.x += e.movementX * 2.0;
            uniforms.iMouse.value.y -= e.movementY * 2.0;
        });

        // wheel zoom
        document.addEventListener('wheel', (e) => {
            const zoomSpeed = 0.01;
            let newZoom = uniforms.uZoom.value - e.deltaY * zoomSpeed;
            uniforms.uZoom.value = Math.max(-200.0, Math.min(-20.0, newZoom));
        }, { passive: true });

        // touch
        document.addEventListener('touchstart', (e) => {
            if (e.target && e.target.id === 'mass-slider') return;

            if (e.touches.length === 1) {
                isDragging = true;
                prevTouch.x = e.touches[0].pageX;
                prevTouch.y = e.touches[0].pageY;
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].pageX - e.touches[1].pageX;
                const dy = e.touches[0].pageY - e.touches[1].pageY;
                pinch0 = Math.hypot(dx, dy);
            }
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            if (e.target && e.target.id === 'mass-slider') return;
            e.preventDefault();

            if (e.touches.length === 1 && isDragging) {
                const x = e.touches[0].pageX;
                const y = e.touches[0].pageY;
                const dx = x - prevTouch.x;
                const dy = y - prevTouch.y;

                uniforms.iMouse.value.x += dx * 2.0;
                uniforms.iMouse.value.y -= dy * 2.0;

                prevTouch.x = x; prevTouch.y = y;
            } else if (e.touches.length === 2 && pinch0) {
                const dx = e.touches[0].pageX - e.touches[1].pageX;
                const dy = e.touches[0].pageY - e.touches[1].pageY;
                const pinch1 = Math.hypot(dx, dy);

                const diff = pinch1 - pinch0;
                const zoomSpeed = 0.05;
                let newZoom = uniforms.uZoom.value + diff * zoomSpeed;
                uniforms.uZoom.value = Math.max(-200.0, Math.min(-20.0, newZoom));

                pinch0 = pinch1;
            }
        }, { passive: false });

        document.addEventListener('touchend', () => {
            isDragging = false;
            pinch0 = null;
        });

        // =========================
        // Resize (mobile-safe)
        // =========================
        function resizeRenderer() {
            const w = window.innerWidth;
            const h = window.visualViewport ? window.visualViewport.height : window.innerHeight;

            renderer.setSize(w, h, false);
            uniforms.iResolution.value.set(w, h);

            // 중심 기준을 현재 화면 중앙으로 재설정(모바일 주소창/툴바 변동 대응)
            uniforms.iMouse.value.set(w / 2, h / 2);
        }

        window.addEventListener('resize', resizeRenderer);
        if (window.visualViewport) window.visualViewport.addEventListener('resize', resizeRenderer);
        resizeRenderer();

        // =========================
        // Animation loop
        // =========================
        function animate(time) {
            requestAnimationFrame(animate);
            uniforms.iTime.value = time * 0.001;
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>

</html>