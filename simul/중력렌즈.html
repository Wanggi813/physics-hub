<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>중력 렌즈 조절</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #eee;
            font-family: sans-serif;
            touch-action: none;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding-top: 20px;
            text-align: center;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.8);
        }

        h3 {
            margin: 0 0 10px 0;
        }

        .slider-container {
            pointer-events: auto;
            display: inline-block;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        /* 슬라이더 반응형 크기 */
        input[type=range] {
            width: 40vw;
            max-width: 300px;
            min-width: 150px;
            vertical-align: middle;
            cursor: pointer;
        }

        #mass-value {
            font-weight: bold;
            color: #ffaa55;
            min-width: 30px;
            display: inline-block;
            text-align: left;
        }

        @media (orientation: portrait) {
            #ui-layer {
                top: 5%;
            }
        }
    </style>
</head>

<body>
    <div id="ui-layer">
        <h3>중력 렌즈</h3>
        <div class="slider-container">
            <label for="mass-slider">블랙홀 질량: <span id="mass-value">1.2</span></label>
            <input type="range" id="mass-slider" min="0.0" max="5.0" step="0.1" value="1.2">
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.Camera();
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.0));
        document.body.appendChild(renderer.domElement);

        const loader = new THREE.TextureLoader();
        const earthTexture = loader.load('./image/세계전도.png');
        const sunTexture = loader.load('./image/태양전도.png');

        earthTexture.wrapS = earthTexture.wrapT = THREE.ClampToEdgeWrapping;
        sunTexture.wrapS = sunTexture.wrapT = THREE.ClampToEdgeWrapping;

        // --- [수정] 거리 대폭 확장 (겹침 방지) ---
        const bhPos = new THREE.Vector3(0.0, 0.0, 0.0);
        const earthPos = new THREE.Vector3(0.0, 0.0, -20.0); // 지구를 더 앞으로 (-10 -> -20)
        const sunPos = new THREE.Vector3(0.0, 0.0, 100.0);   // 태양을 더 뒤로 (50 -> 100)

        const fragmentShader = `
            precision highp float;

            uniform float iTime;
            uniform vec2 iResolution;
            uniform vec2 iMouse;
            uniform float uZoom;
            uniform float uBhMass;

            uniform sampler2D uTexEarth;
            uniform sampler2D uTexSun;
            uniform vec3 uBhPos;
            uniform vec3 uEarthPos;
            uniform vec3 uSunPos;

            #define PI 3.14159265359
            #define MAX_STEPS 200       
            #define MAX_DIST 400.0   // [수정] 렌더링 거리 증가
            #define SURF_DIST 0.005     
            #define EVENT_HORIZON 0.7 

            mat2 rot(float a) { float s = sin(a), c = cos(a); return mat2(c, -s, s, c); }

            vec2 getSphereUV(vec3 p, vec3 center) {
                vec3 n = normalize(p - center);
                float u = atan(n.z, n.x) / (2.0 * PI) + 0.5;
                float v = asin(n.y) / PI + 0.5;
                return vec2(1.0 - u, v);
            }

            float hash21(vec2 p) {
                p = fract(p * vec2(123.34, 456.21));
                p += dot(p, p + 45.32);
                return fract(p.x * p.y);
            }

            vec3 getBackground(vec3 dir) {
                vec3 bgCol = vec3(0.002, 0.003, 0.008); 
                float stars = pow(hash21(dir.xy * 200.0 + dir.z * 100.0), 300.0) * 0.8;
                float bigStar = pow(hash21(dir.xy * 50.0 + dir.z * 10.0), 100.0);
                if(bigStar > 0.99) stars += (bigStar - 0.99) * 200.0;
                return bgCol + vec3(stars);
            }

            vec3 ACESFilm(vec3 x) {
                float a = 2.51, b = 0.03, c = 2.43, d = 0.59, e = 0.14;
                return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);
            }

            void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
                vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;
                
                vec2 m = iMouse.xy / iResolution.xy;
                float camRotX = (m.y - 0.5) * 3.0;
                float camRotY = (m.x - 0.5) * 6.0;

                vec3 ro = vec3(0.0, 0.0, uZoom); 
                vec3 rd = normalize(vec3(uv, 1.8));

                ro.yz *= rot(camRotX); rd.yz *= rot(camRotX);
                ro.xz *= rot(camRotY); rd.xz *= rot(camRotY);

                float bhMass = uBhMass;  
                float earthRad = 0.5; 
                float sunRad = 15.0; // 멀리 있는 태양을 크게 보이게

                vec3 col = vec3(0.0);
                vec3 p = ro;
                vec3 dir = rd;
                float totDist = 0.0;
                bool hitBH = false, hitObj = false;
                vec3 sunGlow = vec3(0.0);
                vec3 diskGlow = vec3(0.0);


                // --- [핵심] 질량이 아주 작으면 그냥 0으로 처리 (노이즈 방지) ---
                if (bhMass < 0.05) bhMass = 0.0;

                for(int i = 0; i < MAX_STEPS; i++) {
                    float dBH = length(p - uBhPos);

                    // 1. 지구 체크
                    float dEarth = length(p - uEarthPos) - earthRad;
                    if(dEarth < SURF_DIST) {
                        vec3 normal = normalize(p - uEarthPos);
                        vec3 lightDir = normalize(uSunPos - uEarthPos);
                        vec3 texCol = texture(uTexEarth, getSphereUV(p, uEarthPos)).rgb;
                        float diff = max(dot(normal, lightDir), 0.05);
                        float fresnel = pow(1.0 + dot(dir, normal), 3.0);
                        vec3 atmosphere = vec3(0.1, 0.4, 1.0) * fresnel * 1.5 * diff;
                        col = texCol * diff + atmosphere; 
                        hitObj = true; break;
                    }

                    // 2. 블랙홀(사건의 지평선) 체크
                    // [수정] 질량이 0이면 이 코드는 절대 실행되지 않음 -> 팩맨 현상 해결
                    if(bhMass > 0.0 && dBH < EVENT_HORIZON) { hitBH = true; break; }

                    // 3. 태양 체크
                    float dSun = length(p - uSunPos) - sunRad;
                    if(dSun < SURF_DIST) {
                        col = texture(uTexSun, getSphereUV(p, uSunPos)).rgb;
                        col *= 4.0;
                        hitObj = true; break;
                    }

                    // 4. 태양 코로나 (빛 번짐)
                    float distToSunCenter = length(p - uSunPos);
                    float glowIntensity = 1.0 / (distToSunCenter * distToSunCenter * 0.2 + 0.1);
                    sunGlow += vec3(1.0, 0.6, 0.2) * glowIntensity * 0.02;

                    // =============================
// [추가] Gargantua-style orange ring (accretion disk-ish)
// =============================
if (bhMass > 0.0) {

    vec3 diskN = normalize(vec3(0.25, 1.0, 0.15));

    float h = dot(p - uBhPos, diskN);
    float distToPlane = abs(h);

    vec3  proj = (p - uBhPos) - diskN * h;
    float r = length(proj);

    // 디스크 반경 범위를 넓혀서 "항상 보이게" (가르강튀아 느낌)
    float rIn = 1.2;                // 안쪽 경계
    float rOut = 8.0 + 1.5*bhMass;  // 바깥 경계(질량에 따라)
    float ringBand = smoothstep(rOut, rOut-1.5, r) * smoothstep(rIn, rIn+0.6, r);

    // 평면 두께(좀 더 두껍게 -> 잘 보이게)
    float wH = 0.25;
    float planeMask = exp(-pow(distToPlane / wH, 2.0));

    // 엣지에서 더 밝게
    float edgeBoost = pow(1.0 - abs(dot(dir, diskN)), 2.2);

    // 뜨거운 색(안쪽이 더 밝고 노랗게)
    float t = clamp((r - rIn) / (rOut - rIn), 0.0, 1.0);
    vec3 hot  = vec3(1.0, 0.85, 0.35);
    vec3 warm = vec3(1.0, 0.35, 0.06);
    vec3 diskCol = mix(hot, warm, pow(t, 0.85));

    // 도플러 비밍 흉내(한쪽 밝게)
    vec3 tdir = normalize(cross(diskN, proj) + 1e-6);
    float dop = dot(tdir, dir);
    float beaming = clamp(1.0 + 1.2*dop, 0.25, 2.6);

    // 중심 가까울수록 밝기 증가(약간의 감쇠)
    float falloff = 1.0 / (0.6 + 0.12*r*r);

    float mask = ringBand * planeMask * edgeBoost * beaming;

    // ✅ col 말고 diskGlow에 누적 (hitBH에서 덮어써도 남는다)
    diskGlow += diskCol * mask * falloff * (1.8 + 0.35*bhMass);
}

                    // 5. 중력 렌즈 효과 (빛 굴절)
                    // [수정] bhMass > 0.0 조건 추가. 질량이 0이면 굴절 계산 스킵
                    if (bhMass > 0.0 && p.z > uEarthPos.z) {
                        vec3 gravDir = normalize(uBhPos - p);
                        float force = bhMass / (dBH * dBH + 0.05); 
                        dir = normalize(dir + gravDir * force * 0.2); 
                    }

                    float stepSize = max(SURF_DIST, min(dEarth, dSun));

// 2) 블랙홀이 실제로 작동할 때만(질량>0) 중심 근처에서 정밀하게 하려고 dBH 제한을 추가
if (bhMass > 0.0) {
    stepSize = min(stepSize, max(SURF_DIST, dBH * 0.05));
}

// 안전장치(너무 작아져서 스텝 한도에 걸리는 것 방지)
stepSize = max(stepSize, 0.02);

                    p += dir * stepSize;
                    totDist += stepSize;
                    if(totDist > MAX_DIST) break;
                }

                if(hitBH) col = vec3(0.0);
                else if(!hitObj) col = getBackground(dir);

                col += sunGlow + diskGlow;
                col = ACESFilm(col);
                col = pow(col, vec3(0.4545));
                
                fragColor = vec4(col, 1.0);
            }
            void main() { mainImage(gl_FragColor, gl_FragCoord.xy); }
        `;

        const geometry = new THREE.PlaneGeometry(2, 2);
        const uniforms = {
            iTime: { value: 0 },
            iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
            iMouse: { value: new THREE.Vector2(window.innerWidth / 2, window.innerHeight / 2) },
            // [수정] 카메라를 더 뒤로 뺌 (-100 -> -150)
            uZoom: { value: -150.0 },
            uBhMass: { value: 1.2 },
            uTexEarth: { value: earthTexture },
            uTexSun: { value: sunTexture },
            uBhPos: { value: bhPos },
            uEarthPos: { value: earthPos },
            uSunPos: { value: sunPos }
        };

        const material = new THREE.ShaderMaterial({
            fragmentShader: fragmentShader, uniforms: uniforms
        });
        scene.add(new THREE.Mesh(geometry, material));

        const slider = document.getElementById('mass-slider');
        const massValueDisplay = document.getElementById('mass-value');

        slider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            uniforms.uBhMass.value = val;
            massValueDisplay.textContent = val.toFixed(1);
        });

        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let initialPinchDistance = null;

        document.addEventListener('mousedown', (e) => {
            if (e.target.id === 'mass-slider') return;
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        document.addEventListener('mouseup', () => isDragging = false);
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                uniforms.iMouse.value.x += e.movementX * 2.0;
                uniforms.iMouse.value.y -= e.movementY * 2.0;
            }
        });
        document.addEventListener('wheel', (e) => {
            const zoomSpeed = 0.01;
            let newZoom = uniforms.uZoom.value - e.deltaY * zoomSpeed;
            // 줌 범위 조정
            newZoom = Math.max(-200.0, Math.min(-20.0, newZoom));
            uniforms.uZoom.value = newZoom;
        });

        document.addEventListener('touchstart', (e) => {
            if (e.target.id === 'mass-slider') return;
            if (e.touches.length === 1) {
                isDragging = true;
                previousMousePosition = { x: e.touches[0].pageX, y: e.touches[0].pageY };
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].pageX - e.touches[1].pageX;
                const dy = e.touches[0].pageY - e.touches[1].pageY;
                initialPinchDistance = Math.hypot(dx, dy);
            }
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            if (e.target.id === 'mass-slider') return;
            e.preventDefault();

            if (e.touches.length === 1 && isDragging) {
                const deltaX = e.touches[0].pageX - previousMousePosition.x;
                const deltaY = e.touches[0].pageY - previousMousePosition.y;
                uniforms.iMouse.value.x += deltaX * 2.0;
                uniforms.iMouse.value.y -= deltaY * 2.0;
                previousMousePosition = { x: e.touches[0].pageX, y: e.touches[0].pageY };
            } else if (e.touches.length === 2 && initialPinchDistance) {
                const dx = e.touches[0].pageX - e.touches[1].pageX;
                const dy = e.touches[0].pageY - e.touches[1].pageY;
                const currentDistance = Math.hypot(dx, dy);
                const diff = currentDistance - initialPinchDistance;
                const zoomSpeed = 0.05;
                let newZoom = uniforms.uZoom.value + diff * zoomSpeed;
                newZoom = Math.max(-200.0, Math.min(-20.0, newZoom));
                uniforms.uZoom.value = newZoom;
                initialPinchDistance = currentDistance;
            }
        }, { passive: false });

        document.addEventListener('touchend', () => {
            isDragging = false;
            initialPinchDistance = null;
        });

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);
        });

        function animate(time) {
            requestAnimationFrame(animate);
            uniforms.iTime.value = time * 0.001;
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>

</html>