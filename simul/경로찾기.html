<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <title>ìœ ì „ì ëª¨ë¸ ë¡œì¼“</title>
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <style>
        body {
            margin: 0;
            background-color: #222;
            color: #eee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        #top-panel {
            background: #2c3e50;
            padding: 10px 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            z-index: 20;
            flex-shrink: 0;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            border-radius: 12px;
            margin: 10px;
        }

        #info-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: flex-end;
            text-align: right;
            font-size: 0.8em;
            color: #aaa;
            z-index: 15;
            pointer-events: none;
        }

        #info-panel span {
            display: block;
        }

        #info-panel span:nth-child(2n) {
            display: none;
        }

        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9em;
            text-transform: uppercase;
            white-space: nowrap;
        }

        .btn:active {
            transform: scale(0.95);
        }

        #btn-challenge {
            background-color: #e74c3c;
            color: white;
            box-shadow: 0 4px 0 #c0392b;
        }

        #btn-challenge.running {
            background-color: #f39c12;
            box-shadow: 0 4px 0 #d35400;
        }

        #btn-clear {
            background-color: #444;
            color: #ccc;
            font-size: 0.8em;
        }

        .stat-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 50px;
        }

        .stat-label {
            font-size: 0.7em;
            color: #888;
            margin-bottom: 2px;
        }

        .badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.8em;
        }

        .mode-setup {
            background: #555;
            color: #ccc;
        }

        .mode-search {
            background: #ff4757;
            color: white;
            animation: pulse 1s infinite;
        }

        .mode-opt {
            background: #1e90ff;
            color: white;
        }

        .divider {
            width: 1px;
            height: 30px;
            background: #555;
            margin: 0 5px;
        }

        input[type=range] {
            width: 80px;
            cursor: pointer;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }

            100% {
                opacity: 1;
            }
        }

        @media (max-width: 1024px) {
            body {
                flex-direction: row;
                align-items: center;
                justify-content: center;
                background-color: #111;
            }

            #top-panel {
                width: 80px;
                height: 90vh;
                flex-direction: column;
                justify-content: flex-start;
                gap: 15px;
                overflow-y: auto;
                margin: 0 10px 0 10px;
            }

            .divider {
                width: 80%;
                height: 1px;
                margin: 5px 0;
            }

            .btn {
                width: 90%;
                font-size: 0.7em;
                padding: 12px 2px;
                white-space: normal;
                line-height: 1.2;
            }

            .stat-group {
                width: 100%;
                margin: 5px 0;
            }

            input[type=range] {
                width: 60px;
            }
        }

        canvas {
            background-color: #000;
            display: block;
            touch-action: none;
            border: 2px solid #555;
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
        }

        #loading-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: #00ff7f;
            padding: 20px 40px;
            border-radius: 8px;
            font-size: 1.5em;
            display: none;
            z-index: 100;
            white-space: nowrap;
        }

        #orientation-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            text-align: center;
        }

        #orientation-overlay h1 {
            font-size: 1.5rem;
            margin-bottom: 10px;
        }

        .rotate-icon {
            font-size: 3rem;
            margin-bottom: 20px;
            animation: rotatePhone 2s infinite;
        }

        @keyframes rotatePhone {
            0% {
                transform: rotate(0deg);
            }

            50% {
                transform: rotate(-90deg);
            }

            100% {
                transform: rotate(0deg);
            }
        }
    </style>
</head>

<body>

    <div id="orientation-overlay">
        <div class="rotate-icon">ğŸ“± â¡ï¸ ğŸ”„</div>
        <h1>ê°€ë¡œ ëª¨ë“œ ê¶Œì¥</h1>
    </div>

    <div id="loading-overlay">ë§µ ë¶„ì„ ì¤‘...</div>

    <div id="top-panel">
        <div class="stat-group">
            <span class="stat-label">MODE</span>
            <span id="mode-badge" class="badge mode-setup">SETUP</span>
        </div>
        <div class="divider"></div>
        <button id="btn-challenge" class="btn" onclick="toggleChallenge()">ğŸš€ ì‹œì‘</button>
        <button id="btn-clear" class="btn" onclick="clearObstacles()">ğŸ§¹ ì§€ìš°ê¸°</button>
        <div class="divider"></div>
        <div class="stat-group">
            <span class="stat-label">SPEED</span>
            <input type="range" id="speed-slider" min="1" max="100" value="1">
        </div>
        <div class="divider"></div>
        <div class="stat-group">
            <span class="stat-label">BRUSH</span>
            <input type="range" id="brush-slider" min="5" max="50" value="20">
        </div>
    </div>

    <div id="info-panel">
        <span>ì„¸ëŒ€: <strong id="gen-count" style="color:#fff">0</strong></span>
        <span>|</span>
        <span>ì‹œê°„: <strong id="timer-display" style="color:#fff">0</strong></span>
        <span>|</span>
        <span>ë³€ì´: <strong id="mut-rate" style="color:#ff4757">0%</strong></span>
        <span>|</span>
        <span>ìµœì´ˆ: <strong id="first-success" style="color:#2ecc71">-</strong></span>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        class Vector {
            constructor(x, y) { this.x = x; this.y = y; }
            add(v) { this.x += v.x; this.y += v.y; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; return this; }
            mult(n) { this.x *= n; this.y *= n; return this; }
            div(n) { if (n !== 0) { this.x /= n; this.y /= n; } return this; }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            normalize() { let m = this.mag(); if (m !== 0) this.mult(1 / m); return this; }
            limit(max) { if (this.mag() > max) { this.normalize(); this.mult(max); } return this; }
            copy() { return new Vector(this.x, this.y); }
            static dist(v1, v2) { return Math.sqrt((v1.x - v2.x) ** 2 + (v1.y - v2.y) ** 2); }
            static random2D() {
                let angle = Math.random() * Math.PI * 2;
                return new Vector(Math.cos(angle), Math.sin(angle));
            }
        }

        let width, height;
        const lifetime = 3000;
        const popSize = 400;
        const maxForce = 0.5;
        const maxSpeed = 6;
        let brushSize = 20;

        let planetSize = 100;
        let planetRadius = 50;
        let touchRadius = 60;

        let isChallengeRunning = false;
        let cycles = 1;
        let firstSuccessGeneration = null;
        let stagnationCounter = 0;
        let lastMaxFitness = 0;

        let spawnPoint, targetPoint;
        let population;
        let lifeCounter = 0;
        let successExists = false;

        const gridRes = 4;
        let cols, rows;
        let obstacleGrid = [];
        let distanceMap = [];

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const btnChallenge = document.getElementById('btn-challenge');
        const modeBadge = document.getElementById('mode-badge');
        const genDisplay = document.getElementById('gen-count');
        const mutRateDisplay = document.getElementById('mut-rate');
        const firstSuccessDisplay = document.getElementById('first-success');
        const loadingOverlay = document.getElementById('loading-overlay');
        const timerDisplay = document.getElementById('timer-display');
        const orientationOverlay = document.getElementById('orientation-overlay');

        let currentMutationRate = 0.02;
        let currentMutationForce = 0.1;

        const earthImg = new Image();
        const marsImg = new Image();
        let earthLoaded = false;
        let marsLoaded = false;
        let dragTarget = null;

        function calculateResponsiveValues(winW) {
            if (winW <= 1024) {
                planetSize = 60;
                planetRadius = 30;
                touchRadius = 45;
                if (!isChallengeRunning && document.getElementById('brush-slider').value == 20) {
                    brushSize = 15;
                    document.getElementById('brush-slider').value = 15;
                }
            } else {
                planetSize = 100;
                planetRadius = 50;
                touchRadius = 60;
            }
        }

        function initScreen() {
            const winW = window.innerWidth;
            const winH = window.innerHeight;

            if (winW < winH) {
                orientationOverlay.style.display = 'flex';
            } else {
                orientationOverlay.style.display = 'none';
            }

            calculateResponsiveValues(winW);

            let marginX = 20;
            let marginY = 20;

            if (winW <= 1024) {
                let sidebarWidth = 100;
                width = winW - sidebarWidth - marginX;
                height = winH - marginY;
            } else {
                width = winW - (marginX * 2);
                height = winH - 130 - marginY;
            }

            canvas.width = width;
            canvas.height = height;

            cols = Math.ceil(width / gridRes);
            rows = Math.ceil(height / gridRes);

            initObstacleGrid();

            let safePadding = planetRadius + 40;
            if (!spawnPoint) spawnPoint = new Vector(width / 2, height - safePadding);
            else {
                spawnPoint.x = Math.min(width - safePadding, Math.max(safePadding, spawnPoint.x));
                spawnPoint.y = Math.min(height - safePadding, Math.max(safePadding, spawnPoint.y));
            }

            if (!targetPoint) targetPoint = new Vector(width / 2, safePadding);
            else {
                targetPoint.x = Math.min(width - safePadding, Math.max(safePadding, targetPoint.x));
                targetPoint.y = Math.min(height - safePadding, Math.max(safePadding, targetPoint.y));
            }

            return true;
        }

        window.onload = () => {
            initScreen();
            setupInput();

            document.getElementById('speed-slider').addEventListener('input', e => cycles = parseInt(e.target.value));
            document.getElementById('brush-slider').addEventListener('input', e => brushSize = parseInt(e.target.value));

            earthImg.onload = () => { earthLoaded = true; };
            marsImg.onload = () => { marsLoaded = true; };
            earthImg.onerror = () => { };
            marsImg.onerror = () => { };

            earthImg.src = './image/earth.png';
            marsImg.src = './image/mars.png';

            requestAnimationFrame(drawLoop);
        };

        window.addEventListener('resize', () => {
            const ready = initScreen();
            if (ready && isChallengeRunning) {
                toggleChallenge();
            }
        });

        function generateDistanceMap() {
            distanceMap = new Array(cols).fill(0).map(() => new Array(rows).fill(Infinity));
            let targetX = Math.floor(targetPoint.x / gridRes);
            let targetY = Math.floor(targetPoint.y / gridRes);

            if (targetX >= cols || targetY >= rows || targetX < 0 || targetY < 0) return false;
            if (obstacleGrid[targetX][targetY]) return false;

            let queue = [[targetX, targetY]];
            distanceMap[targetX][targetY] = 0;
            let dx = [1, -1, 0, 0, 1, 1, -1, -1];
            let dy = [0, 0, 1, -1, 1, -1, 1, -1];
            let cost = [1, 1, 1, 1, 1.4, 1.4, 1.4, 1.4];

            while (queue.length > 0) {
                let [x, y] = queue.shift();
                let currentDist = distanceMap[x][y];
                for (let i = 0; i < 8; i++) {
                    let nx = x + dx[i];
                    let ny = y + dy[i];
                    if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && !obstacleGrid[nx][ny]) {
                        let newDist = currentDist + cost[i];
                        if (newDist < distanceMap[nx][ny]) {
                            distanceMap[nx][ny] = newDist;
                            queue.push([nx, ny]);
                        }
                    }
                }
            }
            let startX = Math.floor(spawnPoint.x / gridRes);
            let startY = Math.floor(spawnPoint.y / gridRes);
            if (startX >= cols || startY >= rows || startX < 0 || startY < 0) return false;
            if (distanceMap[startX][startY] === Infinity) return false;
            return true;
        }

        function toggleChallenge() {
            if (isChallengeRunning) {
                isChallengeRunning = false;
                btnChallenge.innerText = "ğŸš€ ì‹œì‘";
                btnChallenge.classList.remove('running');
                modeBadge.innerText = "SETUP";
                modeBadge.className = "badge mode-setup";
                population = null;
                lifeCounter = 0;
                successExists = false;
            } else {
                loadingOverlay.style.display = 'block';
                setTimeout(() => {
                    let success = generateDistanceMap();
                    loadingOverlay.style.display = 'none';
                    if (!success) { alert("ëª©í‘œ ì§€ì ìœ¼ë¡œ ê°€ëŠ” ê¸¸ì´ ë§‰í˜€ìˆìŠµë‹ˆë‹¤!"); return; }
                    isChallengeRunning = true;
                    btnChallenge.innerText = "â¹ ì¤‘ì§€";
                    btnChallenge.classList.add('running');
                    population = new Population();
                    lifeCounter = 0;
                    firstSuccessGeneration = null;
                    firstSuccessDisplay.innerText = "-";
                    stagnationCounter = 0;
                    lastMaxFitness = 0;
                    successExists = false;
                }, 50);
            }
        }

        function initObstacleGrid() {
            obstacleGrid = new Array(cols).fill(0).map(() => new Array(rows).fill(false));

            let wallThick = 3;

            for (let x = 0; x < cols; x++) {
                for (let y = 0; y < rows; y++) {
                    if (x < wallThick || x >= cols - wallThick || y < wallThick || y >= rows - wallThick) {
                        obstacleGrid[x][y] = true;
                    }
                }
            }
        }

        function clearObstacles() {
            if (!isChallengeRunning) initObstacleGrid();
        }

        // ========== ê°œì„ ëœ DNA í´ë˜ìŠ¤ ==========
        class DNA {
            constructor(genes) {
                if (genes) {
                    this.genes = genes;
                } else {
                    this.genes = [];
                    for (let i = 0; i < lifetime; i++) {
                        let v = Vector.random2D();
                        v.mult(Math.random() * maxForce);
                        this.genes[i] = v;
                    }
                }
            }

            copy() {
                return new DNA(this.genes.map(v => v.copy()));
            }

            mutation(startFrame, isElite = false) {
                let cutoff = startFrame || 0;

                // 1. êµ¬ê°„ ì •ì˜
                let halfLife = this.genes.length * 0.5; // ì´ˆë°˜ ë³´í˜¸ êµ¬ê°„ (50%)
                let endZone = this.genes.length * 0.8;  // í›„ë°˜ íƒìƒ‰ êµ¬ê°„ (80% ì´í›„)

                // ì—˜ë¦¬íŠ¸(ìƒìœ„ ê°œì²´)ëŠ” ê¸°ì¡´ ê²½ë¡œë¥¼ ì–´ëŠ ì •ë„ ìœ ì§€í•´ì•¼ í•˜ë¯€ë¡œ, í›„ë°˜ë¶€ ë³€ì´ìœ¨ì„ ë‚®ê²Œ ì„¤ì •
                if (isElite) {
                    for (let i = cutoff; i < this.genes.length; i++) {
                        // ì—˜ë¦¬íŠ¸ë„ ë§ˆì§€ë§‰ 20% êµ¬ê°„ì—ì„œëŠ” ì•½ê°„ì˜ íƒìƒ‰ì„ í—ˆìš© (í™•ë¥  5%)
                        if (i > endZone && Math.random() < 0.05) {
                            let nudge = Vector.random2D();
                            nudge.mult(currentMutationForce * 0.5);
                            this.genes[i].add(nudge);
                            this.genes[i].limit(maxForce);
                        }
                        // ê·¸ ì™¸ êµ¬ê°„ì€ ë§¤ìš° ë³´ìˆ˜ì 
                        else if (Math.random() < 0.01) {
                            let nudge = Vector.random2D();
                            nudge.mult(currentMutationForce * 0.2);
                            this.genes[i].add(nudge);
                            this.genes[i].limit(maxForce);
                        }
                    }
                    return;
                }

                // ì¼ë°˜ ê°œì²´ ë³€ì´
                for (let i = 0; i < this.genes.length; i++) {

                    // âœ¨ [í•µì‹¬] í›„ë°˜ë¶€ 20% êµ¬ê°„: ê³¼ê²©í•œ íƒìƒ‰ (High Exploration)
                    if (i > endZone) {
                        // 20%ì˜ ë†’ì€ í™•ë¥ ë¡œ ëŒì—°ë³€ì´ ë°œìƒ (ê¸°ì¡´ ìœ ì „ìë¥¼ ë¬´ì‹œí•˜ê³  ìƒˆë¡œìš´ ì›€ì§ì„ ì‹œë„)
                        if (Math.random() < 0.2) {
                            // ê¸°ì¡´ ë°©í–¥ì— í° í˜ì„ ë”í•¨ (ë¶€ëª¨ ê²½ë¡œ ì´íƒˆ ìœ ë„)
                            let nudge = Vector.random2D();
                            nudge.mult(maxForce); // ìµœëŒ€ í˜ìœ¼ë¡œ ë°€ì–´ë²„ë¦¼
                            this.genes[i].add(nudge);
                            this.genes[i].limit(maxForce);
                        }
                        continue; // í›„ë°˜ë¶€ ì²˜ë¦¬ë¥¼ í–ˆìœ¼ë¯€ë¡œ ì•„ë˜ ë¡œì§ ê±´ë„ˆëœ€
                    }

                    // --- ê¸°ì¡´ ë¡œì§ (ì´ˆë°˜ ~ 80% êµ¬ê°„) ---

                    // ì•ˆì •ì„± ê³„ìˆ˜: ì´ˆë°˜ 50% êµ¬ê°„ì€ ë³€ì´ í˜ì„ ì–µì œ
                    let stabilityMult = (i < halfLife) ? 0.2 : 1.0;

                    // A. ë¶€ëª¨ê°€ ê°”ë˜ ê¸¸ (Cutoff ì´ì „)
                    if (i < cutoff) {
                        if (Math.random() < 0.05) { // 5% í™•ë¥ 
                            let nudge = Vector.random2D();
                            nudge.mult(currentMutationForce * stabilityMult);
                            this.genes[i].add(nudge);
                            this.genes[i].limit(maxForce);
                        }
                    }
                    // B. ìƒˆë¡œìš´ ê¸¸ (Cutoff ì´í›„ ~ 80% ì´ì „)
                    else {
                        if (Math.random() < currentMutationRate) {
                            let nudge = Vector.random2D();
                            nudge.mult(currentMutationForce * stabilityMult);
                            this.genes[i].add(nudge);
                            this.genes[i].limit(maxForce);
                        }
                    }
                }
            }
        }// ========== ê°œì„ ëœ Rocket í´ë˜ìŠ¤ ==========
        class Rocket {
            constructor(dna, isBest = false) {
                this.pos = spawnPoint.copy();
                this.vel = new Vector(0, 0);
                this.acc = new Vector(0, 0);
                this.dna = dna || new DNA();
                this.fitness = 0;
                this.completed = false;
                this.crashed = false;
                this.finishTime = 0;
                this.isBest = isBest;
                this.recordMapDist = Infinity;
                this.frameAtBest = 0;
                this.finalMapDist = Infinity;

                // âœ¨ [ì¶”ê°€] ì´ ì´ë™ ê±°ë¦¬ë¥¼ ê¸°ë¡í•  ë³€ìˆ˜
                this.odometer = 0;
            }

            applyForce(force) {
                this.acc.add(force);
            }

            update() {
                if (this.completed || this.crashed) return;

                let d = Vector.dist(this.pos, targetPoint);
                if (d < planetRadius) {
                    this.completed = true;
                    this.pos = targetPoint.copy();
                    this.finishTime = lifeCounter;
                    this.recordMapDist = 0;
                    this.finalMapDist = 0;
                    this.frameAtBest = lifeCounter;
                }

                let gx = Math.floor(this.pos.x / gridRes);
                let gy = Math.floor(this.pos.y / gridRes);

                if (this.pos.x < 0 || this.pos.x > width || this.pos.y < 0 || this.pos.y > height ||
                    (gx >= 0 && gx < cols && gy >= 0 && gy < rows && obstacleGrid[gx][gy])) {
                    this.crashed = true;
                } else {
                    if (gx >= 0 && gx < cols && gy >= 0 && gy < rows) {
                        let currentMapDist = distanceMap[gx][gy];
                        if (currentMapDist < this.recordMapDist) {
                            this.recordMapDist = currentMapDist;
                            this.frameAtBest = lifeCounter;
                        }
                        this.finalMapDist = currentMapDist;

                        // ê°€ì´ë“œ í˜
                        let bestDir = new Vector(0, 0);
                        let minDist = currentMapDist;
                        let dx = [1, -1, 0, 0, 1, 1, -1, -1];
                        let dy = [0, 0, 1, -1, 1, -1, 1, -1];
                        for (let k = 0; k < 8; k++) {
                            let nx = gx + dx[k];
                            let ny = gy + dy[k];
                            if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && distanceMap[nx][ny] < minDist) {
                                minDist = distanceMap[nx][ny];
                                bestDir = new Vector(dx[k], dy[k]);
                            }
                        }
                        if (bestDir.mag() > 0) {
                            bestDir.normalize().mult(maxForce * 0.2);
                            this.applyForce(bestDir);
                        }
                    }
                }

                this.applyForce(this.dna.genes[lifeCounter]);

                if (!this.completed && !this.crashed) {
                    this.vel.add(this.acc);
                    this.vel.mult(0.98);
                    this.vel.limit(maxSpeed);
                    this.pos.add(this.vel);

                    // âœ¨ [ì¶”ê°€] ì´ë²ˆ í”„ë ˆì„ì— ì´ë™í•œ ê±°ë¦¬ë§Œí¼ ëˆ„ì 
                    this.odometer += this.vel.mag();

                    this.acc.mult(0);
                }
            }

            // âœ¨ ê°œì„ ëœ fitness í•¨ìˆ˜ (ì´ë™ ê±°ë¦¬ íš¨ìœ¨ì„± ë°˜ì˜)
            calcFitness() {
                if (this.recordMapDist === Infinity) {
                    this.fitness = 0;
                    return;
                }

                // 1. ê¸°ë³¸ ê±°ë¦¬ ì ìˆ˜
                let distScore = 1 / (this.recordMapDist + 1);
                this.fitness = Math.pow(distScore, 3);

                if (this.completed) {
                    // ì„±ê³µ ì‹œ: ì‹œê°„ ë³´ë„ˆìŠ¤
                    let timeBonus = (lifetime - this.finishTime) / lifetime;
                    this.fitness *= (1 + timeBonus * 10);

                    // âœ¨ [ì¶”ê°€] íš¨ìœ¨ì„±(ì´ë™ ê±°ë¦¬) ë³´ë„ˆìŠ¤
                    // ë§ì´ ì›€ì§ì˜€ì„ìˆ˜ë¡(odometerê°€ í´ìˆ˜ë¡) ë¶„ëª¨ê°€ ì»¤ì ¸ì„œ ì ìˆ˜ê°€ ë‚®ì•„ì§
                    // ì œê³±(pow 2)ì„ í•´ì„œ ì§§ì€ ê²½ë¡œë¥¼ ì•„ì£¼ ê°•ë ¥í•˜ê²Œ ì„ í˜¸í•˜ë„ë¡ ìœ ë„
                    let efficiency = 1 / (1 + this.odometer * 0.05);
                    this.fitness *= Math.pow(efficiency, 2);

                } else {
                    // ì‹¤íŒ¨ ì‹œ: ì§„í–‰ë„ì™€ ì•ˆì •ì„± í‰ê°€

                    // 2. ìµœê³ ì ì—ì„œ ì–¼ë§ˆë‚˜ ë²„í…¼ëŠ”ì§€
                    let stayTime = lifetime - this.frameAtBest;
                    let stayPenalty = 1 / (1 + stayTime / 100);
                    this.fitness *= stayPenalty;

                    // 3. í›„í‡´ í˜ë„í‹°
                    let drift = Math.max(0, this.finalMapDist - this.recordMapDist);
                    this.fitness *= (1 / (1 + drift * 0.05));

                }
            }

            show() {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                let angle = Math.atan2(this.vel.y, this.vel.x);
                ctx.rotate(angle + Math.PI / 2);
                if (this.isBest) {
                    ctx.fillStyle = "#ffff00";
                    ctx.globalAlpha = 1.0;
                    ctx.scale(1.5, 1.5);
                } else if (this.completed) {
                    ctx.fillStyle = "#00ff7f";
                    ctx.globalAlpha = 0.8;
                } else if (this.crashed) {
                    ctx.fillStyle = "#ff4757";
                    ctx.globalAlpha = 0.2;
                } else {
                    ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
                }
                ctx.beginPath();
                ctx.moveTo(0, -10);
                ctx.lineTo(-5, 5);
                ctx.lineTo(5, 5);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }
        // ========== ê°œì„ ëœ Population í´ë˜ìŠ¤ ==========
        class Population {
            constructor() {
                this.rockets = [];
                this.popSize = popSize;
                this.generation = 1;
                this.topDNAs = [];  // ìƒìœ„ DNA ì—¬ëŸ¬ ê°œ ì €ì¥
                this.mutationCutoff = 0;

                for (let i = 0; i < this.popSize; i++) {
                    this.rockets[i] = new Rocket();
                }
            }

            run() {
                let allStopped = true;
                for (let i = 0; i < this.popSize; i++) {
                    this.rockets[i].update();
                    this.rockets[i].show();
                    if (!this.rockets[i].completed && !this.rockets[i].crashed) {
                        allStopped = false;
                    }
                }
                return allStopped;
            }

            // âœ¨ ê°œì„ ëœ í‰ê°€ ë° selection ì¤€ë¹„
            evaluate() {
                // 1. fitness ê³„ì‚°
                for (let i = 0; i < this.popSize; i++) {
                    this.rockets[i].calcFitness();
                }

                // 2. fitness ê¸°ì¤€ ì •ë ¬
                let sorted = this.rockets.slice().sort((a, b) => b.fitness - a.fitness);

                // 3. ìƒìœ„ 10% ì €ì¥
                let eliteCount = Math.floor(this.popSize * 0.1);
                this.topDNAs = sorted.slice(0, eliteCount).map(r => ({
                    dna: r.dna.copy(),
                    cutoff: r.completed ? r.finishTime : r.frameAtBest
                }));

                let maxFit = sorted[0].fitness;
                let bestRocket = sorted[0];
                let successCount = this.rockets.filter(r => r.completed).length;

                this.mutationCutoff = Math.floor(
                    bestRocket.completed ? bestRocket.finishTime : bestRocket.frameAtBest
                );

                // 4. ëª¨ë“œ ë° mutation íŒŒë¼ë¯¸í„° ì¡°ì •
                if (successCount > 0) {
                    successExists = true;
                    if (firstSuccessGeneration === null) {
                        firstSuccessGeneration = this.generation;
                        firstSuccessDisplay.innerText = `${this.generation} ì„¸ëŒ€`;
                    }
                    modeBadge.innerText = "OPTIMIZING";
                    modeBadge.className = "badge mode-opt";
                    currentMutationRate = 0.01;
                    currentMutationForce = 0.05;
                } else {
                    successExists = false;
                    modeBadge.innerText = "SEARCHING";
                    modeBadge.className = "badge mode-search";

                    // stagnation ê°ì§€
                    if (Math.abs(maxFit - lastMaxFitness) < 0.00001) {
                        stagnationCounter++;
                    } else {
                        stagnationCounter = 0;
                    }
                    lastMaxFitness = maxFit;

                    // ì •ì²´ ì‹œ mutation ì¦ê°€
                    currentMutationRate = Math.min(0.02 + (stagnationCounter * 0.01), 0.4);
                    currentMutationForce = Math.min(0.1 + (stagnationCounter * 0.02), 0.5);
                }

                mutRateDisplay.innerText = (currentMutationRate * 100).toFixed(1) + "%";
            }

            // âœ¨ ê°œì„ ëœ selection: ë£°ë › íœ  + ì—˜ë¦¬íŠ¸ ë³´ì¡´
            selection() {
                let newRockets = [];
                let eliteCount = Math.floor(this.popSize * 0.05);  // ìƒìœ„ 5% ê·¸ëŒ€ë¡œ ë³µì œ

                // 1. ì—˜ë¦¬íŠ¸ ë³´ì¡´ (ì•½ê°„ì˜ ë³€ì´ë§Œ)
                for (let i = 0; i < eliteCount && i < this.topDNAs.length; i++) {
                    let dna = this.topDNAs[i].dna.copy();
                    dna.mutation(this.topDNAs[i].cutoff, true);  // ì—˜ë¦¬íŠ¸ ë³€ì´
                    newRockets.push(new Rocket(dna, i === 0));
                }

                // 2. ë£°ë › íœ ë¡œ ë‚˜ë¨¸ì§€ ì±„ìš°ê¸°
                let totalFitness = this.rockets.reduce((sum, r) => sum + r.fitness, 0);

                for (let i = eliteCount; i < this.popSize; i++) {
                    let parentDNA;

                    if (totalFitness === 0) {
                        // fitnessê°€ ëª¨ë‘ 0ì´ë©´ ëœë¤ ì„ íƒ
                        parentDNA = this.rockets[Math.floor(Math.random() * this.rockets.length)].dna.copy();
                    } else {
                        // ë£°ë › íœ  ì„ íƒ
                        let rand = Math.random() * totalFitness;
                        let sum = 0;
                        for (let j = 0; j < this.rockets.length; j++) {
                            sum += this.rockets[j].fitness;
                            if (sum >= rand) {
                                parentDNA = this.rockets[j].dna.copy();
                                break;
                            }
                        }
                    }

                    parentDNA.mutation(this.mutationCutoff, false);
                    newRockets.push(new Rocket(parentDNA));
                }

                this.rockets = newRockets;
                this.generation++;
                genDisplay.innerText = this.generation;
            }
        }

        function drawMapElements() {
            ctx.fillStyle = "#1a1a1a";
            ctx.fillRect(0, 0, width, height);

            ctx.fillStyle = "white";
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (obstacleGrid[i][j]) ctx.fillRect(i * gridRes, j * gridRes, gridRes, gridRes);
                }
            }

            if (marsLoaded) {
                ctx.drawImage(marsImg, targetPoint.x - planetRadius, targetPoint.y - planetRadius, planetSize, planetSize);
            } else {
                ctx.beginPath();
                ctx.arc(targetPoint.x, targetPoint.y, planetRadius, 0, Math.PI * 2);
                ctx.fillStyle = "#2ecc71"; ctx.fill();
            }

            if (earthLoaded) {
                ctx.drawImage(earthImg, spawnPoint.x - planetRadius, spawnPoint.y - planetRadius, planetSize, planetSize);
            } else {
                ctx.beginPath();
                ctx.rect(spawnPoint.x - planetRadius, spawnPoint.y - planetRadius, planetSize, planetSize);
                ctx.fillStyle = "#3498db"; ctx.fill();
            }
        }

        function drawLoop() {
            drawMapElements();
            if (isChallengeRunning && population) {
                for (let n = 0; n < cycles; n++) {
                    let allStopped = population.run();
                    lifeCounter++;
                    timerDisplay.innerText = lifeCounter;
                    if (allStopped || lifeCounter >= lifetime) {
                        population.evaluate();
                        population.selection();
                        lifeCounter = 0;
                        break;
                    }
                }
            }
            requestAnimationFrame(drawLoop);
        }

        function setupInput() {
            canvas.addEventListener('mousedown', (e) => {
                const { x, y } = getPos(e);
                handleStart(x, y);
            });
            canvas.addEventListener('mousemove', (e) => {
                const { x, y } = getPos(e);
                handleMove(x, y);
            });
            window.addEventListener('mouseup', handleEnd);

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const { x, y } = getPos(e.touches[0]);
                handleStart(x, y);
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const { x, y } = getPos(e.touches[0]);
                handleMove(x, y);
            }, { passive: false });

            window.addEventListener('touchend', handleEnd);
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        function handleStart(x, y) {
            if (isChallengeRunning) return;
            if (Vector.dist(new Vector(x, y), spawnPoint) < touchRadius) {
                dragTarget = 'earth';
                return;
            }
            if (Vector.dist(new Vector(x, y), targetPoint) < touchRadius) {
                dragTarget = 'mars';
                return;
            }
            dragTarget = 'wall';
            addObstacle(x, y);
        }

        function handleMove(x, y) {
            if (!dragTarget) return;
            if (dragTarget === 'earth') {
                spawnPoint.x = Math.max(planetRadius, Math.min(width - planetRadius, x));
                spawnPoint.y = Math.max(planetRadius, Math.min(height - planetRadius, y));
            } else if (dragTarget === 'mars') {
                targetPoint.x = Math.max(planetRadius, Math.min(width - planetRadius, x));
                targetPoint.y = Math.max(planetRadius, Math.min(height - planetRadius, y));
            } else if (dragTarget === 'wall') {
                addObstacle(x, y);
            }
        }

        function handleEnd() { dragTarget = null; }

        function addObstacle(x, y) {
            let radius = brushSize / 2;
            let minGridX = Math.max(0, Math.floor((x - radius) / gridRes));
            let maxGridX = Math.min(cols - 1, Math.floor((x + radius) / gridRes));
            let minGridY = Math.max(0, Math.floor((y - radius) / gridRes));
            let maxGridY = Math.min(rows - 1, Math.floor((y + radius) / gridRes));
            for (let i = minGridX; i <= maxGridX; i++) {
                for (let j = minGridY; j <= maxGridY; j++) {
                    let cx = i * gridRes + gridRes / 2;
                    let cy = j * gridRes + gridRes / 2;
                    if (Math.sqrt((cx - x) ** 2 + (cy - y) ** 2) < radius) obstacleGrid[i][j] = true;
                }
            }
        }
    </script>
</body>

</html>