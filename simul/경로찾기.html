<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Smart Rockets - Mobile Responsive</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            background-color: #1a1a1a;
            color: #eee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        /* --- ìƒë‹¨ íŒ¨ë„ ìŠ¤íƒ€ì¼ --- */
        #top-panel {
            margin-top: 10px;
            display: flex;
            gap: 15px;
            align-items: center;
            background: #2c3e50;
            padding: 10px 25px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            z-index: 10;
            flex-shrink: 0;
            transition: all 0.3s ease;
        }

        #info-panel {
            margin-top: 5px;
            display: flex;
            gap: 20px;
            font-size: 0.9em;
            color: #aaa;
            flex-shrink: 0;
            margin-bottom: 5px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1em;
            transition: transform 0.1s;
            text-transform: uppercase;
        }
        .btn:active { transform: scale(0.95); }

        #btn-challenge { background-color: #e74c3c; color: white; box-shadow: 0 4px 0 #c0392b; }
        #btn-challenge.running { background-color: #f39c12; box-shadow: 0 4px 0 #d35400; }
        #btn-clear { background-color: #444; color: #ccc; font-size: 0.8em; padding: 8px 12px; }

        .stat-group { display: flex; flex-direction: column; align-items: center; min-width: 60px; }
        .stat-label { font-size: 0.7em; color: #888; margin-bottom: 2px; }
        .badge { padding: 4px 8px; border-radius: 4px; font-weight: bold; font-size: 0.8em; }
        .mode-setup { background: #555; color: #ccc; }
        .mode-search { background: #ff4757; color: white; animation: pulse 1s infinite; }
        .mode-opt { background: #1e90ff; color: white; }
        .divider { width: 1px; height: 35px; background: #555; margin: 0 5px; }
        input[type=range] { width: 100px; cursor: pointer; }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }

        /* --- ëª¨ë°”ì¼ ëŒ€ì‘ (í™”ë©´ í­ 768px ì´í•˜) --- */
        @media (max-width: 768px) {
            #top-panel {
                padding: 8px 10px; /* íŒ¨ë”© ì¶•ì†Œ */
                gap: 8px; /* ê°„ê²© ì¶•ì†Œ */
                width: 95%; /* í™”ë©´ ê½‰ ì°¨ê²Œ */
                justify-content: space-around;
                margin-top: 5px;
            }
            .btn {
                padding: 6px 12px; /* ë²„íŠ¼ í¬ê¸° ì¶•ì†Œ */
                font-size: 0.8em;
            }
            #btn-challenge {
                padding: 6px 15px;
            }
            .stat-group { min-width: 40px; }
            .stat-label { font-size: 0.6em; }
            input[type=range] { width: 60px; } /* ìŠ¬ë¼ì´ë” ê¸¸ì´ ì¶•ì†Œ */
            .divider { height: 25px; margin: 0 2px; }
            
            #info-panel {
                font-size: 0.75em; /* ì •ë³´ í…ìŠ¤íŠ¸ ì¶•ì†Œ */
                gap: 10px;
            }
        }

        canvas {
            background-color: #000;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);
            border: 2px solid #444;
            cursor: pointer;
            display: block;
            touch-action: none; 
        }

        /* ë¡œë”© & ê°€ë¡œëª¨ë“œ ì•ˆë‚´ */
        #loading-overlay {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: #00ff7f;
            padding: 20px 40px; border-radius: 8px;
            font-size: 1.5em; display: none; z-index: 100;
            white-space: nowrap;
        }
        #orientation-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #1a1a1a; color: white; display: none;
            flex-direction: column; justify-content: center; align-items: center;
            z-index: 9999; text-align: center;
        }
        #orientation-overlay h1 { font-size: 2rem; margin-bottom: 10px; }
        .rotate-icon { font-size: 3rem; margin-bottom: 20px; animation: rotatePhone 2s infinite; }
        @keyframes rotatePhone {
            0% { transform: rotate(0deg); } 50% { transform: rotate(-90deg); } 100% { transform: rotate(0deg); }
        }
    </style>
</head>
<body>

    <div id="orientation-overlay">
        <div class="rotate-icon">ğŸ“± â¡ï¸ ğŸ”„</div>
        <h1>í™”ë©´ì„ ê°€ë¡œë¡œ ëŒë ¤ì£¼ì„¸ìš”</h1>
    </div>

    <div id="loading-overlay">ë§µ ë¶„ì„ ì¤‘...</div>

    <div id="top-panel">
        <div class="stat-group">
            <span class="stat-label">MODE</span>
            <span id="mode-badge" class="badge mode-setup">SETUP</span>
        </div>
        <div class="divider"></div>
        <button id="btn-challenge" class="btn" onclick="toggleChallenge()">ğŸš€ ì‹œì‘</button>
        <button id="btn-clear" class="btn" onclick="clearObstacles()">ğŸ§¹ ë²½ ì§€ìš°ê¸°</button>
        <div class="divider"></div>
        <div class="stat-group">
            <span class="stat-label">SPEED</span>
            <input type="range" id="speed-slider" min="1" max="100" value="1">
        </div>
        <div class="divider"></div>
        <div class="stat-group">
            <span class="stat-label">BRUSH</span>
            <input type="range" id="brush-slider" min="5" max="50" value="20">
        </div>
    </div>

    <div id="info-panel">
        <span>ì„¸ëŒ€: <strong id="gen-count" style="color:#fff">0</strong></span>
        <span>|</span>
        <span>ì‹œê°„: <strong id="timer-display" style="color:#fff">0</strong></span>
        <span>|</span>
        <span>ë³€ì´: <strong id="mut-rate" style="color:#ff4757">0%</strong></span>
        <span>|</span>
        <span>ìµœì´ˆ: <strong id="first-success" style="color:#2ecc71">-</strong></span>
    </div>

    <canvas id="canvas"></canvas>

<script>
class Vector {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { this.x += v.x; this.y += v.y; return this; }
    sub(v) { this.x -= v.x; this.y -= v.y; return this; }
    mult(n) { this.x *= n; this.y *= n; return this; }
    div(n) { if(n!==0) { this.x /= n; this.y /= n; } return this; }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() { let m = this.mag(); if (m !== 0) this.mult(1 / m); return this; }
    limit(max) { if (this.mag() > max) { this.normalize(); this.mult(max); } return this; }
    copy() { return new Vector(this.x, this.y); }
    static dist(v1, v2) { return Math.sqrt((v1.x - v2.x) ** 2 + (v1.y - v2.y) ** 2); }
    static random2D() {
        let angle = Math.random() * Math.PI * 2;
        return new Vector(Math.cos(angle), Math.sin(angle));
    }
}

// --- ì „ì—­ ë³€ìˆ˜ ---
let width, height;
const lifetime = 3000; 
const popSize = 400; 
const maxForce = 0.5; 
const maxSpeed = 6;
let brushSize = 20; 

// [ë³€ê²½] ë°˜ì‘í˜• í¬ê¸° ë³€ìˆ˜
let planetSize = 100;   // í–‰ì„± ì´ë¯¸ì§€ í¬ê¸°
let planetRadius = 50;  // í–‰ì„± ë°˜ì§€ë¦„ (íŒì •ìš©)
let touchRadius = 60;   // í„°ì¹˜/ë“œë˜ê·¸ ê°ì§€ ë²”ìœ„

let isChallengeRunning = false;
let cycles = 1;
let firstSuccessGeneration = null;
let stagnationCounter = 0;
let lastMaxFitness = 0;

let spawnPoint, targetPoint;
let population;
let lifeCounter = 0;

const gridRes = 4;
let cols, rows;
let obstacleGrid = [];
let distanceMap = [];

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const btnChallenge = document.getElementById('btn-challenge');
const modeBadge = document.getElementById('mode-badge');
const genDisplay = document.getElementById('gen-count');
const mutRateDisplay = document.getElementById('mut-rate');
const firstSuccessDisplay = document.getElementById('first-success');
const loadingOverlay = document.getElementById('loading-overlay');
const timerDisplay = document.getElementById('timer-display');
const orientationOverlay = document.getElementById('orientation-overlay');

let currentMutationRate = 0.01;
let currentMutationForce = 0.05;

const earthImg = new Image();
const marsImg = new Image();
let imagesLoaded = 0;
let dragTarget = null; 

// [ì¶”ê°€] ë°˜ì‘í˜• ìˆ˜ì¹˜ ê³„ì‚° í•¨ìˆ˜
function calculateResponsiveValues(winW) {
    if (winW <= 768) {
        // ëª¨ë°”ì¼ ëª¨ë“œ
        planetSize = 60;       // í–‰ì„± í¬ê¸° ì¤„ì„ (100 -> 60)
        planetRadius = 30;     // ë°˜ì§€ë¦„ (50 -> 30)
        touchRadius = 45;      // í„°ì¹˜ íŒì • ë²”ìœ„ ì¤„ì„
        // ëª¨ë°”ì¼ì—ì„œëŠ” ë¸ŒëŸ¬ì‹œ ê¸°ë³¸ê°’ë„ ì¢€ ì‘ê²Œ
        if(!isChallengeRunning && document.getElementById('brush-slider').value == 20) {
             brushSize = 15;
             document.getElementById('brush-slider').value = 15;
        }
    } else {
        // ë°ìŠ¤í¬í†± ëª¨ë“œ
        planetSize = 100;
        planetRadius = 50;
        touchRadius = 60;
    }
}

function initScreen() {
    const winW = window.innerWidth;
    const winH = window.innerHeight;

    if (winW < 900 && winW < winH) {
        orientationOverlay.style.display = 'flex';
        return false; 
    } else {
        orientationOverlay.style.display = 'none';
    }

    calculateResponsiveValues(winW); // [í˜¸ì¶œ] í¬ê¸° ê³„ì‚°

    // ìƒë‹¨ íŒ¨ë„(ì•½ 60px~80px) + ì •ë³´íŒ¨ë„(30px) ê³ ë ¤
    let topMargin = (winW <= 768) ? 100 : 130;

    width = winW - 20;
    height = winH - topMargin; 
    canvas.width = width;
    canvas.height = height;
    
    cols = Math.ceil(width / gridRes);
    rows = Math.ceil(height / gridRes);

    if (!obstacleGrid || obstacleGrid.length !== cols || obstacleGrid[0].length !== rows) {
        initObstacleGrid();
    }

    // ì´ˆê¸° ìœ„ì¹˜ ì„¤ì • (í™”ë©´ ë¹„ìœ¨ì— ë§ì¶¤)
    if (!spawnPoint) spawnPoint = new Vector(width / 2, height - (planetRadius + 30));
    else { 
        spawnPoint.x = Math.min(width - planetRadius, Math.max(planetRadius, spawnPoint.x));
        spawnPoint.y = Math.min(height - planetRadius, Math.max(planetRadius, spawnPoint.y));
    }
    
    if (!targetPoint) targetPoint = new Vector(width / 2, planetRadius + 30);
    else {
        targetPoint.x = Math.min(width - planetRadius, Math.max(planetRadius, targetPoint.x));
        targetPoint.y = Math.min(height - planetRadius, Math.max(planetRadius, targetPoint.y));
    }

    return true;
}

window.onload = () => {
    initScreen();
    setupInput();

    document.getElementById('speed-slider').addEventListener('input', e => cycles = parseInt(e.target.value));
    document.getElementById('brush-slider').addEventListener('input', e => brushSize = parseInt(e.target.value));

    const onImgLoad = () => { 
        imagesLoaded++; 
        if(imagesLoaded===2) requestAnimationFrame(drawLoop); 
    };
    earthImg.onload = onImgLoad;
    marsImg.onload = onImgLoad;
    earthImg.src = './image/earth.png'; 
    marsImg.src = './image/mars.png';  
    setTimeout(() => { if(imagesLoaded < 2) requestAnimationFrame(drawLoop); }, 500);
};

window.addEventListener('resize', () => {
    const ready = initScreen();
    if (ready && isChallengeRunning) {
        toggleChallenge(); 
        alert("í™”ë©´ í¬ê¸°ê°€ ë³€ê²½ë˜ì–´ ì´ˆê¸°í™”í–ˆìŠµë‹ˆë‹¤.");
    }
});

function generateDistanceMap() {
    distanceMap = new Array(cols).fill(0).map(() => new Array(rows).fill(Infinity));
    let targetX = Math.floor(targetPoint.x / gridRes);
    let targetY = Math.floor(targetPoint.y / gridRes);
    
    if (targetX >= cols || targetY >= rows || targetX < 0 || targetY < 0) return false;
    if (obstacleGrid[targetX][targetY]) return false;

    let queue = [[targetX, targetY]];
    distanceMap[targetX][targetY] = 0;
    let dx = [1, -1, 0, 0, 1, 1, -1, -1];
    let dy = [0, 0, 1, -1, 1, -1, 1, -1];
    let cost = [1, 1, 1, 1, 1.4, 1.4, 1.4, 1.4]; 

    while (queue.length > 0) {
        let [x, y] = queue.shift();
        let currentDist = distanceMap[x][y];
        for (let i = 0; i < 8; i++) {
            let nx = x + dx[i];
            let ny = y + dy[i];
            if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && !obstacleGrid[nx][ny]) {
                let newDist = currentDist + cost[i];
                if (newDist < distanceMap[nx][ny]) {
                    distanceMap[nx][ny] = newDist;
                    queue.push([nx, ny]);
                }
            }
        }
    }
    let startX = Math.floor(spawnPoint.x / gridRes);
    let startY = Math.floor(spawnPoint.y / gridRes);
    if (startX >= cols || startY >= rows || startX < 0 || startY < 0) return false;
    if (distanceMap[startX][startY] === Infinity) return false;
    return true;
}

function toggleChallenge() {
    if (isChallengeRunning) {
        isChallengeRunning = false;
        btnChallenge.innerText = "ğŸš€ ì‹œì‘";
        btnChallenge.classList.remove('running');
        modeBadge.innerText = "SETUP";
        modeBadge.className = "badge mode-setup";
        population = null;
        lifeCounter = 0;
    } else {
        loadingOverlay.style.display = 'block';
        setTimeout(() => {
            let success = generateDistanceMap();
            loadingOverlay.style.display = 'none';
            if (!success) { alert("ëª©í‘œ ì§€ì ìœ¼ë¡œ ê°€ëŠ” ê¸¸ì´ ë§‰í˜€ìˆìŠµë‹ˆë‹¤!"); return; }
            isChallengeRunning = true;
            btnChallenge.innerText = "â¹ ì¤‘ì§€";
            btnChallenge.classList.add('running');
            population = new Population();
            lifeCounter = 0;
            firstSuccessGeneration = null;
            firstSuccessDisplay.innerText = "-";
            stagnationCounter = 0;
            lastMaxFitness = 0;
        }, 50);
    }
}

function initObstacleGrid() {
    obstacleGrid = new Array(cols).fill(0).map(() => new Array(rows).fill(false));
}
function clearObstacles() {
    if (!isChallengeRunning) initObstacleGrid();
}

class DNA {
    constructor(genes) {
        if (genes) this.genes = genes;
        else {
            this.genes = [];
            for (let i = 0; i < lifetime; i++) {
                let v = Vector.random2D();
                v.mult(Math.random() * maxForce);
                this.genes[i] = v;
            }
        }
    }
    copy() { return new DNA(this.genes.map(v => v.copy())); }
    mutation(startFrame) {
        let cutoff = startFrame || 0;
        for (let i = 0; i < this.genes.length; i++) {
            if (i < cutoff) {
                if (i > 0 && i < this.genes.length - 1 && Math.random() < 0.1) { 
                    let smoothed = this.genes[i-1].copy().add(this.genes[i]).add(this.genes[i+1]).div(3).limit(maxForce);
                    this.genes[i] = smoothed;
                }
                if (Math.random() < 0.01) { 
                    this.genes[i].add(Vector.random2D().mult(currentMutationForce * 0.5)).limit(maxForce);
                }
            } else {
                if (Math.random() < currentMutationRate) {
                    this.genes[i].add(Vector.random2D().mult(currentMutationForce)).limit(maxForce);
                }
            }
        }
    }
}

class Rocket {
    constructor(dna, isBest = false) {
        this.pos = spawnPoint.copy();
        this.vel = new Vector(0, 0);
        this.acc = new Vector(0, 0);
        this.dna = dna || new DNA();
        this.fitness = 0;
        this.completed = false;
        this.crashed = false;
        this.finishTime = 0;
        this.isBest = isBest;
        this.recordMapDist = Infinity; 
        this.frameAtBest = 0;
        this.finalMapDist = Infinity; 
    }
    applyForce(force) { this.acc.add(force); }
    update() {
        if (this.completed || this.crashed) return;

        // [ë³€ê²½] íŒì • ë²”ìœ„ ë™ì  ì ìš© (í–‰ì„± ë°˜ì§€ë¦„ í¬ê¸°)
        let d = Vector.dist(this.pos, targetPoint);
        if (d < planetRadius) { 
            this.completed = true;
            this.pos = targetPoint.copy();
            this.finishTime = lifeCounter;
            this.recordMapDist = 0; 
            this.finalMapDist = 0;
            this.frameAtBest = lifeCounter;
        }

        let gx = Math.floor(this.pos.x / gridRes);
        let gy = Math.floor(this.pos.y / gridRes);
        
        if (this.pos.x < 0 || this.pos.x > width || this.pos.y < 0 || this.pos.y > height || 
           (gx >= 0 && gx < cols && gy >= 0 && gy < rows && obstacleGrid[gx][gy])) {
            this.crashed = true;
        } else {
            if (gx >= 0 && gx < cols && gy >= 0 && gy < rows) {
                let currentMapDist = distanceMap[gx][gy];
                if (currentMapDist < this.recordMapDist) {
                    this.recordMapDist = currentMapDist;
                    this.frameAtBest = lifeCounter; 
                }
                this.finalMapDist = currentMapDist;
                
                // Flow Field Guidance
                let bestDir = new Vector(0,0);
                let minDist = currentMapDist;
                let dx = [1, -1, 0, 0, 1, 1, -1, -1]; 
                let dy = [0, 0, 1, -1, 1, -1, 1, -1];
                for(let k=0; k<8; k++) {
                    let nx = gx + dx[k];
                    let ny = gy + dy[k];
                    if(nx >= 0 && nx < cols && ny >= 0 && ny < rows && distanceMap[nx][ny] < minDist) {
                        minDist = distanceMap[nx][ny];
                        bestDir = new Vector(dx[k], dy[k]);
                    }
                }
                if(bestDir.mag() > 0) {
                    bestDir.normalize().mult(maxForce * 0.3); 
                    this.applyForce(bestDir);
                }
            }
        }
        this.applyForce(this.dna.genes[lifeCounter]);

        if (!this.completed && !this.crashed) {
            this.vel.add(this.acc);
            this.vel.mult(0.98); 
            this.vel.limit(maxSpeed); 
            this.pos.add(this.vel);
            this.acc.mult(0);
        }
    }
    calcFitness() {
        if (this.recordMapDist === Infinity) { this.fitness = 0; return; }
        let peakScore = 1 / (this.recordMapDist + 1);
        this.fitness = Math.pow(peakScore, 4); 
        let drift = Math.max(0, this.finalMapDist - this.recordMapDist);
        this.fitness *= (1 / (1 + drift * 0.1)); 
        this.fitness *= Math.pow((1 + (lifetime - this.frameAtBest) / 500), 2);
        if (this.completed) {
            this.fitness *= 10; 
            this.fitness *= (1 + (lifetime - this.finishTime) / 20); 
        }
        if (this.crashed) this.fitness *= 0.5; 
    }
    show() {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        let angle = Math.atan2(this.vel.y, this.vel.x);
        ctx.rotate(angle + Math.PI / 2);
        if (this.isBest) {
            ctx.fillStyle = "#ffff00"; ctx.globalAlpha = 1.0; ctx.scale(1.5, 1.5);
        } else if (this.completed) {
            ctx.fillStyle = "#00ff7f"; ctx.globalAlpha = 0.8;
        } else if (this.crashed) {
            ctx.fillStyle = "#ff4757"; ctx.globalAlpha = 0.2;
        } else {
            ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
        }
        ctx.beginPath();
        ctx.moveTo(0, -10); ctx.lineTo(-5, 5); ctx.lineTo(5, 5);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
}

class Population {
    constructor() {
        this.rockets = [];
        this.popSize = popSize;
        this.generation = 1;
        this.bestRocketDNA = null;
        this.mutationCutoff = 0; 
        for (let i = 0; i < this.popSize; i++) this.rockets[i] = new Rocket();
    }
    run() {
        let allStopped = true;
        for (let i = 0; i < this.popSize; i++) {
            this.rockets[i].update();
            this.rockets[i].show();
            if (!this.rockets[i].completed && !this.rockets[i].crashed) allStopped = false;
        }
        return allStopped;
    }
    evaluate() {
        let maxFit = 0;
        let bestIdx = 0;
        let successCount = 0;
        for (let i = 0; i < this.popSize; i++) {
            this.rockets[i].calcFitness();
            if (this.rockets[i].fitness > maxFit) { maxFit = this.rockets[i].fitness; bestIdx = i; }
            if (this.rockets[i].completed) successCount++;
        }
        this.bestRocketDNA = this.rockets[bestIdx].dna.copy();
        let bestRocket = this.rockets[bestIdx];
        let usefulLife = bestRocket.completed ? bestRocket.finishTime : bestRocket.frameAtBest;
        this.mutationCutoff = Math.floor(usefulLife * 0.8);

        if (successCount > 0) {
            if (firstSuccessGeneration === null) {
                firstSuccessGeneration = this.generation;
                firstSuccessDisplay.innerText = `${this.generation} ì„¸ëŒ€`;
            }
            modeBadge.innerText = "OPTIMIZING";
            modeBadge.className = "badge mode-opt";
            let successRatio = successCount / this.popSize; 
            currentMutationRate = 0.01 + (1 - successRatio) * 0.04; 
        } else {
            modeBadge.innerText = "SEARCHING";
            modeBadge.className = "badge mode-search";
            if (Math.abs(maxFit - lastMaxFitness) < 0.00000001) stagnationCounter++;
            else stagnationCounter = 0; 
            lastMaxFitness = maxFit;
            currentMutationRate = Math.min(0.05 + (stagnationCounter * 0.005), 0.3);
            currentMutationForce = Math.min(0.1 + (stagnationCounter * 0.01), 0.4);
        }
        mutRateDisplay.innerText = (currentMutationRate * 100).toFixed(1) + "%";
    }
    selection() {
        let newRockets = [];
        newRockets[0] = new Rocket(this.bestRocketDNA.copy(), true);
        for (let i = 1; i < this.popSize; i++) {
            let childDNA = this.bestRocketDNA.copy();
            childDNA.mutation(this.mutationCutoff);
            newRockets[i] = new Rocket(childDNA);
        }
        this.rockets = newRockets;
        this.generation++;
        genDisplay.innerText = this.generation;
    }
}

function drawMapElements() {
    ctx.fillStyle = "#1a1a1a";
    ctx.fillRect(0, 0, width, height);

    ctx.fillStyle = "white";
    for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
            if (obstacleGrid[i][j]) ctx.fillRect(i * gridRes, j * gridRes, gridRes, gridRes);
        }
    }

    // [ë³€ê²½] ë™ì  í¬ê¸° ì ìš©
    if (marsImg.complete && marsImg.naturalWidth !== 0) {
        ctx.drawImage(marsImg, targetPoint.x - planetRadius, targetPoint.y - planetRadius, planetSize, planetSize);
    } else {
        ctx.beginPath();
        ctx.arc(targetPoint.x, targetPoint.y, planetRadius, 0, Math.PI*2);
        ctx.fillStyle = "#2ecc71"; ctx.fill();
    }

    if (earthImg.complete && earthImg.naturalWidth !== 0) {
        ctx.drawImage(earthImg, spawnPoint.x - planetRadius, spawnPoint.y - planetRadius, planetSize, planetSize);
    } else {
        ctx.beginPath();
        ctx.rect(spawnPoint.x - planetRadius, spawnPoint.y - planetRadius, planetSize, planetSize);
        ctx.fillStyle = "#3498db"; ctx.fill();
    }
}

function drawLoop() {
    if (orientationOverlay.style.display === 'flex') {
        requestAnimationFrame(drawLoop);
        return;
    }
    drawMapElements();
    if (isChallengeRunning && population) {
        for (let n = 0; n < cycles; n++) {
            let allStopped = population.run();
            lifeCounter++;
            timerDisplay.innerText = lifeCounter; 
            if (allStopped || lifeCounter >= lifetime) {
                population.evaluate();
                population.selection();
                lifeCounter = 0;
                break;
            }
        }
    }
    requestAnimationFrame(drawLoop);
}

// --- ì…ë ¥ ì²˜ë¦¬ ---
function setupInput() {
    canvas.addEventListener('mousedown', (e) => {
        const {x, y} = getPos(e);
        handleStart(x, y);
    });
    canvas.addEventListener('mousemove', (e) => {
        const {x, y} = getPos(e);
        handleMove(x, y);
    });
    window.addEventListener('mouseup', handleEnd);

    canvas.addEventListener('touchstart', (e) => { 
        e.preventDefault(); 
        const {x, y} = getPos(e.touches[0]);
        handleStart(x, y);
    }, {passive: false});
    
    canvas.addEventListener('touchmove', (e) => { 
        e.preventDefault(); 
        const {x, y} = getPos(e.touches[0]);
        handleMove(x, y);
    }, {passive: false});

    window.addEventListener('touchend', handleEnd);
}

function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
}

function handleStart(x, y) {
    if (isChallengeRunning) return;
    // [ë³€ê²½] touchRadiusë¥¼ ì‚¬ìš©í•˜ì—¬ ë°˜ì‘í˜• í„°ì¹˜ ë²”ìœ„ ì ìš©
    if (Vector.dist(new Vector(x, y), spawnPoint) < touchRadius) {
        dragTarget = 'earth';
        return;
    }
    if (Vector.dist(new Vector(x, y), targetPoint) < touchRadius) {
        dragTarget = 'mars';
        return;
    }
    dragTarget = 'wall';
    addObstacle(x, y);
}

function handleMove(x, y) {
    if (!dragTarget) return;
    if (dragTarget === 'earth') {
        spawnPoint.x = Math.max(planetRadius, Math.min(width - planetRadius, x));
        spawnPoint.y = Math.max(planetRadius, Math.min(height - planetRadius, y));
    } else if (dragTarget === 'mars') {
        targetPoint.x = Math.max(planetRadius, Math.min(width - planetRadius, x));
        targetPoint.y = Math.max(planetRadius, Math.min(height - planetRadius, y));
    } else if (dragTarget === 'wall') {
        addObstacle(x, y);
    }
}

function handleEnd() { dragTarget = null; }

function addObstacle(x, y) {
    let radius = brushSize / 2; 
    let minGridX = Math.max(0, Math.floor((x - radius) / gridRes));
    let maxGridX = Math.min(cols - 1, Math.floor((x + radius) / gridRes));
    let minGridY = Math.max(0, Math.floor((y - radius) / gridRes));
    let maxGridY = Math.min(rows - 1, Math.floor((y + radius) / gridRes));
    for (let i = minGridX; i <= maxGridX; i++) {
        for (let j = minGridY; j <= maxGridY; j++) {
            let cx = i * gridRes + gridRes / 2;
            let cy = j * gridRes + gridRes / 2;
            if (Math.sqrt((cx - x) ** 2 + (cy - y) ** 2) < radius) obstacleGrid[i][j] = true;
        }
    }
}
</script>
</body>
</html>