<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Smart Rockets - Touch & Drag</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            background-color: #1a1a1a;
            color: #eee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            /* ëª¨ë°”ì¼ì—ì„œ ê¸¸ê²Œ ëˆŒë €ì„ ë•Œ í…ìŠ¤íŠ¸ ì„ íƒ/ë©”ë‰´ ë°©ì§€ */
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        #top-panel {
            margin-top: 10px;
            display: flex;
            gap: 15px;
            align-items: center;
            background: #2c3e50;
            padding: 10px 25px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            z-index: 10;
            flex-shrink: 0;
            transition: all 0.3s ease;
        }

        #info-panel {
            margin-top: 5px;
            display: flex;
            gap: 20px;
            font-size: 0.9em;
            color: #aaa;
            flex-shrink: 0;
            margin-bottom: 5px;
        }

        canvas {
            background-color: #000;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);
            border: 2px solid #444;
            cursor: pointer;
            display: block;
            /* í„°ì¹˜ ì‹œ ìŠ¤í¬ë¡¤/ì¤Œ ë°©ì§€ (ì¤‘ìš”) */
            touch-action: none; 
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1em;
            transition: transform 0.1s;
            text-transform: uppercase;
        }
        .btn:active { transform: scale(0.95); }
        
        #btn-challenge { 
            background-color: #e74c3c; 
            color: white; 
            padding: 10px 30px;
            box-shadow: 0 4px 0 #c0392b;
        }
        #btn-challenge.running {
            background-color: #f39c12;
            box-shadow: 0 4px 0 #d35400;
        }
        
        #btn-clear {
            background-color: #444; 
            color: #ccc;
            font-size: 0.8em;
            padding: 8px 12px;
        }

        /* ë¡œë”© ì˜¤ë²„ë ˆì´ */
        #loading-overlay {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: #00ff7f;
            padding: 20px 40px;
            border-radius: 8px;
            font-size: 1.5em;
            display: none;
            z-index: 100;
            white-space: nowrap;
        }

        /* ê°€ë¡œ ëª¨ë“œ ìœ ë„ ì˜¤ë²„ë ˆì´ */
        #orientation-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #1a1a1a;
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            text-align: center;
        }
        #orientation-overlay h1 { font-size: 2rem; margin-bottom: 10px; }
        #orientation-overlay p { font-size: 1.2rem; color: #aaa; }
        .rotate-icon { font-size: 3rem; margin-bottom: 20px; animation: rotatePhone 2s infinite; }
        
        @keyframes rotatePhone {
            0% { transform: rotate(0deg); }
            50% { transform: rotate(-90deg); }
            100% { transform: rotate(0deg); }
        }

        .stat-group { display: flex; flex-direction: column; align-items: center; min-width: 60px; }
        .stat-val { font-weight: bold; font-size: 1.1em; color: #fff; }
        .stat-label { font-size: 0.7em; color: #888; margin-bottom: 2px; }

        .badge { padding: 4px 8px; border-radius: 4px; font-weight: bold; font-size: 0.8em; }
        .mode-setup { background: #555; color: #ccc; }
        .mode-search { background: #ff4757; color: white; animation: pulse 1s infinite; }
        .mode-opt { background: #1e90ff; color: white; }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }
        input[type=range] { width: 100px; cursor: pointer; }
        .divider { width: 1px; height: 35px; background: #555; margin: 0 5px; }
    </style>
</head>
<body>

    <div id="orientation-overlay">
        <div class="rotate-icon">ğŸ“± â¡ï¸ ğŸ”„</div>
        <h1>í™”ë©´ì„ ê°€ë¡œë¡œ ëŒë ¤ì£¼ì„¸ìš”</h1>
        <p>ì›í™œí•œ ì‹œë®¬ë ˆì´ì…˜ì„ ìœ„í•´ ê°€ë¡œ ëª¨ë“œê°€ í•„ìš”í•©ë‹ˆë‹¤.</p>
    </div>

    <div id="loading-overlay">ë§µ ë¶„ì„ ì¤‘... (Flow Field ìƒì„±)</div>

    <div id="top-panel">
        <div class="stat-group">
            <span class="stat-label">MODE</span>
            <span id="mode-badge" class="badge mode-setup">SETUP</span>
        </div>

        <div class="divider"></div>

        <button id="btn-challenge" class="btn" onclick="toggleChallenge()">ğŸš€ ë„ì „ ì‹œì‘</button>
        <button id="btn-clear" class="btn" onclick="clearObstacles()">ğŸ§¹ ë²½ ì§€ìš°ê¸°</button>

        <div class="divider"></div>

        <div class="stat-group">
            <span class="stat-label">SPEED</span>
            <input type="range" id="speed-slider" min="1" max="100" value="1">
        </div>
        
        <div class="divider"></div>

        <div class="stat-group">
            <span class="stat-label">BRUSH SIZE</span>
            <input type="range" id="brush-slider" min="5" max="50" value="20">
        </div>
    </div>

    <div id="info-panel">
        <span>ì„¸ëŒ€: <strong id="gen-count" style="color:#fff">0</strong></span>
        <span>|</span>
        <span>ì‹œê°„: <strong id="timer-display" style="color:#fff">0</strong></span>
        <span>|</span>
        <span>ë³€ì´ìœ¨: <strong id="mut-rate" style="color:#ff4757">0%</strong></span>
        <span>|</span>
        <span>ìµœì´ˆ ì„±ê³µ: <strong id="first-success" style="color:#2ecc71">-</strong></span>
    </div>

    <canvas id="canvas"></canvas>

<script>
class Vector {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { this.x += v.x; this.y += v.y; return this; }
    sub(v) { this.x -= v.x; this.y -= v.y; return this; }
    mult(n) { this.x *= n; this.y *= n; return this; }
    div(n) { if(n!==0) { this.x /= n; this.y /= n; } return this; }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() { let m = this.mag(); if (m !== 0) this.mult(1 / m); return this; }
    limit(max) { if (this.mag() > max) { this.normalize(); this.mult(max); } return this; }
    copy() { return new Vector(this.x, this.y); }
    static dist(v1, v2) { return Math.sqrt((v1.x - v2.x) ** 2 + (v1.y - v2.y) ** 2); }
    static random2D() {
        let angle = Math.random() * Math.PI * 2;
        return new Vector(Math.cos(angle), Math.sin(angle));
    }
}

// --- ì „ì—­ ì„¤ì • ---
let width, height;
const lifetime = 3000; 

const popSize = 400; 
const maxForce = 0.5; 
const maxSpeed = 6;
let brushSize = 20; 

let isChallengeRunning = false;
let cycles = 1;
let firstSuccessGeneration = null;
let stagnationCounter = 0;
let lastMaxFitness = 0;

let spawnPoint, targetPoint;
let population;
let lifeCounter = 0;

const gridRes = 4;
let cols, rows;
let obstacleGrid = [];
let distanceMap = [];

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const btnChallenge = document.getElementById('btn-challenge');
const modeBadge = document.getElementById('mode-badge');
const genDisplay = document.getElementById('gen-count');
const mutRateDisplay = document.getElementById('mut-rate');
const firstSuccessDisplay = document.getElementById('first-success');
const loadingOverlay = document.getElementById('loading-overlay');
const timerDisplay = document.getElementById('timer-display');
const orientationOverlay = document.getElementById('orientation-overlay');

let currentMutationRate = 0.01;
let currentMutationForce = 0.05;

const earthImg = new Image();
const marsImg = new Image();
let imagesLoaded = 0;

// [ì¶”ê°€] ë“œë˜ê·¸ ìƒíƒœ ê´€ë¦¬ ë³€ìˆ˜
let dragTarget = null; // 'earth', 'mars', 'wall', null

function initScreen() {
    const winW = window.innerWidth;
    const winH = window.innerHeight;

    // ëª¨ë°”ì¼ ì„¸ë¡œ ëª¨ë“œ ì²´í¬
    if (winW < 900 && winW < winH) {
        orientationOverlay.style.display = 'flex';
        return false; 
    } else {
        orientationOverlay.style.display = 'none';
    }

    width = winW - 20;
    height = winH - 130; 
    canvas.width = width;
    canvas.height = height;
    
    cols = Math.ceil(width / gridRes);
    rows = Math.ceil(height / gridRes);

    if (!obstacleGrid || obstacleGrid.length !== cols || obstacleGrid[0].length !== rows) {
        initObstacleGrid();
    }

    if (!spawnPoint) spawnPoint = new Vector(width / 2, height - 80);
    else { spawnPoint.x = width / 2; spawnPoint.y = height - 80; }
    
    if (!targetPoint) targetPoint = new Vector(width / 2, 80);
    else { targetPoint.x = width / 2; targetPoint.y = 80; }

    return true;
}

window.onload = () => {
    initScreen();
    setupInput();

    document.getElementById('speed-slider').addEventListener('input', e => cycles = parseInt(e.target.value));
    document.getElementById('brush-slider').addEventListener('input', e => brushSize = parseInt(e.target.value));

    const onImgLoad = () => { 
        imagesLoaded++; 
        if(imagesLoaded===2) requestAnimationFrame(drawLoop); 
    };
    
    earthImg.onerror = () => { console.log("Earth image not found"); onImgLoad(); };
    marsImg.onerror = () => { console.log("Mars image not found"); onImgLoad(); };
    
    earthImg.onload = onImgLoad;
    marsImg.onload = onImgLoad;

    earthImg.src = './image/earth.png'; 
    marsImg.src = './image/mars.png';  
    
    setTimeout(() => { if(imagesLoaded < 2) requestAnimationFrame(drawLoop); }, 500);
};

window.addEventListener('resize', () => {
    const ready = initScreen();
    if (ready) {
        if (isChallengeRunning) {
            toggleChallenge(); 
            alert("í™”ë©´ í¬ê¸°ê°€ ë³€ê²½ë˜ì–´ ë„ì „ì„ ì¤‘ì§€í•˜ê³  ì´ˆê¸°í™”í–ˆìŠµë‹ˆë‹¤.");
        }
    }
});

function generateDistanceMap() {
    distanceMap = new Array(cols).fill(0).map(() => new Array(rows).fill(Infinity));
    let targetX = Math.floor(targetPoint.x / gridRes);
    let targetY = Math.floor(targetPoint.y / gridRes);
    
    if (targetX >= cols || targetY >= rows || targetX < 0 || targetY < 0) return false;
    if (obstacleGrid[targetX][targetY]) return false;

    let queue = [[targetX, targetY]];
    distanceMap[targetX][targetY] = 0;

    let dx = [1, -1, 0, 0, 1, 1, -1, -1];
    let dy = [0, 0, 1, -1, 1, -1, 1, -1];
    let cost = [1, 1, 1, 1, 1.4, 1.4, 1.4, 1.4]; 

    while (queue.length > 0) {
        let [x, y] = queue.shift();
        let currentDist = distanceMap[x][y];

        for (let i = 0; i < 8; i++) {
            let nx = x + dx[i];
            let ny = y + dy[i];

            if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
                if (!obstacleGrid[nx][ny]) {
                    let newDist = currentDist + cost[i];
                    if (newDist < distanceMap[nx][ny]) {
                        distanceMap[nx][ny] = newDist;
                        queue.push([nx, ny]);
                    }
                }
            }
        }
    }
    
    let startX = Math.floor(spawnPoint.x / gridRes);
    let startY = Math.floor(spawnPoint.y / gridRes);
    if (startX >= cols || startY >= rows || startX < 0 || startY < 0) return false;

    if (distanceMap[startX][startY] === Infinity) return false;
    return true;
}

function toggleChallenge() {
    if (isChallengeRunning) {
        isChallengeRunning = false;
        btnChallenge.innerText = "ğŸš€ ë„ì „ ì‹œì‘";
        btnChallenge.classList.remove('running');
        modeBadge.innerText = "SETUP";
        modeBadge.className = "badge mode-setup";
        population = null;
        lifeCounter = 0;
    } else {
        loadingOverlay.style.display = 'block';
        setTimeout(() => {
            let success = generateDistanceMap();
            loadingOverlay.style.display = 'none';
            if (!success) { alert("ëª©í‘œ ì§€ì ìœ¼ë¡œ ê°€ëŠ” ê¸¸ì´ ë§‰í˜€ìˆìŠµë‹ˆë‹¤!"); return; }

            isChallengeRunning = true;
            btnChallenge.innerText = "â¹ ì¤‘ì§€ ë° í¸ì§‘";
            btnChallenge.classList.add('running');
            
            population = new Population();
            lifeCounter = 0;
            firstSuccessGeneration = null;
            firstSuccessDisplay.innerText = "-";
            stagnationCounter = 0;
            lastMaxFitness = 0;
        }, 50);
    }
}

function initObstacleGrid() {
    obstacleGrid = new Array(cols).fill(0).map(() => new Array(rows).fill(false));
}

function clearObstacles() {
    if (!isChallengeRunning) initObstacleGrid();
}

class DNA {
    constructor(genes) {
        if (genes) this.genes = genes;
        else {
            this.genes = [];
            for (let i = 0; i < lifetime; i++) {
                let v = Vector.random2D();
                v.mult(Math.random() * maxForce);
                this.genes[i] = v;
            }
        }
    }
    copy() { return new DNA(this.genes.map(v => v.copy())); }

    mutation(startFrame) {
        let cutoff = startFrame || 0;
        for (let i = 0; i < this.genes.length; i++) {
            if (i < cutoff) {
                if (i > 0 && i < this.genes.length - 1) {
                    if (Math.random() < 0.1) { 
                        let smoothed = this.genes[i-1].copy().add(this.genes[i]).add(this.genes[i+1]);
                        smoothed.div(3);
                        smoothed.limit(maxForce);
                        this.genes[i] = smoothed;
                    }
                }
                if (Math.random() < 0.01) { 
                    let nudge = Vector.random2D();
                    nudge.mult(currentMutationForce * 0.5); 
                    this.genes[i].add(nudge);
                    this.genes[i].limit(maxForce);
                }
            } else {
                if (Math.random() < currentMutationRate) {
                    let nudge = Vector.random2D();
                    nudge.mult(currentMutationForce);
                    this.genes[i].add(nudge);
                    this.genes[i].limit(maxForce);
                }
            }
        }
    }
}

class Rocket {
    constructor(dna, isBest = false) {
        this.pos = spawnPoint.copy();
        this.vel = new Vector(0, 0);
        this.acc = new Vector(0, 0);
        this.dna = dna || new DNA();
        this.fitness = 0;
        this.completed = false;
        this.crashed = false;
        this.finishTime = 0;
        this.isBest = isBest;
        
        this.recordMapDist = Infinity; 
        this.frameAtBest = 0;
        this.finalMapDist = Infinity; 
        this.stopTime = 0;
    }

    applyForce(force) { this.acc.add(force); }

    update() {
        if (this.completed || this.crashed) return;

        this.stopTime = lifeCounter;

        let d = Vector.dist(this.pos, targetPoint);
        if (d < 50) { 
            this.completed = true;
            this.pos = targetPoint.copy();
            this.finishTime = lifeCounter;
            this.recordMapDist = 0; 
            this.finalMapDist = 0;
            this.frameAtBest = lifeCounter;
        }

        let gx = Math.floor(this.pos.x / gridRes);
        let gy = Math.floor(this.pos.y / gridRes);
        
        if (this.pos.x < 0 || this.pos.x > width || this.pos.y < 0 || this.pos.y > height || 
           (gx >= 0 && gx < cols && gy >= 0 && gy < rows && obstacleGrid[gx][gy])) {
            this.crashed = true;
        } else {
            if (gx >= 0 && gx < cols && gy >= 0 && gy < rows) {
                let currentMapDist = distanceMap[gx][gy];
                if (currentMapDist < this.recordMapDist) {
                    this.recordMapDist = currentMapDist;
                    this.frameAtBest = lifeCounter; 
                }
                this.finalMapDist = currentMapDist;

                let bestDir = new Vector(0,0);
                let minDist = currentMapDist;
                
                let dx = [1, -1, 0, 0, 1, 1, -1, -1]; 
                let dy = [0, 0, 1, -1, 1, -1, 1, -1];
                
                for(let k=0; k<8; k++) {
                    let nx = gx + dx[k];
                    let ny = gy + dy[k];
                    if(nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
                        if(distanceMap[nx][ny] < minDist) {
                            minDist = distanceMap[nx][ny];
                            bestDir = new Vector(dx[k], dy[k]);
                        }
                    }
                }
                
                if(bestDir.mag() > 0) {
                    bestDir.normalize();
                    bestDir.mult(maxForce * 0.3); 
                    this.applyForce(bestDir);
                }
            }
        }

        this.applyForce(this.dna.genes[lifeCounter]);

        if (!this.completed && !this.crashed) {
            this.vel.add(this.acc);
            this.vel.mult(0.98); 
            this.vel.limit(maxSpeed); 
            this.pos.add(this.vel);
            this.acc.mult(0);
        }
    }

    calcFitness() {
        if (this.recordMapDist === Infinity) { this.fitness = 0; return; }

        let peakScore = 1 / (this.recordMapDist + 1);
        this.fitness = Math.pow(peakScore, 4); 

        let drift = Math.max(0, this.finalMapDist - this.recordMapDist);
        let penalty = 1 / (1 + drift * 0.1); 
        this.fitness *= penalty;

        this.fitness *= Math.pow((1 + (lifetime - this.frameAtBest) / 500), 2);

        if (this.completed) {
            this.fitness *= 10; 
            this.fitness *= (1 + (lifetime - this.finishTime) / 20); 
        }
        if (this.crashed) this.fitness *= 0.5; 
    }

    show() {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        let angle = Math.atan2(this.vel.y, this.vel.x);
        ctx.rotate(angle + Math.PI / 2);

        if (this.isBest) {
            ctx.fillStyle = "#ffff00"; ctx.globalAlpha = 1.0; ctx.scale(1.5, 1.5);
        } else if (this.completed) {
            ctx.fillStyle = "#00ff7f"; ctx.globalAlpha = 0.8;
        } else if (this.crashed) {
            ctx.fillStyle = "#ff4757"; ctx.globalAlpha = 0.2;
        } else {
            ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
        }

        ctx.beginPath();
        ctx.moveTo(0, -10); ctx.lineTo(-5, 5); ctx.lineTo(5, 5);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
}

class Population {
    constructor() {
        this.rockets = [];
        this.popSize = popSize;
        this.generation = 1;
        this.bestRocketDNA = null;
        this.mutationCutoff = 0; 
        for (let i = 0; i < this.popSize; i++) this.rockets[i] = new Rocket();
    }

    run() {
        let allStopped = true;
        for (let i = 0; i < this.popSize; i++) {
            this.rockets[i].update();
            this.rockets[i].show();
            if (!this.rockets[i].completed && !this.rockets[i].crashed) allStopped = false;
        }
        return allStopped;
    }

    evaluate() {
        let maxFit = 0;
        let bestIdx = 0;
        let successCount = 0;

        for (let i = 0; i < this.popSize; i++) {
            this.rockets[i].calcFitness();
            if (this.rockets[i].fitness > maxFit) {
                maxFit = this.rockets[i].fitness;
                bestIdx = i;
            }
            if (this.rockets[i].completed) successCount++;
        }
        
        this.bestRocketDNA = this.rockets[bestIdx].dna.copy();

        let bestRocket = this.rockets[bestIdx];
        let usefulLife = bestRocket.completed ? bestRocket.finishTime : bestRocket.frameAtBest;
        this.mutationCutoff = Math.floor(usefulLife * 0.8);

        if (successCount > 0) {
            if (firstSuccessGeneration === null) {
                firstSuccessGeneration = this.generation;
                firstSuccessDisplay.innerText = `${this.generation} ì„¸ëŒ€`;
            }
            modeBadge.innerText = "OPTIMIZING";
            modeBadge.className = "badge mode-opt";
            
            let successRatio = successCount / this.popSize; 
            currentMutationRate = 0.01 + (1 - successRatio) * 0.04; 
            currentMutationForce = 0.05; 
        } else {
            modeBadge.innerText = "SEARCHING";
            modeBadge.className = "badge mode-search";
            if (Math.abs(maxFit - lastMaxFitness) < 0.00000001) stagnationCounter++;
            else stagnationCounter = 0; 
            lastMaxFitness = maxFit;

            currentMutationRate = 0.05 + (stagnationCounter * 0.005);
            currentMutationRate = Math.min(currentMutationRate, 0.3); 
            currentMutationForce = 0.1 + (stagnationCounter * 0.01);
            currentMutationForce = Math.min(currentMutationForce, 0.4);
        }
        mutRateDisplay.innerText = (currentMutationRate * 100).toFixed(1) + "%";
    }

    selection() {
        let newRockets = [];
        newRockets[0] = new Rocket(this.bestRocketDNA.copy(), true);
        for (let i = 1; i < this.popSize; i++) {
            let childDNA = this.bestRocketDNA.copy();
            childDNA.mutation(this.mutationCutoff);
            newRockets[i] = new Rocket(childDNA);
        }
        this.rockets = newRockets;
        this.generation++;
        genDisplay.innerText = this.generation;
    }
}

function drawMapElements() {
    ctx.fillStyle = "#1a1a1a";
    ctx.fillRect(0, 0, width, height);

    ctx.fillStyle = "white";
    for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
            if (obstacleGrid[i][j]) ctx.fillRect(i * gridRes, j * gridRes, gridRes, gridRes);
        }
    }

    if (marsImg.complete && marsImg.naturalWidth !== 0) {
        ctx.drawImage(marsImg, targetPoint.x - 50, targetPoint.y - 50, 100, 100);
    } else {
        ctx.beginPath();
        ctx.arc(targetPoint.x, targetPoint.y, 50, 0, Math.PI*2);
        ctx.fillStyle = "#2ecc71"; ctx.fill();
    }

    if (earthImg.complete && earthImg.naturalWidth !== 0) {
        ctx.drawImage(earthImg, spawnPoint.x - 50, spawnPoint.y - 50, 100, 100);
    } else {
        ctx.beginPath();
        ctx.rect(spawnPoint.x-25, spawnPoint.y-25, 50, 50);
        ctx.fillStyle = "#3498db"; ctx.fill();
    }
}

function drawLoop() {
    if (orientationOverlay.style.display === 'flex') {
        requestAnimationFrame(drawLoop);
        return;
    }

    drawMapElements();
    if (isChallengeRunning && population) {
        for (let n = 0; n < cycles; n++) {
            let allStopped = population.run();
            lifeCounter++;
            timerDisplay.innerText = lifeCounter; 
            if (allStopped || lifeCounter >= lifetime) {
                population.evaluate();
                population.selection();
                lifeCounter = 0;
                break;
            }
        }
    }
    requestAnimationFrame(drawLoop);
}

// --- ì…ë ¥ ì²˜ë¦¬ (ë§ˆìš°ìŠ¤ & í„°ì¹˜ í†µí•©) ---
function setupInput() {
    // Mouse Events
    canvas.addEventListener('mousedown', (e) => {
        const {x, y} = getPos(e);
        handleStart(x, y);
    });
    canvas.addEventListener('mousemove', (e) => {
        const {x, y} = getPos(e);
        handleMove(x, y);
    });
    window.addEventListener('mouseup', handleEnd);

    // Touch Events
    canvas.addEventListener('touchstart', (e) => { 
        e.preventDefault(); 
        const {x, y} = getPos(e.touches[0]);
        handleStart(x, y);
    }, {passive: false});
    
    canvas.addEventListener('touchmove', (e) => { 
        e.preventDefault(); 
        const {x, y} = getPos(e.touches[0]);
        handleMove(x, y);
    }, {passive: false});

    window.addEventListener('touchend', handleEnd);
}

// ì¢Œí‘œ ê³„ì‚° ìœ í‹¸ë¦¬í‹°
function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
    };
}

// ì…ë ¥ ì‹œì‘ (í´ë¦­/í„°ì¹˜ ì‹œ)
function handleStart(x, y) {
    if (isChallengeRunning) return;

    // ì§€êµ¬(ì¶œë°œì ) ê·¼ì²˜ í´ë¦­ í™•ì¸ (íŒì • ë²”ìœ„ 60px)
    if (Vector.dist(new Vector(x, y), spawnPoint) < 60) {
        dragTarget = 'earth';
        return;
    }

    // í™”ì„±(ëª©í‘œì ) ê·¼ì²˜ í´ë¦­ í™•ì¸ (íŒì • ë²”ìœ„ 60px)
    if (Vector.dist(new Vector(x, y), targetPoint) < 60) {
        dragTarget = 'mars';
        return;
    }

    // ì•„ë¬´ê²ƒë„ ì•„ë‹ˆë©´ ë²½ ê·¸ë¦¬ê¸° ëª¨ë“œ
    dragTarget = 'wall';
    addObstacle(x, y);
}

// ì…ë ¥ ì´ë™ (ë“œë˜ê·¸ ì‹œ)
function handleMove(x, y) {
    if (!dragTarget) return;

    if (dragTarget === 'earth') {
        spawnPoint.x = x;
        spawnPoint.y = y;
        // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šê²Œ ì œí•œ
        spawnPoint.x = Math.max(25, Math.min(width - 25, spawnPoint.x));
        spawnPoint.y = Math.max(25, Math.min(height - 25, spawnPoint.y));
    } else if (dragTarget === 'mars') {
        targetPoint.x = x;
        targetPoint.y = y;
        targetPoint.x = Math.max(25, Math.min(width - 25, targetPoint.x));
        targetPoint.y = Math.max(25, Math.min(height - 25, targetPoint.y));
    } else if (dragTarget === 'wall') {
        addObstacle(x, y);
    }
}

// ì…ë ¥ ì¢…ë£Œ
function handleEnd() {
    dragTarget = null;
}

function addObstacle(x, y) {
    let radius = brushSize / 2; 
    let minGridX = Math.max(0, Math.floor((x - radius) / gridRes));
    let maxGridX = Math.min(cols - 1, Math.floor((x + radius) / gridRes));
    let minGridY = Math.max(0, Math.floor((y - radius) / gridRes));
    let maxGridY = Math.min(rows - 1, Math.floor((y + radius) / gridRes));

    for (let i = minGridX; i <= maxGridX; i++) {
        for (let j = minGridY; j <= maxGridY; j++) {
            let cellCenterX = i * gridRes + gridRes / 2;
            let cellCenterY = j * gridRes + gridRes / 2;
            let dist = Math.sqrt((cellCenterX - x) ** 2 + (cellCenterY - y) ** 2);
            if (dist < radius) obstacleGrid[i][j] = true;
        }
    }
}
</script>
</body>
</html>