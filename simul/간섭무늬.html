<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>간섭무늬 (심플 모드)</title>
  <style>
    html, body {
      height:100%; margin:0;
      background:#0a0a0a; color:#e6e6e6;
      font-family:system-ui, sans-serif;
      overscroll-behavior: none; /* 당겨서 새로고침 방지 */
    }

    /* === 기본 데스크탑 스타일 === */
    .wrap {
      width:min(92vmin, 720px);
      aspect-ratio:1 / 1;
      margin:3vmin auto 0.8rem;
      background:#000;
      border-radius:14px;
      box-shadow:0 12px 40px rgba(0,0,0,.55);
      overflow:hidden;
      touch-action:none;
      position: relative;
    }
    canvas#sim {
      width:100%; height:100%; display:block;
      cursor:grab;
      touch-action:none;
      -webkit-user-select:none; user-select:none;
    }
    .panel {
      width:min(92vmin, 720px);
      margin:0 auto 0.6rem;
      display:grid;
      grid-template-columns: 120px 1fr 62px;
      gap:8px 12px;
      align-items:center;
      font-size:14px;
    }
    .panel label { color:#bdbdbd }
    .panel input[type="range"], .panel select { width:100% }
    .badge {
      width:min(92vmin, 720px);
      margin:0 auto 0.6rem;
      text-align:center; color:#9b9b9b; font-size:12px;
      line-height: 1.5;
    }
    .brand {
      width:min(92vmin, 720px);
      margin:0 auto 2rem;
      text-align:center;
      color:#c7f36b; font-weight:700;
      letter-spacing:.02em;
      text-shadow:0 1px 10px rgba(199,243,107,.25);
    }

    /* === 모바일 최적화 (화면 분할) === */
    @media (max-width: 768px) {
      body { overflow: hidden; } /* 전체 스크롤 막기 */

      /* 1. 상단 시뮬레이션 영역 (45%) */
      .wrap {
        position: fixed;
        top: 0; left: 0;
        width: 100%;
        height: 45vh;
        aspect-ratio: auto;
        margin: 0;
        border-radius: 0 0 14px 14px;
        border-bottom: 1px solid #333;
        z-index: 5;
      }

      /* 2. 하단 UI 영역 (55% - 스크롤 가능) */
      #ui-layer {
        position: fixed;
        top: 45vh;
        left: 0;
        width: 100%;
        height: 55vh;
        overflow-y: auto;
        background: #0a0a0a;
        padding: 20px 0 60px 0;
        box-sizing: border-box;
        z-index: 10;
      }
      
      /* 패널 스타일 조정 */
      .panel, .badge, .brand {
        width: 90%;
        margin-left: auto; margin-right: auto;
      }
      .panel { gap: 12px 8px; margin-bottom: 20px;}
      .panel label { font-size: 13px; }
    }
  </style>
</head>
<body>

  <div class="wrap">
    <canvas id="sim"></canvas>
  </div>

  <div id="ui-layer">
    
    <div class="panel">
      <label for="lambda">파장 λ</label>
      <input id="lambda" type="range" min="16" max="200" step="2" value="60">
      <output id="lambdaOut">60</output>

      <label for="speed">위상속도 v</label>
      <input id="speed" type="range" min="20" max="400" step="5" value="140">
      <output id="speedOut">140</output>

      <label for="expo">노출</label>
      <input id="expo" type="range" min="2000" max="60000" step="1000" value="22000">
      <output id="expoOut">22000</output>

      <label for="sources">파원 개수</label>
      <select id="sources">
        <option value="1">1개</option>
        <option value="2" selected>2개</option>
        <option value="3">3개</option>
      </select>
    </div>

    <div class="badge">
      드래그/터치: 파원 이동 • 감쇠 = <b>1/√r</b><br>
      밝은 곳: 보강 간섭 • 어두운 곳: 상쇄 간섭
    </div>
    <div class="brand">왕왕물리시뮬레이션</div>

  </div> <script>
/* ==== 원형파 간섭 시뮬레이터 (그래프/게임 제거됨) ==== */
(() => {
  const canvas = document.getElementById('sim');
  const ctx = canvas.getContext('2d');

  // UI 엘리먼트
  const $λ = document.getElementById('lambda'), $λOut=document.getElementById('lambdaOut');
  const $v = document.getElementById('speed'), $vOut=document.getElementById('speedOut');
  const $ex = document.getElementById('expo'), $exOut=document.getElementById('expoOut');
  const $src = document.getElementById('sources');

  let lambda=+$λ.value, v=+$v.value, exposure=+$ex.value;
  let numSources = +$src.value;

  // 파원 배열 (정규화 좌표)
  let sources = [
    { x:0.35, y:0.5 },
    { x:0.65, y:0.5 },
    { x:0.5,  y:0.3 }
  ];

  // 캔버스/이미지 버퍼
  let W=0,H=0,imgData,data;
  let rAll=[], invSqrtAll=[];
  let dragging=null, rebuildScheduled=false, draggingActive=false;

  function resizeCanvasToContainer(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio||1);
    const w=Math.round(rect.width*dpr), h=Math.round(rect.height*dpr);
    if(w===W && h===H) return;
    W=w; H=h;
    canvas.width=W; canvas.height=H;
    imgData=ctx.createImageData(W,H); data=imgData.data;
    rebuildCache();
  }

  function rebuildCache(){
    rAll=[]; invSqrtAll=[];
    for(let si=0; si<numSources; si++){
      const S={x:sources[si].x*W, y:sources[si].y*H};
      const r=new Float32Array(W*H), invSqrt=new Float32Array(W*H);
      let i=0;
      for(let y=0;y<H;y++){
        const dy=y-S.y;
        for(let x=0;x<W;x++,i++){
          const d=Math.hypot(x-S.x,dy)+1e-4;
          r[i]=d; invSqrt[i]=1/Math.sqrt(d);
        }
      }
      rAll.push(r); invSqrtAll.push(invSqrt);
    }
  }

  // ----- 드래그(마우스/터치) 처리 -----
  function canvasToNorm(ev){
    const rect=canvas.getBoundingClientRect();
    return {
      x:Math.min(1,Math.max(0,(ev.clientX-rect.left)/rect.width)),
      y:Math.min(1,Math.max(0,(ev.clientY-rect.top)/rect.height))
    };
  }

  function blockScroll(ev){ if(draggingActive) ev.preventDefault(); }

  canvas.addEventListener('pointerdown', e=>{
    e.preventDefault();
    canvas.setPointerCapture?.(e.pointerId);
    canvas.style.cursor='grabbing';
    draggingActive=true;

    const n=canvasToNorm(e);
    let nearest=0, best=1e9;
    for(let i=0;i<numSources;i++){
      const d=Math.hypot(n.x-sources[i].x, n.y-sources[i].y);
      if(d<best){best=d; nearest=i;}
    }
    dragging=nearest;
  }, {passive:false});

  canvas.addEventListener('pointermove', e=>{
    if(dragging==null) return;
    e.preventDefault();
    sources[dragging]=canvasToNorm(e);
    if(!rebuildScheduled){
      rebuildScheduled=true;
      requestAnimationFrame(()=>{ rebuildCache(); rebuildScheduled=false; });
    }
  }, {passive:false});

  function endDrag(e){
    if(dragging!=null){
      dragging=null;
      canvas.releasePointerCapture?.(e.pointerId);
      canvas.style.cursor='grab';
      draggingActive=false;
      rebuildCache();
    }
  }
  canvas.addEventListener('pointerup', endDrag, {passive:false});
  canvas.addEventListener('pointercancel', endDrag, {passive:false});
  canvas.addEventListener('lostpointercapture', ()=>{ dragging=null; draggingActive=false; }, {passive:true});
  document.addEventListener('touchmove', blockScroll, {passive:false});
  document.addEventListener('gesturestart', blockScroll, {passive:false});

  // ----- UI 이벤트 -----
  $λ.addEventListener('input',e=>{lambda=+e.target.value;$λOut.textContent=lambda;});
  $v.addEventListener('input',e=>{v=+e.target.value;$vOut.textContent=v;});
  $ex.addEventListener('input',e=>{exposure=+e.target.value;$exOut.textContent=exposure;});
  $src.addEventListener('change',e=>{numSources=+e.target.value; rebuildCache();});

  $λOut.textContent=lambda; $vOut.textContent=v; $exOut.textContent=exposure;

  // ----- 렌더 루프 -----
  function render(tMs){
    resizeCanvasToContainer();
    const t=tMs/1000;
    const k=(2*Math.PI)/lambda, omega=k*v;
    if(rAll.length!==numSources) rebuildCache();

    let i=0;
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++,i++){
        let a=0;
        for(let si=0;si<numSources;si++){
          a += Math.sin(k*rAll[si][i] - omega*t) * invSqrtAll[si][i];
        }
        let I=a*a*exposure; if(I>255) I=255;
        const g=I|0, o=i*4;
        data[o]=g; data[o+1]=g; data[o+2]=g; data[o+3]=255;
      }
    }
    ctx.putImageData(imgData,0,0);

    // 파원 표시 (하얀 점)
    ctx.fillStyle='#ffffff';
    const rDot = 3*(window.devicePixelRatio||1);
    for(let si=0;si<numSources;si++){
      ctx.beginPath();
      ctx.arc(sources[si].x*W, sources[si].y*H, rDot, 0, Math.PI*2);
      ctx.fill();
    }
    
    // (이곳에 있던 검은색 그래프 그리기 코드를 삭제했습니다)

    requestAnimationFrame(render);
  }

  resizeCanvasToContainer();
  requestAnimationFrame(render);
  window.addEventListener('resize',resizeCanvasToContainer);

})();
</script>

</body>
</html>