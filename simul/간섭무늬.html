<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ê°„ì„­ë¬´ëŠ¬</title>
  <style>
    html, body {
      height:100%; margin:0;
      background:#0a0a0a; color:#e6e6e6;
      font-family:system-ui, sans-serif;
      overscroll-behavior: none;
    }
    .wrap {
      width:min(92vmin, 720px);
      aspect-ratio:1 / 1;
      margin:3vmin auto 0.8rem;
      background:#000;
      border-radius:14px;
      box-shadow:0 12px 40px rgba(0,0,0,.55);
      overflow:hidden;
      touch-action:none;
    }
    canvas#sim {
      width:100%; height:100%; display:block;
      cursor:grab;
      touch-action:none;
      -webkit-user-select:none; user-select:none;
    }
    .panel {
      width:min(92vmin, 720px);
      margin:0 auto 0.6rem;
      display:grid;
      grid-template-columns: 120px 1fr 62px;
      gap:8px 12px;
      align-items:center;
      font-size:14px;
    }
    .panel label { color:#bdbdbd }
    .panel input[type="range"], .panel select { width:100% }
    .badge {
      width:min(92vmin, 720px);
      margin:0 auto 0.6rem;
      text-align:center; color:#9b9b9b; font-size:12px;
    }
    .brand {
      width:min(92vmin, 720px);
      margin:0 auto 2rem;
      text-align:center;
      color:#c7f36b; font-weight:700;
      letter-spacing:.02em;
      text-shadow:0 1px 10px rgba(199,243,107,.25);
    }

    /* === ê°„ì„­ ë„ì „ ë°•ìŠ¤ (ë°ì€ ìƒ‰) === */
.challenge-box{
  position:fixed;

  /* ğŸ“ ìœ„ì¹˜: ì™¼ìª½ ì•„ë˜ */
  left:14px;
  bottom:14px;
  top:auto;
  transform:none;

  /* ğŸ“ í­: í™”ë©´ì— ë§ê²Œ ìë™ ì¡°ì ˆ */
  width:clamp(220px, 38vw, 420px);
  max-width:calc(100vw - 28px);

  z-index:20;
  background:rgba(255,255,255,0.98);
  border:1px solid #e2e8f0;
  border-radius:14px;
  padding:10px 12px;
  color:#0f172a;
  box-shadow:0 12px 28px rgba(148,163,184,0.55);
  font-size:13px;
  line-height:1.45;
}
    .cb-title{
      font-size:12px;
      font-weight:800;
      letter-spacing:.08em;
      color:#2563eb;
      margin-bottom:6px;
      text-transform:uppercase;
    }
    .cb-rows{
      display:flex;
      justify-content:space-between;
      gap:12px;
      margin-bottom:6px;
    }
    .cb-row{
      flex:1;
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      margin-bottom:2px;
    }
    .cb-label{
      font-size:12px;
      color:#64748b;
    }
    .cb-value{
      font-size:15px;
      font-weight:800;
      text-align:right;
      color:#0f172a;
    }
    .cb-best .cb-value{
      color:#f59e0b;
      text-shadow:0 0 5px rgba(245,158,11,0.6);
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap:4px;
    }
    .cb-best .trophy{
      font-size:18px;
    }
    .cb-btn-row{
      display:flex;
      gap:8px;
      margin-top:4px;
    }
    .cb-btn{
      flex:1;
      border-radius:999px;
      border:1px solid #bfdbfe;
      background:linear-gradient(135deg,#2563eb,#38bdf8);
      color:#f9fafb;
      font-size:13px;
      font-weight:700;
      padding:6px 0;
      cursor:pointer;
    }
    .cb-btn:hover{
      filter:brightness(1.05);
    }
    .cb-btn-secondary{
      flex:1;
      background:#e5e7eb;
      border-color:#cbd5e1;
      color:#111827;
      font-size:12px;
      padding:6px 0;
    }
    .cb-btn-secondary:hover{
      background:#d1d5db;
    }
    .cb-msg{
      margin-top:6px;
      font-size:11.5px;
      line-height:1.5;
      color:#4b5563;
      min-height:40px;
    }
    .cb-msg small{
      display:block;
      color:#9ca3af;
      margin-top:2px;
    }

    @keyframes bestPop {
      0%   { transform:scale(1); }
      30%  { transform:scale(1.25); }
      60%  { transform:scale(0.92); }
      100% { transform:scale(1); }
    }
    #int-challenge .best-badge{
      animation:none;
    }
    #int-challenge .best-badge.best-bump{
      animation:bestPop .6s ease-out;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="sim"></canvas>
  </div>

  <!-- ê°„ì„­ ë„ì „ ë°•ìŠ¤ -->
  <div class="challenge-box" id="int-challenge">
    <div class="cb-title">ê°„ì„­ ë„ì „</div>
    <div class="cb-rows">
      <div style="flex:1.1">
        <div class="cb-row">
          <div class="cb-label">ë¼ìš´ë“œ</div>
          <div class="cb-value" id="int-round">-</div>
        </div>
        <div class="cb-row">
          <div class="cb-label">ì ìˆ˜</div>
          <div class="cb-value" id="int-score">0</div>
        </div>
      </div>
      <div class="cb-row cb-best" style="flex:1">
        <div class="cb-label">ìµœê³ ì ìˆ˜</div>
        <div class="cb-value best-badge">
          <span class="trophy">ğŸ†</span>
          <span id="int-best">0</span>
        </div>
      </div>
    </div>
    <div class="cb-btn-row">
      <button id="int-start" class="cb-btn">ë„ì „</button>
      <button id="int-check" class="cb-btn cb-btn-secondary">ì •ë‹µ í™•ì¸</button>
    </div>
    <div class="cb-msg" id="int-msg">
      ì•„ë˜ ìº”ë²„ìŠ¤ì˜ <b>ê²€ì€ìƒ‰ ì„ </b>ì€ í˜„ì¬ ì„¤ì •ìœ¼ë¡œ ë§Œë“  ê°„ì„­ë¬´ëŠ¬ ë‹¨ë©´ì´ê³ ,<br>
      <b style="color:#f97316">ì£¼í™©ìƒ‰ ì„ </b>ì€ ëª©í‘œ ê°„ì„­ë¬´ëŠ¬ì…ë‹ˆë‹¤.<br>
      íŒŒì¥ ìŠ¬ë¼ì´ë”ì™€ íŒŒì› ìœ„ì¹˜ë¥¼ ì¡°ì ˆí•´ ë‘ ì„ ì„ ìµœëŒ€í•œ ê²¹ì¹˜ê²Œ ë§Œë“¤ì–´ ë³´ì„¸ìš”.
      <small>ì´ 10ë¼ìš´ë“œ Â· ì •ë‹µë§ˆë‹¤ +50ì  Â· ì˜¤ë‹µì€ 0ì </small>
    </div>
  </div>

  <!-- ì›ë˜ ì¡°ì‘ íŒ¨ë„ -->
  <div class="panel">
    <label for="lambda">íŒŒì¥ Î»</label>
    <input id="lambda" type="range" min="16" max="200" step="2" value="60">
    <output id="lambdaOut">60</output>

    <label for="speed">ìœ„ìƒì†ë„ v</label>
    <input id="speed" type="range" min="20" max="400" step="5" value="140">
    <output id="speedOut">140</output>

    <label for="expo">ë…¸ì¶œ</label>
    <input id="expo" type="range" min="2000" max="60000" step="1000" value="22000">
    <output id="expoOut">22000</output>

    <label for="sources">íŒŒì› ê°œìˆ˜</label>
    <select id="sources">
      <option value="1">1ê°œ</option>
      <option value="2" selected>2ê°œ</option>
      <option value="3">3ê°œ</option>
    </select>
  </div>

  <div class="badge">
    ë“œë˜ê·¸/í„°ì¹˜: íŒŒì› ì´ë™ â€¢ ê°ì‡  = <b>1/âˆšr</b><br>
    <span style="color:#f97316">ì£¼í™©ìƒ‰ ì„ </span>: ëª©í‘œ ë¬´ëŠ¬ Â· <span style="color:#e5e7eb">ê²€ì€ìƒ‰ ì„ </span>: í˜„ì¬ ë¬´ëŠ¬
  </div>
  <div class="brand">ì™•ì™•ë¬¼ë¦¬ì‹œë®¬ë ˆì´ì…˜</div>

<script>
/* ==== ì›í˜•íŒŒ ê°„ì„­ ì‹œë®¬ë ˆì´í„° + ë‹¨ë©´ ê·¸ë˜í”„ API ==== */
(() => {
  const canvas = document.getElementById('sim');
  const ctx = canvas.getContext('2d');

  // UI ì—˜ë¦¬ë¨¼íŠ¸
  const $Î» = document.getElementById('lambda'), $Î»Out=document.getElementById('lambdaOut');
  const $v = document.getElementById('speed'), $vOut=document.getElementById('speedOut');
  const $ex = document.getElementById('expo'), $exOut=document.getElementById('expoOut');
  const $src = document.getElementById('sources');

  let lambda=+$Î».value, v=+$v.value, exposure=+$ex.value;
  let numSources = +$src.value;

  // íŒŒì› ë°°ì—´ (ì •ê·œí™” ì¢Œí‘œ)
  let sources = [
    { x:0.35, y:0.5 },
    { x:0.65, y:0.5 },
    { x:0.5,  y:0.3 }
  ];

  // ìº”ë²„ìŠ¤/ì´ë¯¸ì§€ ë²„í¼
  let W=0,H=0,imgData,data;
  let rAll=[], invSqrtAll=[];
  let dragging=null, rebuildScheduled=false, draggingActive=false;

  // ê²Œì„ìš©: ëª©í‘œ í”„ë¡œíŒŒì¼(ì£¼í™©ìƒ‰ ì„ )
  let targetProfile = null;

  function resizeCanvasToContainer(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio||1);
    const w=Math.round(rect.width*dpr), h=Math.round(rect.height*dpr);
    if(w===W && h===H) return;
    W=w; H=h;
    canvas.width=W; canvas.height=H;
    imgData=ctx.createImageData(W,H); data=imgData.data;
    rebuildCache();
  }

  function rebuildCache(){
    rAll=[]; invSqrtAll=[];
    for(let si=0; si<numSources; si++){
      const S={x:sources[si].x*W, y:sources[si].y*H};
      const r=new Float32Array(W*H), invSqrt=new Float32Array(W*H);
      let i=0;
      for(let y=0;y<H;y++){
        const dy=y-S.y;
        for(let x=0;x<W;x++,i++){
          const d=Math.hypot(x-S.x,dy)+1e-4;
          r[i]=d; invSqrt[i]=1/Math.sqrt(d);
        }
      }
      rAll.push(r); invSqrtAll.push(invSqrt);
    }
  }

  // ----- ë“œë˜ê·¸(ë§ˆìš°ìŠ¤/í„°ì¹˜) ì²˜ë¦¬ -----
  function canvasToNorm(ev){
    const rect=canvas.getBoundingClientRect();
    return {
      x:Math.min(1,Math.max(0,(ev.clientX-rect.left)/rect.width)),
      y:Math.min(1,Math.max(0,(ev.clientY-rect.top)/rect.height))
    };
  }

  function blockScroll(ev){ if(draggingActive) ev.preventDefault(); }

  canvas.addEventListener('pointerdown', e=>{
    e.preventDefault();
    canvas.setPointerCapture?.(e.pointerId);
    canvas.style.cursor='grabbing';
    draggingActive=true;

    const n=canvasToNorm(e);
    let nearest=0, best=1e9;
    for(let i=0;i<numSources;i++){
      const d=Math.hypot(n.x-sources[i].x, n.y-sources[i].y);
      if(d<best){best=d; nearest=i;}
    }
    dragging=nearest;
  }, {passive:false});

  canvas.addEventListener('pointermove', e=>{
    if(dragging==null) return;
    e.preventDefault();
    sources[dragging]=canvasToNorm(e);
    if(!rebuildScheduled){
      rebuildScheduled=true;
      requestAnimationFrame(()=>{ rebuildCache(); rebuildScheduled=false; });
    }
  }, {passive:false});

  function endDrag(e){
    if(dragging!=null){
      dragging=null;
      canvas.releasePointerCapture?.(e.pointerId);
      canvas.style.cursor='grab';
      draggingActive=false;
      rebuildCache();
    }
  }
  canvas.addEventListener('pointerup', endDrag, {passive:false});
  canvas.addEventListener('pointercancel', endDrag, {passive:false});
  canvas.addEventListener('lostpointercapture', ()=>{ dragging=null; draggingActive=false; }, {passive:true});
  document.addEventListener('touchmove', blockScroll, {passive:false});
  document.addEventListener('gesturestart', blockScroll, {passive:false});

  // ----- UI ì´ë²¤íŠ¸ -----
  $Î».addEventListener('input',e=>{lambda=+e.target.value;$Î»Out.textContent=lambda;});
  $v.addEventListener('input',e=>{v=+e.target.value;$vOut.textContent=v;});
  $ex.addEventListener('input',e=>{exposure=+e.target.value;$exOut.textContent=exposure;});
  $src.addEventListener('change',e=>{numSources=+e.target.value; rebuildCache();});

  $Î»Out.textContent=lambda; $vOut.textContent=v; $exOut.textContent=exposure;

  // ----- ì¤‘ì•™ ë‹¨ë©´ í”„ë¡œíŒŒì¼ ê³„ì‚° -----
  function computeProfile(lambdaVal, srcList){
    const prof = new Float32Array(W || 1);
    if(!W || !H || !srcList || srcList.length===0) return prof;
    const k = (2*Math.PI) / lambdaVal;
    const yMid = H*0.5;
    for(let x=0;x<W;x++){
      let amp = 0;
      for(let si=0; si<srcList.length; si++){
        const sx = srcList[si].x * W;
        const sy = srcList[si].y * H;
        const dx = x - sx;
        const dy = yMid - sy;
        const r  = Math.hypot(dx,dy) + 1e-4;
        amp += Math.sin(k*r) / Math.sqrt(r);
      }
      const I = amp*amp;
      prof[x] = I;
    }
    // 0~1ë¡œ ì •ê·œí™”
    let max = 0;
    for(let x=0;x<W;x++) if(prof[x]>max) max=prof[x];
    const inv = max>0 ? 1/max : 1;
    for(let x=0;x<W;x++) prof[x]*=inv;
    return prof;
  }

  function drawGraph(currentProf){
    if(!W || !H) return;
    const graphHeight = Math.min(80, H*0.25);
    const marginBottom = 12;
    const yBase = H - marginBottom;
    const yTop  = yBase - graphHeight;

    ctx.save();
    // ë°°ê²½ ë°•ìŠ¤
    ctx.fillStyle = 'rgba(0,0,0,0.65)';
    ctx.fillRect(0, yTop, W, graphHeight);

    // ê°€ìš´ë° ê¸°ì¤€ì„ 
    ctx.strokeStyle = 'rgba(148,163,184,0.4)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, yBase - graphHeight*0.5);
    ctx.lineTo(W, yBase - graphHeight*0.5);
    ctx.stroke();

    // ëª©í‘œ(ì£¼í™©ìƒ‰) í”„ë¡œíŒŒì¼
    if(targetProfile && targetProfile.length === W){
      ctx.strokeStyle = '#f97316';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for(let x=0;x<W;x++){
        const y = yBase - targetProfile[x]*graphHeight*0.9;
        if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }

    // í˜„ì¬(ê²€ì€ìƒ‰) í”„ë¡œíŒŒì¼
    if(currentProf && currentProf.length === W){
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 1.6;
      ctx.beginPath();
      for(let x=0;x<W;x++){
        const y = yBase - currentProf[x]*graphHeight*0.9;
        if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }

    ctx.restore();
  }

  // ----- ë Œë” ë£¨í”„ -----
  function render(tMs){
    resizeCanvasToContainer();
    const t=tMs/1000;
    const k=(2*Math.PI)/lambda, omega=k*v;
    if(rAll.length!==numSources) rebuildCache();

    let i=0;
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++,i++){
        let a=0;
        for(let si=0;si<numSources;si++){
          a += Math.sin(k*rAll[si][i] - omega*t) * invSqrtAll[si][i];
        }
        let I=a*a*exposure; if(I>255) I=255;
        const g=I|0, o=i*4;
        data[o]=g; data[o+1]=g; data[o+2]=g; data[o+3]=255;
      }
    }
    ctx.putImageData(imgData,0,0);

    // íŒŒì› í‘œì‹œ
    ctx.fillStyle='#ffffff';
    const rDot = 3*(window.devicePixelRatio||1);
    for(let si=0;si<numSources;si++){
      ctx.beginPath();
      ctx.arc(sources[si].x*W, sources[si].y*H, rDot, 0, Math.PI*2);
      ctx.fill();
    }

    // ì¤‘ì•™ ë‹¨ë©´ ê·¸ë˜í”„ (ê²€ì€ìƒ‰ ì„  + ì£¼í™©ìƒ‰ ì„ )
    const currentProf = computeProfile(lambda, sources.slice(0,numSources));
    drawGraph(currentProf);

    requestAnimationFrame(render);
  }

  resizeCanvasToContainer();
  requestAnimationFrame(render);
  window.addEventListener('resize',resizeCanvasToContainer);

  // ===== ê²Œì„ìš© API ê³µê°œ =====
  window.InterferenceGameAPI = {
    getConfig(){
      return {
        lambda,
        v,
        exposure,
        numSources,
        sources: sources.slice(0,numSources).map(s=>({x:s.x,y:s.y}))
      };
    },
    setLambda(val){
      lambda = val;
      $Î».value = String(Math.round(val));
      $Î»Out.textContent = String(Math.round(val));
    },
    setConfig(cfg){
      if(typeof cfg.lambda === 'number'){
        lambda = cfg.lambda;
        $Î».value = String(Math.round(lambda));
        $Î»Out.textContent = String(Math.round(lambda));
      }
      if(typeof cfg.v === 'number'){
        v = cfg.v;
        $v.value = String(Math.round(v));
        $vOut.textContent = String(Math.round(v));
      }
      if(typeof cfg.exposure === 'number'){
        exposure = cfg.exposure;
        $ex.value = String(Math.round(exposure));
        $exOut.textContent = String(Math.round(exposure));
      }
      if(typeof cfg.numSources === 'number'){
        numSources = Math.max(1, Math.min(3, cfg.numSources|0));
        $src.value = String(numSources);
      }
      if(cfg.sources && cfg.sources.length){
        for(let i=0;i<Math.min(numSources, cfg.sources.length);i++){
          sources[i].x = Math.min(1, Math.max(0, cfg.sources[i].x));
          sources[i].y = Math.min(1, Math.max(0, cfg.sources[i].y));
        }
      }
      rebuildCache();
    },
    computeProfile,
    setTargetProfile(profile){
      targetProfile = profile;
    }
  };
})();
</script>

<!-- ==== ê°„ì„­ ë„ì „ ê²Œì„ ë¡œì§ (10ë¼ìš´ë“œ, 50ì ì”©) ==== -->
<script>
(function(){
  const elRound = document.getElementById('int-round');
  const elScore = document.getElementById('int-score');
  const elBest  = document.getElementById('int-best');
  const elMsg   = document.getElementById('int-msg');
  const btnStart= document.getElementById('int-start');
  const btnCheck= document.getElementById('int-check');

  let score = 0;
  let bestScore = 0;
  let round = 0;
  let targetLambda = null;
  let targetProfile = null;
  let fixedSources = null;   // í•œ ê²Œì„ ë™ì•ˆ ê³ ì •í•  íŒŒì› ìœ„ì¹˜
  let playing = false;

  function randInt(min, max){
    return Math.floor(min + Math.random()*(max-min+1));
  }

  function updateBestScoreUI(animate){
    if(!elBest) return;
    elBest.textContent = bestScore;
    const badge = document.querySelector('#int-challenge .best-badge');
    if(animate && badge){
      badge.classList.remove('best-bump');
      void badge.offsetWidth;
      badge.classList.add('best-bump');
    }
  }

  // Firebaseì—ì„œ ìµœê³ ì  ë¶ˆëŸ¬ì˜¬ ë•Œ ì“¸ ì½œë°±
  window.setBestScoreFromFirebase = function(scoreFromDb){
    bestScore = Number(scoreFromDb) || 0;
    updateBestScoreUI(false);
  };

  function resetGameText(){
    elMsg.innerHTML =
      'ì•„ë˜ ìº”ë²„ìŠ¤ì˜ <b>ê²€ì€ìƒ‰ ì„ </b>ì€ í˜„ì¬ ì„¤ì •ìœ¼ë¡œ ë§Œë“  ê°„ì„­ë¬´ëŠ¬ ë‹¨ë©´ì´ê³ ,<br>'+
      '<b style="color:#f97316">ì£¼í™©ìƒ‰ ì„ </b>ì€ ëª©í‘œ ê°„ì„­ë¬´ëŠ¬ì…ë‹ˆë‹¤.<br>'+
      'íŒŒì¥ ìŠ¬ë¼ì´ë”ì™€ íŒŒì› ìœ„ì¹˜ë¥¼ ì¡°ì ˆí•´ ë‘ ì„ ì„ ìµœëŒ€í•œ ê²¹ì¹˜ê²Œ ë§Œë“¤ì–´ ë³´ì„¸ìš”.'+
      '<small>ì´ 10ë¼ìš´ë“œ Â· ì •ë‹µë§ˆë‹¤ +50ì  Â· ì˜¤ë‹µì€ 0ì </small>';
  }

  function startNewRun(){
    const api = window.InterferenceGameAPI;
    if(!api){
      elMsg.textContent = 'ì‹œë®¬ë ˆì´í„°ê°€ ì•„ì§ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.';
      return;
    }
    score = 0;
    round = 1;
    elScore.textContent = '0';
    elRound.textContent = '1/10';
    playing = true;

    // í˜„ì¬ íŒŒì› ë°°ì¹˜ë¥¼ í•œ ê²Œì„ ë™ì•ˆ ê³ ì •
    const cfg = api.getConfig();
    fixedSources = cfg.sources;

    setupRound();
  }

  function setupRound(){
    const api = window.InterferenceGameAPI;
    if(!api || !fixedSources || !playing) return;

    // ë¼ìš´ë“œë§ˆë‹¤ ìƒˆë¡œìš´ ëª©í‘œ Î» ìƒì„± (ì§€ê¸ˆ Î»ì™€ ì–´ëŠ ì •ë„ ì°¨ì´ë‚˜ê²Œ)
    const currentLambda = api.getConfig().lambda;
    let newLambda = randInt(24, 180);
    let tries = 0;
    while(Math.abs(newLambda - currentLambda) < 10 && tries < 30){
      newLambda = randInt(24, 180);
      tries++;
    }
    targetLambda = newLambda;

    // ëª©í‘œ í”„ë¡œíŒŒì¼ ê³„ì‚° & ì£¼í™©ìƒ‰ ì„ ìœ¼ë¡œ ì„¤ì •
    targetProfile = api.computeProfile(targetLambda, fixedSources);
    api.setTargetProfile(targetProfile);

    // í”Œë ˆì´ì–´ ì‹œì‘ê°’ì€ ëª©í‘œì—ì„œ ì‚´ì§ ë²—ì–´ë‚˜ê²Œ ì„¸íŒ…
    const startLambda = targetLambda + randInt(-40,40);
    api.setLambda(Math.max(16, Math.min(200, startLambda)));

    elRound.textContent = round + '/10';
    elScore.textContent = String(score);
    elMsg.innerHTML =
      `ë¼ìš´ë“œ ${round}: <b style="color:#f97316">ì£¼í™©ìƒ‰ ëª©í‘œ ì„ </b>ì„ ì˜ ë³´ê³ ,<br>`+
      `<b>ê²€ì€ìƒ‰ ì„ </b>ì´ ìµœëŒ€í•œ ê²¹ì¹˜ë„ë¡ Î»ì™€ íŒŒì› ìœ„ì¹˜ë¥¼ ì¡°ì ˆí•´ ë³´ì„¸ìš”.`+
      '<small>ì¤€ë¹„ê°€ ë˜ë©´ [ì •ë‹µ í™•ì¸] ë²„íŠ¼ì„ ëˆŒëŸ¬ ì±„ì í•©ë‹ˆë‹¤.</small>';
  }

  function checkAnswer(){
    const api = window.InterferenceGameAPI;
    if(!api){
      elMsg.textContent = 'ì‹œë®¬ë ˆì´í„°ê°€ ì•„ì§ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.';
      return;
    }
    if(!playing || round===0 || !fixedSources || !targetProfile){
      elMsg.innerHTML = 'ë¨¼ì € <b>ë„ì „</b> ë²„íŠ¼ìœ¼ë¡œ ê²Œì„ì„ ì‹œì‘í•´ ì£¼ì„¸ìš”.';
      return;
    }

    const cfg = api.getConfig();
    const currentProfile = api.computeProfile(cfg.lambda, fixedSources);

    // ë‘ í”„ë¡œíŒŒì¼ì˜ í‰ê·  ì°¨ì´ë¡œ ì •ë‹µ íŒì •
    const W = Math.min(currentProfile.length, targetProfile.length);
    if(W === 0){
      elMsg.textContent = 'í”„ë¡œíŒŒì¼ ê³„ì‚°ì— ë¬¸ì œê°€ ìƒê²¼ìŠµë‹ˆë‹¤.';
      return;
    }

    let diffSum = 0;
    const step = 4; // ê³„ì‚°ëŸ‰ ì¤„ì´ê¸°
    let count = 0;
    for(let x=0;x<W;x+=step){
      diffSum += Math.abs(currentProfile[x] - targetProfile[x]);
      count++;
    }
    const avgDiff = diffSum / Math.max(1, count);  // 0 ~ 2 ì •ë„ ë²”ìœ„

    const threshold = 0.18; // ì´ ê°’ì´ ì‘ì„ìˆ˜ë¡ ë” ë¹¡ì…ˆ
    const correct = (avgDiff < threshold);

    if(correct){
      score += 50;
      elScore.textContent = String(score);

      if(score > bestScore){
        bestScore = score;
        updateBestScoreUI(true);
        if(window.saveBestScoreToFirebase){
          window.saveBestScoreToFirebase(bestScore);
        }
      }else{
        updateBestScoreUI(false);
      }

      elMsg.innerHTML =
        'âœ… ì •ë‹µì…ë‹ˆë‹¤! +50ì <br>'+
        `<small>ë‘ ì„ ì˜ í‰ê·  ì°¨ì´: ${avgDiff.toFixed(3)} (ê¸°ì¤€ ${threshold.toFixed(2)} ì´í•˜)</small>`;
    }else{
      elMsg.innerHTML =
        'âŒ ì•„ì§ ì°¨ì´ê°€ í½ë‹ˆë‹¤. ì´ë²ˆ ë¼ìš´ë“œëŠ” 0ì ì…ë‹ˆë‹¤.<br>'+
        `<small>ë‘ ì„ ì˜ í‰ê·  ì°¨ì´: ${avgDiff.toFixed(3)} (ê¸°ì¤€ ${threshold.toFixed(2)} ì´í•˜)</small>`;
    }

    if(round >= 10){
      const final = score;
      playing = false;
      setTimeout(()=>{
        elRound.textContent = '-';
        elMsg.innerHTML =
          `ê²Œì„ì´ ëë‚¬ìŠµë‹ˆë‹¤.<br><b>ìµœì¢… ì ìˆ˜: ${final}ì </b>`+
          '<small>ë‹¤ì‹œ ë„ì „í•˜ë ¤ë©´ [ë„ì „] ë²„íŠ¼ì„ ëˆŒëŸ¬ ì£¼ì„¸ìš”.</small>';
      }, 700);
    }else{
      setTimeout(()=>{
        round++;
        setupRound();
      }, 700);
    }
  }

  btnStart.addEventListener('click', ()=>{
    startNewRun();
  });

  btnCheck.addEventListener('click', ()=>{
    checkAnswer();
  });

  // ì²˜ìŒ ì•ˆë‚´ ë¬¸êµ¬ ì„¸íŒ…
  resetGameText();
})();
</script>

<!-- ==== Firebase ìµœê³ ì  ì €ì¥ (ìƒëŒ€ì„±ì´ë¡ /ë Œì¦ˆì™€ ë™ì¼ êµ¬ì¡°) ==== -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
  import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";
  import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCO36JgPpNz8swADxTMVJUFVALWM5o171w",
    authDomain: "simulation-67cd3.firebaseapp.com",
    projectId: "simulation-67cd3",
    storageBucket: "simulation-67cd3.appspot.com",
    messagingSenderId: "615983461615",
    appId: "1:615983461615:web:002e07bcea878eb6d5571a",
    measurementId: "G-9RGN7LYE5W"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  const SIM_ID = "ê°„ì„­ë¬´ëŠ¬_ë„ì „ê²Œì„";
  let firebaseUser = null;

  async function saveBestScore(score) {
    if (!firebaseUser) return;
    try {
      const ref = doc(db, "users", firebaseUser.uid, "simulations", SIM_ID);
      await setDoc(ref, { score: Number(score) || 0 }, { merge: true });
    } catch (err) {
      console.error("[ê°„ì„­ ë„ì „] ìµœê³  ì ìˆ˜ ì €ì¥ ì˜¤ë¥˜:", err);
    }
  }

  async function loadBestScore() {
    if (!firebaseUser) return;
    try {
      const ref = doc(db, "users", firebaseUser.uid, "simulations", SIM_ID);
      const snap = await getDoc(ref);
      if (snap.exists()) {
        const data = snap.data();
        const score = Number(data.score || 0) || 0;
        if (window.setBestScoreFromFirebase) {
          window.setBestScoreFromFirebase(score);
        }
      }
    } catch (err) {
      console.error("[ê°„ì„­ ë„ì „] ìµœê³  ì ìˆ˜ ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜:", err);
    }
  }

  window.saveBestScoreToFirebase = saveBestScore;

  onAuthStateChanged(auth, async (user) => {
    firebaseUser = user;
    if (user) {
      await loadBestScore();
    }
  });
</script>

</body>
</html>
