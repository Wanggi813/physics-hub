<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>도플러 효과 시뮬레이터 — 이동 음원 · 원형 파면</title>
  <style>
    :root{
      --bg:#f7fbff; --panel:#ffffff; --ink:#0f172a; --muted:#5b657a; --accent:#2563eb; --good:#10b981; --warn:#f59e0b; --border:#e6eef9; --radius:18px; --shadow:0 10px 30px rgba(15,23,42,.08);
    }
    *{box-sizing:border-box}
    body{margin:0;background:radial-gradient(1200px 800px at 10% -10%, #eef6ff, #f7fbff);color:var(--ink);font-family:ui-sans-serif,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial}
    header{padding:20px}
    header h1{margin:0 0 6px;font-size:clamp(22px,2.6vw,30px)}
    header p{margin:4px 0 0;color:var(--muted)}
    .wrap{display:grid;grid-template-columns:380px 1fr;gap:16px;padding:0 20px 20px}
    @media (max-width:1020px){.wrap{grid-template-columns:1fr}}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow)}
    .controls{padding:14px;display:grid;gap:10px}
    .group{background:#fff;border:1px dashed var(--border);border-radius:14px;padding:12px}
    .group h3{margin:0 0 8px;font-size:15px}
    .row{display:grid;grid-template-columns:1fr auto;gap:10px;align-items:center;margin:6px 0}
    .row label{color:var(--muted);font-size:13px}
    .row output{font-variant-numeric:tabular-nums;font-size:13px}
    input[type=range]{width:100%;appearance:none;height:6px;background:#e7eef9;border-radius:999px}
    input[type=range]::-webkit-slider-thumb{appearance:none;width:18px;height:18px;border-radius:50%;background:var(--accent);box-shadow:0 0 0 3px rgba(37,99,235,.2)}
    input[type=range]::-moz-range-thumb{width:18px;height:18px;border-radius:50%;background:var(--accent)}
    .viz{padding:12px;display:grid;gap:10px}
    .canvasBox{background:#ffffff;border:1px solid var(--border);border-radius:14px;overflow:hidden}
    canvas{display:block;width:100%;background:linear-gradient(180deg,#ffffff,#f8fbff)}
    .bar{height:10px;border-radius:999px;background:#e7eef9;border:1px solid var(--border);overflow:hidden}
    .bar>i{display:block;height:100%;width:0;background:linear-gradient(90deg,#60a5fa,#34d399)}
    .chip{display:inline-block;padding:6px 10px;border:1px solid var(--border);border-radius:999px;background:#fff;cursor:pointer;margin-right:6px}
    .chip:hover{filter:brightness(1.02)}
    .legend{display:flex;gap:12px;align-items:center;color:var(--muted);font-size:12px}
    .dot{width:10px;height:10px;border-radius:50%}
    footer{text-align:center;color:#111827;padding:18px 12px}
    .brand{font-weight:800;letter-spacing:.08em;border:2px solid #111827;border-radius:999px;padding:8px 14px;display:inline-block}
  </style>
</head>
<body>
  <header>
    <h1>도플러 효과 시뮬레이터</h1>
    <p>속도를 0으로 두면 음원 중심의 <strong>동심원 파면</strong>이, 속도를 주면 <strong>이동하는 원형 파면</strong>과 <em>압축/팽창된 파장</em>이 보입니다. (초음속이면 <strong>마하 콘</strong>도 표시)</p>
  </header>

  <div class="wrap">
    <!-- Controls -->
    <section class="card controls">
      <div class="group">
        <h3>설정</h3>
        <div class="row"><label>음속 <em>v</em> (m/s)</label><output id="out_c">—</output></div>
        <input id="c" type="range" min="200" max="380" step="1" value="340" />
        <div class="row"><label>음원 속도 <em>v<sub>s</sub></em> (m/s)</label><output id="out_vs">—</output></div>
        <input id="vs" type="range" min="-600" max="600" step="1" value="0" />
        <div class="row"><label>주파수 <em>f</em> (Hz)</label><output id="out_f">—</output></div>
        <input id="f" type="range" min="0.5" max="10" step="0.1" value="2" />
        <div class="row"><label>시간 배속</label><output id="out_speed">—</output></div>
        <input id="timescale" type="range" min="0.2" max="3" step="0.1" value="1" />
        <div style="display:flex;gap:8px;align-items:center;margin-top:6px">
          <label style="font-size:13px;color:var(--muted)"><input id="showMach" type="checkbox" checked> 마하 콘 표시(초음속에서)</label>
          <label style="font-size:13px;color:var(--muted)"><input id="showLambda" type="checkbox" checked> 앞/뒤 파장 표시</label>
        </div>
      </div>
      <div class="group">
        <h3>빠른 예시</h3>
        <div>
          <button class="chip" data-vs="0">정지(0 m/s)</button>
          <button class="chip" data-vs="120">저속(+)</button>
          <button class="chip" data-vs="320">준음속(+)</button>
          <button class="chip" data-vs="500">초음속(+)</button>
          <button class="chip" data-vs="-300">반대방향(−)</button>
        </div>
      </div>
      <div class="group legend">
        <div class="dot" style="background:#ef4444"></div> 음원(🚗)
        <div class="dot" style="background:#60a5fa"></div> 파면(동심원)
        <div class="dot" style="background:#10b981"></div> 관찰자
      </div>
<!-- Theory / Formula box -->
<div class="group" style="background:#fdfcff;border:1px solid var(--border);border-radius:14px;padding:10px 12px;margin:6px 0 8px;">
  <div style="font-weight:600;margin-bottom:6px">이론 · 공식</div>
  <div class="eq">파장: <span style="white-space:nowrap">λ = v / f</span></div>
  <div class="eq" style="margin-top:4px">
    정지 관측자, 이동 음원(1차원): 
    앞쪽&nbsp;f′<sub>front</sub> = <span style="white-space:nowrap">v/(v−v<sub>s</sub>)</span>·f,&nbsp; 
    뒤쪽&nbsp;f′<sub>back</sub> = <span style="white-space:nowrap">v/(v+v<sub>s</sub>)</span>·f
  </div>
  <div class="eq" style="margin-top:4px;color:#5b657a">
    일반식(관측자 속도 v<sub>o</sub> 포함): 
    <span style="white-space:nowrap">f′ = ((v ± v<sub>o</sub>)/(v ∓ v<sub>s</sub>))·f</span>
    <small style="color:#94a3b8"> (±는 접근/이탈 부호 규약)</small>
  </div>
  <div style="margin-top:6px;font-size:13px;color:#374151">
    지금 관측자 위치에서: 
    f′<sub>obs</sub> = <b><span id="fObs">—</span> Hz</b>, 
    λ′<sub>obs</sub> = <b><span id="lObs">—</span> m</b>
  </div>
</div>
    </section>

    <!-- Viz -->
    <section class="card viz">
      <div class="canvasBox"><canvas id="canvas" height="420"></canvas></div>
      <div style="display:flex;gap:16px;align-items:center;flex-wrap:wrap;padding:0 4px 8px 4px">
        <div style="font-size:13px;color:var(--muted)">관찰 주파수(정면/후방): <span id="fFront">—</span> / <span id="fBack">—</span> Hz · 파장: <span id="lFront">—</span> / <span id="lBack">—</span> m</div>
        <div style="margin-left:auto;display:flex;gap:8px">
          <button id="btnReset" class="chip">초기화</button>
          <button id="btnPause" class="chip">일시정지</button>
        </div>
      </div>
    </section>
  </div>

  <footer>
    <div class="brand">왕왕 물리시뮬레이션</div>
  </footer>

  <script>
    // ---------- Elements & helpers ----------
    const $ = id => document.getElementById(id);
    const canvas = $('canvas');
    const ctx = canvas.getContext('2d');
    const cEl=$('c'), vsEl=$('vs'), fEl=$('f'), tsEl=$('timescale');
    const out_c=$('out_c'), out_vs=$('out_vs'), out_f=$('out_f'), out_speed=$('out_speed');
    const fFrontEl=$('fFront'), fBackEl=$('fBack'), lFrontEl=$('lFront'), lBackEl=$('lBack');
    const btnReset=$('btnReset'), btnPause=$('btnPause');
    const showMach=$('showMach'), showLambda=$('showLambda');

    // world scale
    function resize(){ canvas.width = canvas.clientWidth; }
    window.addEventListener('resize', resize); resize();

    // simulation state
    const state = {
      t: 0, emitAcc: 0, 
      x0: 120, y0: 240, // start position
      emissions: [], // {t,x,y}
      paused: false,
    };

    function fmt(v){ return Math.abs(v) >= 100 ? v.toFixed(0) : v.toFixed(1); }

    // quick chips
    document.querySelectorAll('.chip[data-vs]').forEach(btn=>{
      btn.addEventListener('click',()=>{ vsEl.value = btn.dataset.vs; });
    });

    btnReset.addEventListener('click',()=>{ state.t=0; state.emitAcc=0; state.emissions.length=0; state.x0=120; })
    btnPause.addEventListener('click',()=>{ state.paused = !state.paused; btnPause.textContent = state.paused? '재생' : '일시정지'; });

    // main update
    let last=performance.now();
    function loop(now){
      const dtRaw = (now-last)/1000; last = now; const ts = Number(tsEl.value); const dt = Math.min(0.05, dtRaw*ts);
      const c = Number(cEl.value); const vs = Number(vsEl.value); const f = Number(fEl.value);
      out_c.textContent = c + ' m/s'; out_vs.textContent = vs + ' m/s'; out_f.textContent = f.toFixed(1) + ' Hz'; out_speed.textContent = ts+'x';
      // observed frequencies and wavelengths (source moving, observer 정지)
      const fFront = f * (c/(c - vs));
      const fBack  = f * (c/(c + vs));
      const lFront = (c - vs)/f; // ahead (압축)
      const lBack  = (c + vs)/f; // behind (팽창)
// --- 관측자에서의 도플러 주파수/파장 ---
const ox = canvas.width - 80, oy = state.y0;

// 소스가 관측자 쪽으로 접근 중인지 판별
const approaching = (vs > 0 && state.x0 < ox) || (vs < 0 && state.x0 > ox);

let fObs = NaN, lObs = NaN;
if (Math.abs(vs) < c) {
  // 정지 관측자, 이동 음원(1D): f′ = f * v / (v − s*vs),  s=+1(접근), −1(이탈)
  const s = approaching ? +1 : -1;
  fObs = f * (c / (c - s * vs));
  lObs = c / fObs;
}
// 표시에 반영
$('fObs').textContent = isFinite(fObs) ? fObs.toFixed(2) : '—';
$('lObs').textContent = isFinite(lObs) ? lObs.toFixed(2) : '—';
      fFrontEl.textContent = isFinite(fFront)? fFront.toFixed(2) : '—';
      fBackEl.textContent  = isFinite(fBack)?  fBack.toFixed(2)  : '—';
      lFrontEl.textContent = isFinite(lFront)? lFront.toFixed(2) : '—';
      lBackEl.textContent  = isFinite(lBack)?  lBack.toFixed(2)  : '—';

      if(!state.paused){
        state.t += dt;
        state.emitAcc += dt;
        // emit a new wavefront every 1/f seconds
        const period = 1/Math.max(0.1, f);
        while(state.emitAcc >= period){
          const te = state.t - state.emitAcc + period; // closer to exact times
          const xe = state.x0 - vs * (state.t - te); state.emissions.push({t: te, x: xe, y: state.y0});
          state.emitAcc -= period;
        }
        // move source
        state.x0 += vs * dt;
        // wrap-around
        const margin = 200; if(state.x0 > canvas.width + margin) state.x0 = -margin; if(state.x0 < -margin) state.x0 = canvas.width + margin;
      }

      draw(c, vs, f, lFront, lBack);
      requestAnimationFrame(loop);
    }

    function draw(c, vs, f, lFront, lBack){
      const w = canvas.width, h = canvas.height; ctx.clearRect(0,0,w,h);
      // grid
      ctx.strokeStyle = '#eef2ff'; ctx.lineWidth=1; ctx.beginPath(); for(let x=40;x<w;x+=40){ctx.moveTo(x,0);ctx.lineTo(x,h);} for(let y=40;y<h;y+=40){ctx.moveTo(0,y);ctx.lineTo(w,y);} ctx.stroke();

      // observer icon (right side)
      const oy = state.y0; const ox = w - 80; ctx.fillStyle='#10b981'; ctx.fillRect(ox-3, oy-30, 6, 30); ctx.beginPath(); ctx.arc(ox, oy-36, 6, 0, Math.PI*2); ctx.fill();

      // wavefront circles
      ctx.strokeStyle = '#60a5fa'; ctx.lineWidth=1.6;
      const now = state.t; const maxAge = 6 / Math.max(0.1, f); // keep ~6 periods
      const kept = [];
      for(const wf of state.emissions){
        const age = now - wf.t; if(age < 0) continue; const r = c * age;
        const px = wf.x; const py = wf.y; const R = r;
        if(R < 2 || px + R < -50 || px - R > w+50) { if(now - wf.t < maxAge) kept.push(wf); continue; }
        ctx.beginPath(); ctx.arc(px, py, R, 0, Math.PI*2); ctx.stroke();
        if(now - wf.t < maxAge) kept.push(wf);
      }
      state.emissions = kept;

      // source (car)
      const sx = state.x0, sy = state.y0;
      ctx.fillStyle = '#ef4444';
      // car body
      ctx.fillRect(sx-18, sy-12, 36, 16);
      ctx.beginPath(); ctx.arc(sx-10, sy+5, 4, 0, Math.PI*2); ctx.arc(sx+10, sy+5, 4, 0, Math.PI*2); ctx.fillStyle='#111'; ctx.fill();
      // direction arrow
      ctx.beginPath(); ctx.moveTo(sx, sy-22); ctx.lineTo(sx + Math.sign(vs)*20, sy-22); ctx.lineTo(sx + Math.sign(vs)*16, sy-26); ctx.moveTo(sx + Math.sign(vs)*20, sy-22); ctx.lineTo(sx + Math.sign(vs)*16, sy-18); ctx.strokeStyle='#94a3b8'; ctx.stroke();

      // Mach cone (only when |vs|>c)
    if (showMach.checked && Math.abs(vs) > c) {
  const M = Math.abs(vs) / c;
  const mu = Math.asin(1 / M);          // 마하각
  const ax = sx, ay = sy, len = 1200;

  // 이동 방향(φ): 오른쪽=0, 왼쪽=π
  const phi = (vs >= 0) ? 0 : Math.PI;

  // '뒤쪽' 기준각 = φ + π  (오른쪽 이동이면 π, 왼쪽 이동이면 0)
  const base = (phi + Math.PI) % (2 * Math.PI); // vs>=0 ? Math.PI : 0 과 동일

  const ang1 = base + mu;
  const ang2 = base - mu;

  ctx.strokeStyle = '#f59e0b';
  ctx.setLineDash([6, 6]);
  ctx.lineWidth = 2;

  ctx.beginPath(); ctx.moveTo(ax, ay);
  ctx.lineTo(ax + len * Math.cos(ang1), ay + len * Math.sin(ang1)); ctx.stroke();

  ctx.beginPath(); ctx.moveTo(ax, ay);
  ctx.lineTo(ax + len * Math.cos(ang2), ay + len * Math.sin(ang2)); ctx.stroke();

  ctx.setLineDash([]); 
  ctx.lineWidth = 1.6;
}

      // Lambda markers ahead/behind along motion direction
      if(showLambda.checked){
        const dir = Math.sign(vs) || 1; // default right
        const front = sx + dir*30; const back = sx - dir*30;
        // front
        ctx.strokeStyle='#64748b'; ctx.beginPath(); ctx.moveTo(front, sy+16); ctx.lineTo(front + dir*lFront, sy+16); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(front, sy+12); ctx.lineTo(front, sy+20); ctx.moveTo(front + dir*lFront, sy+12); ctx.lineTo(front + dir*lFront, sy+20); ctx.stroke();
        ctx.fillStyle='#64748b'; ctx.fillText('λ′(front)', front + dir*lFront/2 - 18, sy+28);
        // back
        ctx.beginPath(); ctx.moveTo(back, sy+34); ctx.lineTo(back - dir*lBack, sy+34); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(back, sy+30); ctx.lineTo(back, sy+38); ctx.moveTo(back - dir*lBack, sy+30); ctx.lineTo(back - dir*lBack, sy+38); ctx.stroke();
        ctx.fillText('λ′(back)', back - dir*lBack/2 - 16, sy+46);
      }

      // labels
      ctx.fillStyle = '#0f172a'; ctx.fillText(`Mach = |v_s|/v = ${(Math.abs(vs)/c).toFixed(2)}`, 14, 24);
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
