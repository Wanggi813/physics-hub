<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RLC ê³µëª… 3D ì‹œë®¬ë ˆì´ì…˜ Â· three.js (ìê¸°ì¥/ìœ ë„ + ìº¡ ë™ì Â·ì €ì† + ì „ë¥˜ ê·¸ë˜í”„)</title>
  <style>
    :root{ --bg:#0b1020; --ink:#e2e8f0; --muted:#94a3b8; --primary:#38bdf8; }
    html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 800px at 70% 0%,#0c1631 0%,#0b1020 55%);color:var(--ink);font:15px/1.6 system-ui,-apple-system,Segoe UI,Roboto,Pretendard,Noto Sans KR,sans-serif}
    header,footer{padding:10px 14px}
    header{display:flex;align-items:center;justify-content:space-between}
    .brand{font-weight:700}
    #scene{position:fixed; inset:0; z-index:0}
    #scene canvas{position:absolute; inset:0; width:100vw !important; height:100vh !important; display:block}

    .hud{position:fixed;left:14px;top:14px;width:360px;background:rgba(15,23,42,.78);backdrop-filter: blur(8px);border:1px solid rgba(148,163,184,.25);border-radius:14px;padding:12px;z-index:10}
    .row{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;margin:6px 0}
    input[type=range]{width:100%}
    .meter{font-variant-numeric:tabular-nums}
    .small{font-size:12px;color:var(--muted)}
    .btn{display:inline-flex;gap:8px;align-items:center;padding:8px 10px;background:#0ea5e9;color:white;border:none;border-radius:10px;cursor:pointer}
    .pill{display:inline-flex;gap:6px;align-items:center;border:1px solid rgba(148,163,184,.35);padding:6px 8px;border-radius:999px}
    .ok{color:#16a34a}
    .err{position:fixed;right:12px;top:12px;background:#fee2e2;color:#991b1b;padding:10px 12px;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,.25);z-index:20}

    .graphbox{position:fixed; right:14px; top:14px; width:320px; background:rgba(15,23,42,.78); border:1px solid rgba(148,163,184,.25); border-radius:14px; padding:10px; z-index:11}
    .graphbox canvas{display:block; width:100%; height:140px}
    .graphbox .title{font-size:12px;color:var(--muted);text-align:right;margin-top:6px}

    /* ===== ë„ì „ ëª¨ë“œ íŒ¨ë„ ===== */
    .game-panel{
      position:fixed;
      left:14px;
      bottom:14px;
      width:360px;
      background:rgba(15,23,42,.78);
      backdrop-filter: blur(8px);
      border:1px solid rgba(148,163,184,.25);
      border-radius:14px;
      padding:12px;
      z-index:12;
      box-shadow:0 10px 28px rgba(9,12,28,.28);
      font-size:13px;
      line-height:1.4;
    }
    .game-header{display:flex;justify-content:space-between;align-items:flex-start;gap:10px;margin-bottom:8px}
    .game-title{font-weight:800;font-size:14px}
    .game-round{font-size:12px;color:rgba(226,232,240,.75);margin-top:2px}
    .game-question{color:rgba(226,232,240,.92);margin:6px 0 10px}
    .game-question b{color:#38bdf8}
    .game-answers{display:none;gap:8px;flex-wrap:wrap;margin:6px 0 8px}
    .game-btn{
      flex:1 1 calc(50% - 8px);
      border-radius:999px;
      border:1px solid rgba(148,163,184,.35);
      background:rgba(2,6,23,.35);
      color:rgba(226,232,240,.95);
      padding:7px 10px;
      font-size:12px;
      cursor:pointer;
    }
    .game-btn:hover:not(:disabled){background:rgba(2,6,23,.55)}
    .game-btn:disabled{opacity:.45;cursor:not-allowed}
    .game-btn.primary{
      flex:0 0 auto;
      background:#0ea5e9;
      border-color:#0ea5e9;
      color:white;
      font-weight:700;
      padding:8px 12px;
    }
    .game-footer{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
    .game-score{font-variant-numeric:tabular-nums;color:rgba(226,232,240,.95)}
    .game-sub{color:rgba(148,163,184,.92);font-size:12px}
    .game-feedback{margin-top:8px;font-size:12px}
    .game-feedback.ok{color:#34d399}
    .game-feedback.bad{color:#fb7185}

    /* ìµœê³ ì ìˆ˜ ë±ƒì§€ */
    .game-best-badge{
      display:inline-flex;align-items:center;gap:6px;
      padding:4px 10px;border-radius:999px;
      background:linear-gradient(135deg, rgba(255,247,230,.95), rgba(255,255,255,.25));
      box-shadow:0 0 0 1px rgba(251,191,36,0.35), 0 0 14px rgba(251,191,36,0.35);
      font-size:12px;white-space:nowrap;
    }
    .best-label{font-size:11px;color:rgba(2,6,23,.65)}
    .best-icon{font-size:15px;line-height:1;text-shadow:0 0 6px rgba(251,191,36,0.55)}
    .best-value{font-weight:900;font-size:14px;color:#fb923c;min-width:26px;text-align:right}

    @keyframes bump{0%{transform:scale(1)}30%{transform:scale(1.06)}100%{transform:scale(1)}}
    .bump{animation:bump .35s ease-out}

    /* íŒíŠ¸ ë°” */
    .hint-wrap{display:none;margin:8px 0 10px;padding:10px;border-radius:12px;border:1px solid rgba(148,163,184,.22);background:rgba(2,6,23,.28)}
    .hint-title{font-size:12px;color:rgba(226,232,240,.85);margin-bottom:8px}
    .hint-bar{position:relative;height:10px;border-radius:999px;background:rgba(148,163,184,.18);overflow:hidden}
    .hint-band{position:absolute;top:0;height:100%;border-radius:999px;background:rgba(34,197,94,.35)}
    .hint-marker{position:absolute;top:-4px;width:2px;height:18px;background:rgba(56,189,248,.95)}
    .hint-meta{margin-top:6px;font-size:12px;color:rgba(148,163,184,.92)}

    /* ëª©í‘œ ê²Œì´ì§€ */
    .goal-wrap{display:none;margin:8px 0 10px;padding:10px;border-radius:12px;border:1px solid rgba(148,163,184,.22);background:rgba(2,6,23,.28)}
    .goal-title{font-size:12px;color:rgba(226,232,240,.85);margin-bottom:8px}
    .goal-bar{position:relative;height:10px;border-radius:999px;background:rgba(148,163,184,.18);overflow:hidden}
    .goal-zone{position:absolute;top:0;height:100%;border-radius:999px;background:rgba(251,191,36,.35)}
    .goal-fill{position:absolute;top:0;left:0;height:100%;border-radius:999px;background:rgba(56,189,248,.55)}
    .goal-meta{margin-top:6px;font-size:12px;color:rgba(148,163,184,.92)}

    @media (max-width: 860px){
      .game-panel{left:10px;right:10px;bottom:10px;width:auto}
      .hud{width:340px}
      .graphbox{width:300px}
    }

  </style>

  <!-- ë¡œì»¬ three.js (ì „ì—­ THREE) -->
  <script src="./libs/three.min.js"></script>
</head>
<body>
  <header>
    <div class="brand">ğŸ”· RLC ê³µëª… 3D ì‹œë®¬ë ˆì´ì…˜ Â· three.js</div>
    <div class="small">ì€ìƒ‰ ë„ì„ Â·ë¶€í’ˆ Â· ì „í•˜ í´ë¼ìš°ë“œ Â· ê³µëª… ì ê¸ˆ Â· B-field</div>
  </header>

  <div id="scene"></div>

  <div class="hud">
    <div class="row"><label for="L">L (mH)</label><span class="meter"><span id="Lval">50</span></span></div>
    <input id="L" type="range" min="1" max="200" step="1" value="50" />

    <div class="row"><label for="C">C (ÂµF)</label><span class="meter"><span id="Cval">10.0</span></span></div>
    <input id="C" type="range" min="0.1" max="100" step="0.1" value="10" />

    <div class="row"><label for="R">R (Î©)</label><span class="meter"><span id="Rval">50</span></span></div>
    <input id="R" type="range" min="5" max="200" step="1" value="50" />


    <div class="row"><label for="f">f (Hz)</label><span class="meter"><span id="fval">â€”</span></span></div>
    <input id="f" type="range" min="1" max="1000" step="1" value="200" />

    <div class="row"><span>ê³µëª… ì ê¸ˆ</span><label class="pill"><input id="lock" type="checkbox" checked /> f = fâ‚€</label></div>

    <div class="row"><label for="vis">í‘œì‹œ ë°°ì†</label><span class="meter"><span id="visVal">0.10Ã—</span></span></div>
    <input id="vis" type="range" min="0.01" max="0.50" step="0.01" value="0.10" />

    <div class="small">
      fâ‚€ = <span id="f0">â€”</span> Hz Â· Q = <span id="Q">â€”</span> Â· Î”f â‰ˆ <span id="BW">â€”</span> Hz Â· f/fâ‚€ = <span id="ratio">â€”</span>
    </div>
    <div style="margin-top:8px;display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <button id="resetCam" class="btn">ì¹´ë©”ë¼ ë¦¬ì…‹</button>
      <span id="resTag" class="pill"><span class="ok">â—</span> ê³µëª… ê·¼ì ‘</span>
    </div>
  </div>

  <div class="graphbox">
    <canvas id="graph" width="320" height="140"></canvas>
    <div class="title">i(t) Â· ì „ë¥˜ (A)</div>
  </div>


  <!-- ===== ë„ì „ ëª¨ë“œ íŒ¨ë„ (RLC ê³µëª…) ===== -->
  <div class="game-panel" id="gamePanel">
    <div class="game-header">
      <div>
        <div class="game-title">RLC ê³µëª… ë„ì „ ëª¨ë“œ</div>
        <div class="game-round" id="gp-round">ë¼ìš´ë“œ: 0 / 10</div>
      </div>
      <div class="game-best-badge" id="gp-best">
        <span class="best-label">ìµœê³ ì ìˆ˜</span>
        <span class="best-icon">ğŸ†</span>
        <span class="best-value" id="gp-best-value">0</span>
      </div>
    </div>

    <div class="game-question" id="gp-question">
      <b>ë„ì „ ì‹œì‘</b>ì„ ëˆ„ë¥´ë©´ ë¼ìš´ë“œë³„ ì¡°ê±´(L, C, R)ì´ ìë™ìœ¼ë¡œ ì„¤ì •ë©ë‹ˆë‹¤.<br>
      í•™ìƒì€ <b>ìŠ¬ë¼ì´ë” ì¡°ì‘ë§Œ</b>ìœ¼ë¡œ ê³µëª… ìƒíƒœë¥¼ ì°¾ì•„ <b>ì œì¶œ</b>í•˜ë©´ ë©ë‹ˆë‹¤.
    </div>

    <!-- íŒíŠ¸ ë°” (1~5ë¼ìš´ë“œì—ì„œë§Œ í‘œì‹œ) -->
    <div class="hint-wrap" id="gp-hint-wrap">
      <div class="hint-title">ê³µëª… íŒíŠ¸(ì‰¬ì›€): ì´ˆë¡ êµ¬ê°„ ì•ˆìœ¼ë¡œ fë¥¼ ë§ì¶”ì„¸ìš”</div>
      <div class="hint-bar">
        <div class="hint-band" id="gp-hint-band"></div>
        <div class="hint-marker" id="gp-hint-marker"></div>
      </div>
      <div class="hint-meta" id="gp-hint-meta"></div>
    </div>

    <!-- ì „ë¥˜ ëª©í‘œ ê²Œì´ì§€ (9ë¼ìš´ë“œ) -->
    <div class="goal-wrap" id="gp-goal-wrap">
      <div class="goal-title">ëª©í‘œ ì „ë¥˜ ì§„í­ ë§ì¶”ê¸° (ê³µëª… ê·¼ì²˜ ìœ ì§€ + ëª©í‘œ êµ¬ê°„)</div>
      <div class="goal-bar">
        <div class="goal-zone" id="gp-goal-zone"></div>
        <div class="goal-fill" id="gp-goal-fill"></div>
      </div>
      <div class="goal-meta" id="gp-goal-meta"></div>
    </div>

    <!-- 10ë¼ìš´ë“œ(í˜•íƒœ ë¶„ë¥˜) -->
    <div class="game-answers" id="gp-answers">
      <button class="game-btn" id="btnNarrow">ë‚ ì¹´ë¡œìš´ ê³µëª…(ê³ Q)</button>
      <button class="game-btn" id="btnWide">ë‘¥ê·¼ ê³µëª…(ì €Q)</button>
    </div>

    <div class="game-footer">
      <span class="game-score" id="gp-score">ì ìˆ˜: 0ì  / 500ì </span>
      <span class="game-sub" id="gp-sub"></span>
      <button class="game-btn primary" id="btnMain">ë„ì „ ì‹œì‘</button>
    </div>
    <div class="game-feedback" id="gp-feedback"></div>
  </div>

  <footer class="small">Â© 2025 Â· êµìœ¡ìš© ì‹œê°í™” Â· ë” ë§ì€ ìë£Œ: </footer>

  <script>
  (function(){
    const elScene = document.getElementById('scene');
    const LSlider = document.getElementById('L');
    const CSlider = document.getElementById('C');
    const RSlider = document.getElementById('R');
    const FSlider = document.getElementById('f');
    const LockChk = document.getElementById('lock');
    const VisSlider = document.getElementById('vis');
    const Lval = document.getElementById('Lval');
    const Cval = document.getElementById('Cval');
    const Rval = document.getElementById('Rval');
    const Fval = document.getElementById('fval');
    const F0val = document.getElementById('f0');
    const Qval = document.getElementById('Q');
    const BWval = document.getElementById('BW');
    const Ratio = document.getElementById('ratio');
    const ResetCamBtn = document.getElementById('resetCam');
    const ResTag = document.getElementById('resTag');
    const VisVal = document.getElementById('visVal');

    // === Graph ===
    const gCanvas = document.getElementById('graph');
    const g = gCanvas.getContext('2d');
    const G_W = gCanvas.width, G_H = gCanvas.height;
    const G_CAP = 360; const gBuf = new Float32Array(G_CAP); let gIdx=0; let yMaxEMA = 1.0;

    function drawGraph(yAmp){
      g.clearRect(0,0,G_W,G_H);
      g.fillStyle = 'rgba(2,6,23,0.75)'; g.fillRect(0,0,G_W,G_H);
      g.strokeStyle = 'rgba(148,163,184,0.25)'; g.lineWidth=1; g.beginPath();
      for(let x=0;x<=G_W;x+=40){ g.moveTo(x,0); g.lineTo(x,G_H); }
      for(let y=0;y<=G_H;y+=28){ g.moveTo(0,y); g.lineTo(G_W,y); }
      g.stroke();
      const y0 = Math.round(G_H/2); g.strokeStyle='rgba(226,232,240,0.5)'; g.beginPath(); g.moveTo(0,y0); g.lineTo(G_W,y0); g.stroke();
      g.strokeStyle = 'rgba(102,204,255,1)'; g.lineWidth=2; g.beginPath();
      for(let i=0;i<G_CAP;i++){
        const idx = (gIdx + i) % G_CAP;
        const v = gBuf[idx];
        const x = i*(G_W/(G_CAP-1));
        const y = y0 - (v / (yAmp+1e-6)) * (G_H*0.42);
        if(i===0) g.moveTo(x,y); else g.lineTo(x,y);
      }
      g.stroke();
      g.fillStyle='rgba(226,232,240,0.8)'; g.font='11px system-ui,-apple-system,Segoe UI,Roboto,Pretendard,sans-serif';
      g.fillText('Â±' + yAmp.toFixed(2) + ' A', 6, 12);
    }

    // --- SimpleOrbit (OrbitControls ëŒ€ì²´) ---
    class SimpleOrbit{
      constructor(camera, dom, target=new THREE.Vector3(0,0,0)){
        this.camera=camera; this.dom=dom; this.target=target;
        this.sph=new THREE.Spherical(12, Math.PI/3, -Math.PI/6);
        const off=camera.position.clone().sub(target); this.sph.setFromVector3(off);
        this.minPhi=0.01; this.maxPhi=Math.PI-0.01; this.minR=3; this.maxR=60;
        this.drag=false; this.lastX=0; this.lastY=0; this.rotSpeed=0.006; this.zoomSpeed=1.1;
        dom.addEventListener('mousedown',e=>{ this.drag=true; this.lastX=e.clientX; this.lastY=e.clientY; });
        window.addEventListener('mouseup',()=>{ this.drag=false; });
        window.addEventListener('mousemove',e=>{
          if(!this.drag) return;
          const dx=e.clientX-this.lastX, dy=e.clientY-this.lastY;
          this.sph.theta -= dx*this.rotSpeed;
          this.sph.phi = Math.min(this.maxPhi, Math.max(this.minPhi, this.sph.phi + dy*this.rotSpeed));
          this.lastX=e.clientX; this.lastY=e.clientY;
          this.update();
        });
        dom.addEventListener('wheel',e=>{
          e.preventDefault();
          const s=Math.pow(this.zoomSpeed, e.deltaY>0?1:-1);
          this.sph.radius = Math.min(this.maxR, Math.max(this.minR, this.sph.radius*s));
          this.update();
        }, {passive:false});
        this.update();
      }
      update(){ const p=new THREE.Vector3().setFromSpherical(this.sph).add(this.target); this.camera.position.copy(p); this.camera.lookAt(this.target); }
      setTarget(v){ this.target.copy(v); this.update(); }
    }

    // === Renderer / Scene / Camera ===
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x07111f, 1);

    // three r152+ vs êµ¬ë²„ì „ í˜¸í™˜
    if ('outputColorSpace' in renderer) {
      renderer.outputColorSpace = THREE.SRGBColorSpace;
    } else if ('outputEncoding' in renderer) {
      renderer.outputEncoding = THREE.sRGBEncoding;
    }
    if ('ACESFilmicToneMapping' in THREE) renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.15;

    elScene.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(10, 9, 15); camera.lookAt(0,0,0);
    const orbit = new SimpleOrbit(camera, renderer.domElement);
    document.getElementById('resetCam').onclick = ()=>{
      camera.position.set(10,9,15); orbit.sph.setFromVector3(camera.position.clone()); orbit.update();
    };

    // === Lights ===
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    scene.add(new THREE.HemisphereLight(0xbfd4ff, 0x080820, 1.2));
    const d = new THREE.DirectionalLight(0xffffff, 1.3); d.position.set(5,8,7); scene.add(d);

    // === Materials ===
    const silverMat = new THREE.MeshStandardMaterial({ color: 0xd9d9d9, metalness: 0.6, roughness: 0.35, emissive: 0x000000, emissiveIntensity: 0.0 });
    const wireMat = silverMat.clone();
    const resistorMat = silverMat.clone();
    const coilMat = silverMat.clone();
    const capacitorMat = silverMat.clone();

    // === Helpers ===
    const sideInner = 8, zWire = 0.0;
    function cylinderBetween(a,b,r=0.08,mat=wireMat){
      const dir = new THREE.Vector3().subVectors(b,a); const len = dir.length();
      const geom = new THREE.CylinderGeometry(r, r, len, 24, 1, true);
      const mesh = new THREE.Mesh(geom, mat);
      const mid = new THREE.Vector3().addVectors(a,b).multiplyScalar(0.5);
      mesh.position.copy(mid);
      mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone().normalize());
      return mesh;
    }
    function updateCylinderBetween(mesh, a, b, r=0.08){
      const dir = new THREE.Vector3().subVectors(b,a); const len = dir.length();
      mesh.geometry.dispose();
      mesh.geometry = new THREE.CylinderGeometry(r, r, len, 24, 1, true);
      const mid = new THREE.Vector3().addVectors(a,b).multiplyScalar(0.5);
      mesh.position.copy(mid);
      mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone().normalize());
    }
    function boxAt(c, size, mat){ const g = new THREE.BoxGeometry(...size); const m = new THREE.Mesh(g, mat); m.position.copy(c); return m; }

    const gModel = new THREE.Group(); scene.add(gModel);
    const P = {
      TL: new THREE.Vector3(-sideInner/2, sideInner/2, zWire),
      TR: new THREE.Vector3( sideInner/2, sideInner/2, zWire),
      BR: new THREE.Vector3( sideInner/2,-sideInner/2, zWire),
      BL: new THREE.Vector3(-sideInner/2,-sideInner/2, zWire),
    };
    const gapFrac = 0.30;
    function splitEdge(a,b){
      const v = new THREE.Vector3().subVectors(b,a);
      const c1 = a.clone().addScaledVector(v, 0.5 - gapFrac/2);
      const c2 = a.clone().addScaledVector(v, 0.5 + gapFrac/2);
      return {a,c1,c2,b};
    }
    const ETop = splitEdge(P.TL, P.TR);
    const ERight = splitEdge(P.TR, P.BR);
    const EBottom = splitEdge(P.BL, P.BR);
    const ELeft = splitEdge(P.TL, P.BL);

    // Wires
    gModel.add(cylinderBetween(ETop.a, ETop.c1)); gModel.add(cylinderBetween(ETop.c2, ETop.b));
    gModel.add(cylinderBetween(ERight.a, ERight.c1)); gModel.add(cylinderBetween(ERight.c2, ERight.b));
    gModel.add(cylinderBetween(EBottom.a, EBottom.c1)); gModel.add(cylinderBetween(EBottom.c2, EBottom.b));
    gModel.add(cylinderBetween(ELeft.a, ELeft.c1)); gModel.add(cylinderBetween(ELeft.c2, ELeft.b));

    // === Components ===
    // AC source (top)
    const acCenter = new THREE.Vector3(0, sideInner/2, zWire);
    const acLen = 2.0;
    const acBody = new THREE.Mesh(new THREE.CylinderGeometry(0.65,0.65,0.18,48), silverMat);
    acBody.position.copy(acCenter); acBody.rotation.x = Math.PI/2; gModel.add(acBody);
    // sine groove (inlay)
    const sinePts=[]; for(let i=0;i<=80;i++){ const t=i/80; const x=(t-0.5)*0.9; const y=Math.sin(t*Math.PI*2)*0.25; sinePts.push(new THREE.Vector3(x, y, 0)); }
    const sinePath = new THREE.CatmullRomCurve3(sinePts);
    const grooveGeo = new THREE.TubeGeometry(sinePath, 160, 0.02, 12, false);
    const grooveMat = new THREE.MeshStandardMaterial({ color: 0x8d98a3, metalness: 0.3, roughness: 0.7 });
    const groove = new THREE.Mesh(grooveGeo, grooveMat);
    groove.position.copy(acCenter);
    groove.rotation.x = Math.PI/2;
    groove.position.z += 0.09 - 0.005;
    gModel.add(groove);
    const acPortL = acCenter.clone().add(new THREE.Vector3(-acLen/2, 0, 0));
    const acPortR = acCenter.clone().add(new THREE.Vector3( acLen/2, 0, 0));
    const postL = new THREE.Mesh(new THREE.CylinderGeometry(0.09,0.09,0.5,24), silverMat); postL.position.copy(acPortL); postL.rotation.z=Math.PI/2; gModel.add(postL);
    const postR = new THREE.Mesh(new THREE.CylinderGeometry(0.09,0.09,0.5,24), silverMat); postR.position.copy(acPortR); postR.rotation.z=Math.PI/2; gModel.add(postR);
    gModel.add(cylinderBetween(ETop.c1, acPortL)); gModel.add(cylinderBetween(acPortR, ETop.c2));

    // Capacitor (right)
    const capCenter = new THREE.Vector3(sideInner/2, 0, zWire);
    const capW0 = 1.0, capT = 0.12, capD0 = 1.0;
    const capPlateTop = boxAt(capCenter.clone(), [capW0, capT, capD0], capacitorMat);
    const capPlateBot = boxAt(capCenter.clone(), [capW0, capT, capD0], capacitorMat);
    gModel.add(capPlateTop, capPlateBot);
    let capConnTop = cylinderBetween(ERight.c1, capPlateTop.position, 0.08);
    let capConnBot = cylinderBetween(capPlateBot.position, ERight.c2, 0.08);
    gModel.add(capConnTop, capConnBot);

    // Inductor (bottom)
    const coilCenter = new THREE.Vector3(0, -sideInner/2, zWire);
    let coilRadius0 = 0.35, coilLen0 = 2.2, turns = 4, wireRadius = 0.08;
    let coilRadius = coilRadius0, coilLen = coilLen0;
    function makeCoilGeometry(){
      const pts = []; const NPTS = 400;
      for(let i=0;i<=NPTS;i++){
        const t=i/NPTS;
        const x=(t-0.5)*coilLen;
        const ang=t*turns*Math.PI*2;
        const y=Math.cos(ang)*coilRadius;
        const z=Math.sin(ang)*coilRadius;
        pts.push(new THREE.Vector3(x, y, z));
      }
      const path = new THREE.CatmullRomCurve3(pts);
      return new THREE.TubeGeometry(path, 400, wireRadius, 24, false);
    }
    const coilMesh = new THREE.Mesh(makeCoilGeometry(), coilMat); coilMesh.position.copy(coilCenter); gModel.add(coilMesh);
    let coilPortL = coilCenter.clone().add(new THREE.Vector3(-coilLen/2, 0, 0));
    let coilPortR = coilCenter.clone().add(new THREE.Vector3( coilLen/2, 0, 0));
    let coilConnL = cylinderBetween(EBottom.c1, coilPortL, 0.08);
    let coilConnR = cylinderBetween(coilPortR, EBottom.c2, 0.08);
    gModel.add(coilConnL, coilConnR);

    // B-field arrows + halos
    const gB = new THREE.Group(); scene.add(gB);
    const N_B = 12; const arrows = [];
    for(let i=0;i<N_B;i++){
      const tx = (i/(N_B-1) - 0.5) * 0.9;
      const yOff = (Math.random()-0.5) * coilRadius * 0.5;
      const zOff = (Math.random()-0.5) * coilRadius * 0.5;
      const pos = new THREE.Vector3(coilCenter.x + tx*coilLen, coilCenter.y + yOff, coilCenter.z + zOff);
      const len = 0.6; const dir = new THREE.Vector3(1,0,0);
      const arr = new THREE.ArrowHelper(dir, pos, len, 0x66ffcc, 0.20, 0.10); arr.userData={tx,yOff,zOff};
      gB.add(arr); arrows.push(arr);
    }
    const halos = []; const haloScale = [1.2, 1.5, 1.85];
    for(const s of haloScale){
      const hGeo = new THREE.TorusGeometry(coilRadius*s, 0.05, 16, 64);
      const hMat = new THREE.MeshBasicMaterial({ color:0x66ccff, transparent:true, opacity:0.0, depthWrite:false, blending: THREE.AdditiveBlending });
      const tor = new THREE.Mesh(hGeo, hMat); tor.position.copy(coilCenter); tor.rotation.y = Math.PI/2; gB.add(tor); halos.push(tor);
    }

    function updateCoilGeom(){
      const LmH = parseFloat(LSlider.value); // 1~200 mH
      const Lnorm = THREE.MathUtils.clamp(LmH/50, 0.2, 5.0);
      // ì§ê´€: r âˆ âˆšL, l âˆ L^{-0.25}
      coilRadius = coilRadius0 * Math.sqrt(Lnorm);
      coilLen    = coilLen0    / Math.pow(Lnorm, 0.25);
      coilMesh.geometry.dispose(); coilMesh.geometry = makeCoilGeometry();
      coilPortL = coilCenter.clone().add(new THREE.Vector3(-coilLen/2, 0, 0));
      coilPortR = coilCenter.clone().add(new THREE.Vector3( coilLen/2, 0, 0));
      updateCylinderBetween(coilConnL, EBottom.c1, coilPortL, 0.08);
      updateCylinderBetween(coilConnR, coilPortR, EBottom.c2, 0.08);
      for(const arr of arrows){ const {tx,yOff,zOff} = arr.userData; arr.position.set(coilCenter.x + tx*coilLen, coilCenter.y + yOff, coilCenter.z + zOff); }
      for(let i=0;i<halos.length;i++){
        const r = coilRadius*haloScale[i];
        const h=halos[i];
        h.geometry.dispose(); h.geometry = new THREE.TorusGeometry(r, 0.05, 16, 64);
        h.position.copy(coilCenter); h.rotation.y = Math.PI/2;
      }
    }
    updateCoilGeom();

    // Resistor (left)
    {
      const resCenter = new THREE.Vector3(-sideInner/2, 0, zWire + 0.03);
      const resLen = 2.2; const resRad = 0.32;
      const resBody = new THREE.Mesh(new THREE.CylinderGeometry(resRad, resRad, resLen, 32), resistorMat);
      resBody.position.copy(resCenter);
      const capGeo = new THREE.CylinderGeometry(resRad*0.85, resRad*0.85, 0.18, 32);
      const resCapTop = new THREE.Mesh(capGeo, resistorMat); resCapTop.position.copy(resCenter).y += resLen/2;
      const resCapBot = new THREE.Mesh(capGeo, resistorMat); resCapBot.position.copy(resCenter).y -= resLen/2;
      gModel.add(resBody, resCapTop, resCapBot);
      const resPortTop = resCenter.clone().add(new THREE.Vector3(0,  resLen/2 + 0.15, 0));
      const resPortBot = resCenter.clone().add(new THREE.Vector3(0, -resLen/2 - 0.15, 0));
      gModel.add(cylinderBetween(ELeft.c1, resPortTop, 0.08));
      gModel.add(cylinderBetween(resPortBot, ELeft.c2, 0.08));
    }

    // Capacitor electron clouds
    const CAP_MAX = 160; const capDotGeo = new THREE.SphereGeometry(0.04, 10, 10);
    const capDotsTop = new THREE.InstancedMesh(capDotGeo, new THREE.MeshStandardMaterial({ color:0x00b4ff, emissive:0x33ccff, emissiveIntensity:0.85, metalness:0.0, roughness:0.6 }), CAP_MAX);
    const capDotsBot = new THREE.InstancedMesh(capDotGeo, new THREE.MeshStandardMaterial({ color:0x00b4ff, emissive:0x33ccff, emissiveIntensity:0.85, metalness:0.0, roughness:0.6 }), CAP_MAX);
    capDotsTop.instanceMatrix.setUsage(THREE.DynamicDrawUsage); capDotsBot.instanceMatrix.setUsage(THREE.DynamicDrawUsage); gModel.add(capDotsTop, capDotsBot);
    const plateCloudTop = Array.from({length:CAP_MAX}, ()=> new THREE.Vector3((Math.random()-0.5)*1.0, (Math.random()-0.5)*0.2 + 0.12, (Math.random()-0.5)*0.9));
    const plateCloudBot = Array.from({length:CAP_MAX}, ()=> new THREE.Vector3((Math.random()-0.5)*1.0, (Math.random()-0.5)*0.2 - 0.12, (Math.random()-0.5)*0.9));

    // ---------- Circuit model ----------
    const VAMP = 5;
    function getR(){ return Math.max(0.1, parseFloat(RSlider.value)||50); }
    function params(){
      const R = getR();
      const L = parseFloat(LSlider.value)/1000;
      const C = parseFloat(CSlider.value)/1e6;
      let f0 = 1/(2*Math.PI*Math.sqrt(L*C)); if(!isFinite(f0)) f0 = 1;
      let f = parseFloat(FSlider.value);
      if(LockChk.checked){ f=f0; FSlider.disabled=true; } else { FSlider.disabled=false; }
      const w=2*Math.PI*f, XL=w*L, XC=1/(w*C);
      const Zmag=Math.sqrt(R*R + (XL-XC)**2);
      const Iamp=VAMP/Zmag;
      const thetaZ=Math.atan2((XL-XC),R);
      const phiI=-thetaZ;
      const Q=Math.sqrt(L/C)/R;
      const BW=f0/Q;
      return {L,C,f,f0,w,XL,XC,Zmag,Iamp,phiI,Q,BW};
    }
    function updateFSliderRange(){
      const {f0}=params();
      const min=Math.max(1, Math.floor(f0*0.2));
      const max=Math.max(min+5, Math.ceil(f0*5));
      FSlider.min=String(min); FSlider.max=String(max);
      const cur=parseFloat(FSlider.value);
      if(cur<min || cur>max){ FSlider.value=String(Math.min(Math.max(cur,min),max)); }
    }
    LSlider.addEventListener('input', updateFSliderRange);
    CSlider.addEventListener('input', updateFSliderRange);
    LockChk.addEventListener('change', updateFSliderRange);
    updateFSliderRange();

    // ---------- Animation ----------
    let tPrev = performance.now()/1000; let qVis = 0; // ì¶•ì „ê¸° ì „í•˜ EMA
    function animate(){
      const tNow = performance.now()/1000; const dt = Math.min(0.05, tNow - tPrev); tPrev = tNow;
      const Pp = params();
      // --- Round 10 auto sweep (short) ---
      if (sweeping && roundType === 'classify_q') {
        sweepT += dt;
        const f0 = Pp.f0;
        const span = 0.25; // Â±25%
        const s = Math.min(1, sweepT/2.2);
        const phase = (s*2*Math.PI);
        const fSweep = f0 * (1 + span*Math.sin(phase));
        const fMin = parseFloat(FSlider.min), fMax = parseFloat(FSlider.max);
        const fClamped = Math.max(fMin, Math.min(fMax, fSweep));
        FSlider.value = String(Math.round(fClamped));
        if (sweepT >= 2.2) {
          sweeping = false;
          btnMain.disabled = true;
          // ë‹µ ë²„íŠ¼ í™œì„±í™”
          btnNarrow.disabled = false; btnWide.disabled = false;
          gpFeedbackEl.className = 'game-feedback';
          gpFeedbackEl.textContent = 'ì´ì œ ì„ íƒí•˜ì„¸ìš”: ë‚ ì¹´ë¡œìš´ ê³µëª…(ê³ Q) / ë‘¥ê·¼ ê³µëª…(ì €Q)';
        }
      }

      const vis = parseFloat(VisSlider.value); VisVal.textContent = vis.toFixed(2)+'Ã—';
      const Rnow = getR();
      Lval.textContent = (+LSlider.value).toFixed(0); Cval.textContent = (+CSlider.value).toFixed(1); Rval.textContent = (+Rnow).toFixed(0); Fval.textContent = Pp.f.toFixed(1); F0val.textContent = Pp.f0.toFixed(1);
      Qval.textContent = isFinite(Pp.Q)? Pp.Q.toFixed(2): 'â€”'; BWval.textContent = (isFinite(Pp.BW) && Pp.BW>0)? Pp.BW.toFixed(1): 'â€”'; Ratio.textContent = (Pp.f/Pp.f0).toFixed(3);

      const nearRes = Math.abs(Pp.f - Pp.f0)/Pp.f0 < 0.03;
      // (ë„ì „ 9~10) ê³µëª… íŒíŠ¸(ë¶ˆ ë“¤ì–´ì˜¤ëŠ” í‘œì‹œ) ìˆ¨ê¹€
      const hideResLamp = (gameState === 'question' && gameRound >= 9);
      ResTag.style.display = hideResLamp ? 'none' : 'inline-flex';
      if(!hideResLamp){
        ResTag.style.opacity = nearRes ? '1' : '0.25';
        ResTag.style.borderColor = nearRes ? 'rgba(34,197,94,.8)' : 'rgba(148,163,184,.35)';
      }

      const tVis = tNow * vis;
      const iInst = Pp.Iamp * Math.sin(Pp.w*tVis + Pp.phiI);
      const di_dt = Pp.Iamp * Pp.w * Math.cos(Pp.w*tVis + Pp.phiI);
      const vR = iInst * Rnow;
      const vL = Pp.Iamp * Pp.XL * Math.sin(Pp.w*tVis + Pp.phiI + Math.PI/2);
      const vC = Pp.Iamp * Pp.XC * Math.sin(Pp.w*tVis + Pp.phiI - Math.PI/2);
      const qC = Pp.C * vC;

      // glow
      const glowWire = THREE.MathUtils.clamp(Math.abs(iInst)*2.2, 0.0, 1.8);
      const glowR = THREE.MathUtils.clamp(Math.abs(vR)*0.12, 0.0, 2.0);
      const glowL = THREE.MathUtils.clamp(Math.abs(vL)*0.05, 0.0, 2.2);
      const glowC = THREE.MathUtils.clamp(Math.abs(vC)*0.05, 0.0, 2.2);
      wireMat.emissiveIntensity = glowWire; resistorMat.emissiveIntensity = glowR; coilMat.emissiveIntensity = glowL; capacitorMat.emissiveIntensity = glowC; silverMat.emissiveIntensity = 0.15 + 0.1*glowWire;

      // Capacitor geometry vs C
      const Cuf = parseFloat(CSlider.value);
      const Cnorm = Math.max(0.001, Cuf/10);
      const sA = THREE.MathUtils.clamp(Math.sqrt(Cnorm), 0.6, 2.0);
      const gap = THREE.MathUtils.clamp(0.8 / Math.sqrt(Cnorm), 0.25, 1.3);
      capPlateTop.scale.set(sA, 1, sA); capPlateBot.scale.set(sA, 1, sA);
      capPlateTop.position.set(capCenter.x, capCenter.y + gap/2, capCenter.z);
      capPlateBot.position.set(capCenter.x, capCenter.y - gap/2, capCenter.z);
      updateCylinderBetween(capConnTop, ERight.c1, capPlateTop.position, 0.08);
      updateCylinderBetween(capConnBot, capPlateBot.position, ERight.c2, 0.08);

      // Capacitor clouds (ìœ„ìƒ ë°˜ëŒ€)
      const alpha = 0.12; qVis += (qC - qVis) * alpha; const kCap = 1e6 * 1.6;
      const baseN = Math.floor(CAP_MAX * 0.35);
      const delta = Math.min(CAP_MAX - baseN, Math.floor(Math.abs(qVis) * kCap));
      const topN = THREE.MathUtils.clamp(baseN + (qVis>0 ? delta : -delta), 0, CAP_MAX);
      const botN = THREE.MathUtils.clamp(baseN + (qVis<0 ? delta : -delta), 0, CAP_MAX);
      const dummy2 = new THREE.Object3D();
      for(let i=0;i<CAP_MAX;i++){
        if(i<topN){ const off = plateCloudTop[i]; dummy2.position.set(capCenter.x + off.x*sA, capCenter.y + gap/2 + off.y, capCenter.z + off.z*sA); }
        else { dummy2.position.set(999,999,999); }
        dummy2.updateMatrix(); capDotsTop.setMatrixAt(i, dummy2.matrix);
      }
      capDotsTop.instanceMatrix.needsUpdate = true;
      for(let i=0;i<CAP_MAX;i++){
        if(i<botN){ const off = plateCloudBot[i]; dummy2.position.set(capCenter.x + off.x*sA, capCenter.y - gap/2 + off.y, capCenter.z + off.z*sA); }
        else { dummy2.position.set(999,999,999); }
        dummy2.updateMatrix(); capDotsBot.setMatrixAt(i, dummy2.matrix);
      }
      capDotsBot.instanceMatrix.needsUpdate = true;

      // B-field
      const signI = (iInst >= 0) ? 1 : -1; const baseLen = 0.5, kLen = 1.4;
      for(const arr of arrows){
        arr.setDirection(new THREE.Vector3(signI,0,0));
        const Lnow = baseLen + kLen * Math.abs(iInst);
        arr.setLength(Lnow, 0.25*Lnow, 0.12*Lnow);
      }
      const diNorm = THREE.MathUtils.clamp(Math.abs(di_dt) / (Math.abs(Pp.Iamp*Pp.w) + 1e-9), 0, 1);
      const sHalo = 1 + 0.25 * diNorm * (di_dt>=0 ? 1 : -1);
      for(const h of halos){
        h.scale.set(sHalo, sHalo, sHalo);
        h.material.opacity = 0.12 + 0.55 * diNorm;
        h.material.color.setHex(di_dt>=0 ? 0x66ccff : 0xff6688);
      }

      // Graph buffer
      gBuf[gIdx] = iInst; gIdx = (gIdx + 1) % G_CAP;
      yMaxEMA += ((Math.max(0.5, Pp.Iamp*1.2)) - yMaxEMA) * 0.05;
      drawGraph(yMaxEMA);

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // Resize
    window.addEventListener('resize', ()=>{
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
    });


    // =============================
    // ====== Challenge Game =======
    // =============================
    const TOTAL_ROUNDS = 10;
    let gameRound = 0;
    let gameState = 'idle'; // idle | question | feedback | finished
    let currentScore = 0;
    let bestScore = 0;

    // round config
    let roundType = null; // 'seek' | 'seek_mid' | 'tune_amp' | 'classify_q'
    let tol = 0.03;
    let moveLimit = 0;
    let moveCount = 0;
    let lastF = null;
    let targetAmpMin = 0.08, targetAmpMax = 0.12; // A (for round 9)
    let correctQIsNarrow = true;
    let sweeping = false;
    let sweepT = 0;

    // UI
    const gpRoundEl = document.getElementById('gp-round');
    const gpQuestionEl = document.getElementById('gp-question');
    const gpScoreEl = document.getElementById('gp-score');
    const gpFeedbackEl = document.getElementById('gp-feedback');
    const gpSubEl = document.getElementById('gp-sub');
    const btnMain = document.getElementById('btnMain');
    const btnNarrow = document.getElementById('btnNarrow');
    const btnWide = document.getElementById('btnWide');
    const gpBestValueEl = document.getElementById('gp-best-value');
    const gpBestBadgeEl = document.getElementById('gp-best');

    const hintWrap = document.getElementById('gp-hint-wrap');
    const hintBand = document.getElementById('gp-hint-band');
    const hintMarker = document.getElementById('gp-hint-marker');
    const hintMeta = document.getElementById('gp-hint-meta');

    const goalWrap = document.getElementById('gp-goal-wrap');
    const goalZone = document.getElementById('gp-goal-zone');
    const goalFill = document.getElementById('gp-goal-fill');
    const goalMeta = document.getElementById('gp-goal-meta');

    const ansWrap = document.getElementById('gp-answers');

    function bump(el){
      if(!el) return;
      el.classList.remove('bump'); void el.offsetWidth; el.classList.add('bump');
    }

    function setBestScoreFromFirebase(score){
      bestScore = Number(score)||0;
      gpBestValueEl.textContent = bestScore;
      bump(gpBestBadgeEl);
    }
    window.setBestScoreFromFirebase = setBestScoreFromFirebase;

    function updateScoreUI(){
      gpScoreEl.textContent = `ì ìˆ˜: ${currentScore}ì  / 500ì `;
      bump(gpScoreEl);
      gpBestValueEl.textContent = bestScore;
    }
    function updateRoundUI(){
      gpRoundEl.textContent = `ë¼ìš´ë“œ: ${gameRound} / ${TOTAL_ROUNDS}`;
    }

    function setMaskedHud(masked){
      // ìˆ«ì íŒíŠ¸(ê³µì‹/ê°’) ìˆ¨ê¹€ â€” í•™ìƒì€ ì¡°ì‘/ê·¸ë˜í”„ë§Œ ë³´ê³  íŒë‹¨
      const maskedText = masked ? 'â€”' : null;
      if(masked){
        F0val.textContent = 'â€”';
        Qval.textContent = 'â€”';
        BWval.textContent = 'â€”';
        Ratio.textContent = 'â€”';
        ResTag.style.opacity = '0.25';
      }
    }

    function setControlsEnabled({L=true,C=true,R=true,f=true,lock=true,vis=true}){
      LSlider.disabled = !L;
      CSlider.disabled = !C;
      RSlider.disabled = !R;
      FSlider.disabled = !f;
      LockChk.disabled = !lock;
      VisSlider.disabled = !vis;
    }

    function rand(min,max){ return min + Math.random()*(max-min); }
    function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

    function randomizeCircuitForRound(type){
      // round íƒ€ì…ë³„ë¡œ ì¡°ê±´ì„ ë‹¤ë¥´ê²Œ ë¿Œë ¤ì„œ ì²´ê° ë‚œì´ë„ ì¡°ì ˆ
      // L(mH) 10~180, C(uF) 0.5~80, R(ohm) 10~150
      const LmH = Math.round(rand(12, 160));
      const CuF = Math.round(rand(0.6, 70)*10)/10;
      let Rv = 50;

      if(type === 'seek'){ Rv = pick([30,40,50,60,80]); }
      else if(type === 'seek_mid'){ Rv = pick([20,30,50,70,100]); }
      else if(type === 'tune_amp'){
        // ê³µëª… ì§„í­ ì¡°ì ˆì´ ê°€ëŠ¥í•˜ë„ë¡ R ë²”ìœ„ë¥¼ ë„“ê²Œ
        Rv = pick([20,30,40,60,80,120,150]);
      } else if(type === 'classify_q'){
        // Që¥¼ í™•ì‹¤íˆ ê°ˆë¦¬ê²Œ
        Rv = pick([12, 18, 28, 45, 80, 120, 160]);
      }

      LSlider.value = String(LmH);
      CSlider.value = String(CuF);
      RSlider.value = String(Rv);
      refresh(); // f slider range + coil update

      // lockì€ ê²Œì„ ì¤‘ ì‚¬ìš© ì•ˆ í•¨
      LockChk.checked = false;

      // ì‹œì‘ ì£¼íŒŒìˆ˜ëŠ” ëœë¤ (f0 ì£¼ë³€ or ì¢€ ë–¨ì–´ì§)
      const {f0} = params();
      let fStart = f0 * (type === 'seek' ? rand(0.85, 1.15) : rand(0.65, 1.45));
      fStart = Math.max(parseFloat(FSlider.min), Math.min(parseFloat(FSlider.max), fStart));
      FSlider.value = String(Math.round(fStart));
      lastF = Number(FSlider.value);
      moveCount = 0;
      updateHintUI();
      updateGoalUI();
    }

    function updateHintUI(){
      const Pp = params();
      const f0 = Pp.f0;
      const fMin = parseFloat(FSlider.min), fMax = parseFloat(FSlider.max);
      const fCur = parseFloat(FSlider.value);
      const toPct = (f)=> ((f - fMin) / (fMax - fMin)) * 100;

      // marker
      hintMarker.style.left = `${toPct(fCur)}%`;

      // band = f0*(1Â±tol)
      const a = Math.max(fMin, f0*(1-tol));
      const b = Math.min(fMax, f0*(1+tol));
      const left = toPct(a);
      const right = toPct(b);
      hintBand.style.left = `${left}%`;
      hintBand.style.width = `${Math.max(0, right-left)}%`;

      hintMeta.textContent =
        (roundType === 'seek')
          ? `í˜„ì¬ f ìœ„ì¹˜ë¥¼ ì´ˆë¡ êµ¬ê°„ì— ë§ì¶”ë©´ ì •ë‹µ(ì œì¶œ)!`
          : `íŒíŠ¸ ì—†ìŒ: ê·¸ë˜í”„ ì§„í­ì´ ìµœëŒ€ê°€ ë˜ëŠ” ì§€ì ì„ ì°¾ì•„ ì œì¶œí•˜ì„¸ìš”.`;
    }

    function updateGoalUI(){
      const Pp = params();
      const amp = Pp.Iamp;
      // normalize gauge: 0~0.20 A ê¸°ì¤€(ë³´ì •)
      const maxA = 0.20;
      const fillPct = Math.max(0, Math.min(100, (amp/maxA)*100));
      goalFill.style.width = `${fillPct}%`;

      // target zone
      const a = Math.max(0, Math.min(maxA, targetAmpMin));
      const b = Math.max(0, Math.min(maxA, targetAmpMax));
      const left = (a/maxA)*100;
      const width = ((b-a)/maxA)*100;
      goalZone.style.left = `${left}%`;
      goalZone.style.width = `${Math.max(0,width)}%`;

      const {f0} = Pp;
      const ratio = (Pp.f / f0);
      goalMeta.textContent = `í˜„ì¬: ì „ë¥˜ ì§„í­â‰ˆ${amp.toFixed(3)}A Â· f/fâ‚€â‰ˆ${ratio.toFixed(3)} (ê³µëª… ê·¼ì²˜ ìœ ì§€!)`;
    }

    function setPanelForRound(){
      gpFeedbackEl.textContent = '';
      gpFeedbackEl.className = 'game-feedback';
      ansWrap.style.display = 'none';
      hintWrap.style.display = 'none';
      goalWrap.style.display = 'none';
      gpSubEl.textContent = '';

      // ê¸°ë³¸(ë„ì „ ëª¨ë“œê°€ ì•„ë‹ ë•Œ): ëª¨ë“  ì¡°ì‘ ê°€ëŠ¥ + f=f0 í† ê¸€ ê°€ëŠ¥
      if(gameState === 'idle' || gameState === 'finished'){
        gpQuestionEl.innerHTML =
          `<b>ë„ì „ ëª¨ë“œ</b>ë¥¼ ëˆ„ë¥´ë©´ ë¼ìš´ë“œë³„ ì¡°ê±´(L, C, R)ì´ ìë™ìœ¼ë¡œ ì„¤ì •ë©ë‹ˆë‹¤.<br>`+
          `ë„ì „ ëª¨ë“œê°€ ì•„ë‹ ë•ŒëŠ” <b>f=fâ‚€</b>ë¥¼ ììœ ë¡­ê²Œ ì¼°ë‹¤/ê»ë‹¤ í•  ìˆ˜ ìˆì–´ìš”.`;
        btnMain.textContent = (gameState === 'finished') ? 'ë‹¤ì‹œ ë„ì „' : 'ë„ì „ ì‹œì‘';
        btnMain.disabled = false;
        btnNarrow.disabled = true; btnWide.disabled = true;
        setControlsEnabled({L:true,C:true,R:true,f:true,lock:true,vis:true});
        setMaskedHud(false);
        return;
      }

      const r = gameRound;

      if(roundType === 'seek'){
        hintWrap.style.display = 'block';
        gpQuestionEl.innerHTML =
          `<b>ì‰¬ì›€</b> Â· ê³µëª… ì°¾ê¸° (1~5)<br>`+
          `ì´ˆë¡ êµ¬ê°„(ê³µëª… ê·¼ì²˜) ì•ˆìœ¼ë¡œ <b>f</b>ë¥¼ ë§ì¶˜ ë’¤ <b>ì œì¶œ</b>í•˜ì„¸ìš”.`;
        btnMain.textContent = 'ì œì¶œ';
        gpSubEl.textContent = '';
        setControlsEnabled({L:false,C:false,R:false,f:true,lock:false,vis:true});
        setMaskedHud(true);
      } else if(roundType === 'seek_mid'){
        // 6~8: ì¤‘ê°„, 9~10: ì–´ë ¤ì›€(ì¡°ê¸ˆ ë” ì—„ê²©í•œ tol)
        const lvl = (r <= 8) ? 'ì¤‘ê°„' : 'ì–´ë ¤ì›€';
        const rr  = (r <= 8) ? '(6~8)' : '(9~10)';
        gpQuestionEl.innerHTML =
          `<b>${lvl}</b> Â· íŒíŠ¸ ì—†ì´ ê³µëª… ì°¾ê¸° ${rr}<br>`+
          `ê·¸ë˜í”„ ì§„í­ì´ ê°€ì¥ ì»¤ì§€ëŠ” ì§€ì ìœ¼ë¡œ <b>f</b>ë¥¼ ë§ì¶˜ ë’¤ <b>ì œì¶œ</b>í•˜ì„¸ìš”.`;
        btnMain.textContent = 'ì œì¶œ';
        hintWrap.style.display = 'none';
        gpSubEl.textContent = '';
        setControlsEnabled({L:false,C:false,R:false,f:true,lock:false,vis:true});
        setMaskedHud(true);
      }
    }

    function startNewGame(){
      gameRound = 0;
      currentScore = 0;
      gameState = 'question';
      updateScoreUI();
      nextRound();
    }

    function nextRound(){
      gameRound++;
      if(gameRound > TOTAL_ROUNDS){
        endGame();
        return;
      }
      updateRoundUI();

      // determine type
      if(gameRound <= 5){
        // ì‰¬ì›€: íŒíŠ¸(ë°´ë“œ) í‘œì‹œ + ì œì¶œë¡œ íŒì •
        roundType = 'seek';
        tol = 0.03;
        moveLimit = 0;
      } else if(gameRound <= 8){
        // ì¤‘ê°„: íŒíŠ¸ ì—†ìŒ + ì¡°ì‘ ì œí•œ(ë‹¤ ì“°ë©´ ì œì¶œë¡œ íŒì •)
        roundType = 'seek_mid';
        tol = 0.02;
        moveLimit = 0;
      } else {
        // ì–´ë ¤ì›€(9~10): 6~8ê³¼ ë™ì¼í•œ í˜•íƒœ(ê³µëª… ì°¾ê¸°)ì§€ë§Œ ì¡°ê¸ˆ ë” ì—„ê²©í•˜ê²Œ
        roundType = 'seek_mid';
        tol = 0.015;
        moveLimit = 0;
      }

      gameState = 'question';
      randomizeCircuitForRound(roundType);

      // (ë„ì „ ëª¨ë“œ) ìë™ ìŠ¤ìœ•/ë¶„ë¥˜ ë¼ìš´ë“œëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠìŒ
      sweeping = false;


      setPanelForRound();
      btnMain.disabled = false;
    }

    function endGame(){
      gameState = 'finished';
      setControlsEnabled({L:true,C:true,R:true,f:true,lock:true,vis:true});
      gpFeedbackEl.className = 'game-feedback ok';
      gpFeedbackEl.textContent = `ë„ì „ ì¢…ë£Œ! ì´ ì ìˆ˜ ${currentScore}ì  / 500ì . ìµœê³  ì ìˆ˜ ê°±ì‹ ì— ë„ì „í•´ ë³´ì„¸ìš”.`;
      btnMain.textContent = 'ë‹¤ì‹œ ë„ì „';
      btnMain.disabled = false;
      setMaskedHud(false);
      bump(gpBestBadgeEl);
    }

    function isNearResonance(){
      const Pp = params();
      const rel = Math.abs(Pp.f - Pp.f0) / Pp.f0;
      return rel < tol;
    }

    function submitSeek(){
      const ok = isNearResonance();
      if(ok){
        currentScore += 50;
        gpFeedbackEl.className = 'game-feedback ok';
        gpFeedbackEl.textContent = `ì •ë‹µ! +50ì  (ê³µëª… í¬ì°©)`;
      } else {
        gpFeedbackEl.className = 'game-feedback bad';
        gpFeedbackEl.textContent = `ì˜¤ë‹µ! ê³µëª… ì§€ì ì´ ì•„ë‹™ë‹ˆë‹¤.`;
      }

      if(currentScore > bestScore){
        bestScore = currentScore;
        if(window.saveBestScoreToFirebase) window.saveBestScoreToFirebase(bestScore);
        bump(gpBestBadgeEl);
      }
      updateScoreUI();

      // ë‹¤ìŒ ì§„í–‰
      if(gameRound >= TOTAL_ROUNDS){
        btnMain.textContent = 'ìµœì¢… ê²°ê³¼';
      } else {
        btnMain.textContent = 'ë‹¤ìŒ ë¼ìš´ë“œ';
      }
      gameState = 'feedback';
      setControlsEnabled({L:false,C:false,R:false,f:false,lock:false,vis:true});
      btnMain.disabled = false;
      setMaskedHud(false);
    }

    function submitTuneAmp(){
      const Pp = params();
      const amp = Pp.Iamp;
      const ampOk = (amp >= targetAmpMin && amp <= targetAmpMax);
      const resOk = isNearResonance();
      const ok = ampOk && resOk;

      if(ok){
        currentScore += 50;
        gpFeedbackEl.className = 'game-feedback ok';
        gpFeedbackEl.textContent = `ì •ë‹µ! +50ì  (ê³µëª… ìœ ì§€ + ëª©í‘œ ì§„í­ ì„±ê³µ)`;
      } else {
        gpFeedbackEl.className = 'game-feedback bad';
        gpFeedbackEl.textContent =
          `ì˜¤ë‹µ! `+
          `${resOk ? 'ê³µëª…ì€ OK' : 'ê³µëª… ê·¼ì²˜ê°€ ì•„ë‹˜'} Â· `+
          `${ampOk ? 'ì§„í­ì€ OK' : 'ì§„í­ì´ ëª©í‘œ êµ¬ê°„ ë°–'}`;
      }

      if(currentScore > bestScore){
        bestScore = currentScore;
        if(window.saveBestScoreToFirebase) window.saveBestScoreToFirebase(bestScore);
        bump(gpBestBadgeEl);
      }
      updateScoreUI();

      if(gameRound >= TOTAL_ROUNDS){
        btnMain.textContent = 'ìµœì¢… ê²°ê³¼';
      } else {
        btnMain.textContent = 'ë‹¤ìŒ ë¼ìš´ë“œ';
      }
      gameState = 'feedback';
      setControlsEnabled({L:false,C:false,R:false,f:false,lock:false,vis:true});
      btnMain.disabled = false;
      setMaskedHud(false);
    }

    function answerQ(isNarrow){
      if(gameState !== 'question' || roundType !== 'classify_q') return;

      sweeping = false;
      const ok = (isNarrow === correctQIsNarrow);
      if(ok){
        currentScore += 50;
        gpFeedbackEl.className = 'game-feedback ok';
        gpFeedbackEl.textContent = `ì •ë‹µ! +50ì  (ê³µëª… ê³¡ì„  íŒë³„ ì„±ê³µ)`;
      } else {
        gpFeedbackEl.className = 'game-feedback bad';
        gpFeedbackEl.textContent = `ì˜¤ë‹µ! ì´ë²ˆ ë¼ìš´ë“œëŠ” ${correctQIsNarrow ? 'ë‚ ì¹´ë¡œìš´ ê³µëª…(ê³ Q)' : 'ë‘¥ê·¼ ê³µëª…(ì €Q)'} ì…ë‹ˆë‹¤.`;
      }

      if(currentScore > bestScore){
        bestScore = currentScore;
        if(window.saveBestScoreToFirebase) window.saveBestScoreToFirebase(bestScore);
        bump(gpBestBadgeEl);
      }
      updateScoreUI();

      btnMain.textContent = (gameRound >= TOTAL_ROUNDS) ? 'ìµœì¢… ê²°ê³¼' : 'ë‹¤ìŒ ë¼ìš´ë“œ';
      btnMain.disabled = false;
      gameState = 'feedback';
      setControlsEnabled({L:false,C:false,R:false,f:false,lock:false,vis:true});
      setMaskedHud(false);
    }

    // button wiring
    btnMain.addEventListener('click', ()=>{
      if(gameState === 'idle' || gameState === 'finished'){
        startNewGame();
        return;
      }
      if(gameState === 'feedback'){
        // next
        nextRound();
        return;
      }
      // question
      if(roundType === 'seek' || roundType === 'seek_mid') submitSeek();
      else if(roundType === 'tune_amp') submitTuneAmp();
    });

    btnNarrow.addEventListener('click', ()=>answerQ(true));
    btnWide.addEventListener('click', ()=>answerQ(false));

    // movement count (6~8)
    FSlider.addEventListener('input', ()=>{
      if(gameState !== 'question') return;
      // âœ… 6~10 ë¼ìš´ë“œ ì¡°ì‘ ì œí•œ ì œê±°: fëŠ” ì–¸ì œë“  ì¡°ì ˆ ê°€ëŠ¥, íŒì •ì€ 'ì œì¶œ'ë¡œë§Œ ì§„í–‰
      updateHintUI();
      if(roundType === 'tune_amp') updateGoalUI();
    });

        // keep hint/goal updated
    [LSlider,CSlider,RSlider,FSlider].forEach(sl=>{
      sl.addEventListener('input', ()=>{
        if(gameState !== 'question') return;
        if(roundType === 'seek') updateHintUI();
        if(roundType === 'tune_amp'){ updateGoalUI(); updateHintUI(); }
      });
    });

    // init panel
    updateScoreUI();
    updateRoundUI();
    setPanelForRound();

    function refresh(){ updateFSliderRange(); updateCoilGeom(); }
    LSlider.addEventListener('input', refresh);
    CSlider.addEventListener('input', refresh);
    LockChk.addEventListener('change', refresh);
  })();
  </script>

  <!-- ===== Firebase ìµœê³ ì ìˆ˜ ì—°ë™ (RLC ê³µëª…) ===== -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCO36JgPpNz8swADxTMVJUFVALWM5o171w",
      authDomain: "simulation-67cd3.firebaseapp.com",
      projectId: "simulation-67cd3",
      storageBucket: "simulation-67cd3.appspot.com",
      messagingSenderId: "615983461615",
      appId: "1:615983461615:web:002e07bcea878eb6d5571a",
      measurementId: "G-9RGN7LYE5W"
    };

    const app  = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db   = getFirestore(app);

    const SIM_ID = "RLC_ê³µëª…";

    let firebaseUser = null;

    async function saveBestScore(score){
      if(!firebaseUser) return;
      try{
        const ref = doc(db, "users", firebaseUser.uid, "simulations", SIM_ID);
        await setDoc(ref, { score: Number(score)||0 }, { merge:true });
      }catch(err){
        console.error("[RLC ê³µëª…] ìµœê³  ì ìˆ˜ ì €ì¥ ì˜¤ë¥˜:", err);
      }
    }

    async function loadBestScore(){
      if(!firebaseUser) return;
      try{
        const ref = doc(db, "users", firebaseUser.uid, "simulations", SIM_ID);
        const snap = await getDoc(ref);
        if(snap.exists()){
          const data = snap.data();
          const score = Number(data.score||0)||0;
          if(window.setBestScoreFromFirebase) window.setBestScoreFromFirebase(score);
        }
      }catch(err){
        console.error("[RLC ê³µëª…] ìµœê³  ì ìˆ˜ ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜:", err);
      }
    }

    window.saveBestScoreToFirebase = saveBestScore;

    onAuthStateChanged(auth, async (user)=>{
      firebaseUser = user;
      if(user) await loadBestScore();
    });
  </script>

</body>
</html>
