<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>광다이오드 직관 시뮬레이션 | 왕왕물리시뮬레이션</title>
<style>
  :root{ 
    --bg:#fdfdfd; 
    --ink:#111827; 
    --muted:#6b7280; 
    --card:#f9fafb; 
    --brand:#4ade80; 
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:system-ui, Segoe UI, Roboto, Noto Sans KR, sans-serif}
  .wrap{max-width:900px;margin:28px auto;padding:0 16px}
  h1{margin:0 0 12px}
  .panel,.stage{
    background:var(--card);
    border:1px solid #e5e7eb;
    border-radius:14px;
    box-shadow:0 4px 12px rgba(0,0,0,.08)
  }
  .panel{padding:14px;margin-bottom:12px}
  .row{display:grid;grid-template-columns:120px 1fr 90px;gap:10px;align-items:center}
  .row3{display:grid;grid-template-columns:120px 1fr 120px;gap:10px;align-items:center;margin-top:10px}
  input[type="range"], select{width:100%}
  output, .pill{
    background:#fff;border:1px solid #d1d5db;border-radius:10px;padding:6px 10px;text-align:center;
    font-variant-numeric:tabular-nums; color:var(--ink)
  }
  .hint{color:var(--muted);font-size:12px;margin-top:8px;line-height:1.5}
  .stage{padding:12px}
  .sim{aspect-ratio:16/9;border-radius:10px;overflow:hidden;background:#fff;position:relative}
  canvas{display:block;width:100%;height:100%}
  .legend{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px;color:var(--muted);font-size:12px}
  .legend i{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;vertical-align:-1px}
  .brand{
    margin:18px auto 36px;
    text-align:center;
    color:var(--brand);
    font-weight:800;
    letter-spacing:.02em;
    text-shadow:0 1px 4px rgba(74,222,128,.25)
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>광다이오드 (정·역바이어스 직관)</h1>

  <div class="panel">
    <div class="row">
      <label for="bias">전압 V (–5 ~ +5 V)</label>
      <input id="bias" type="range" min="-5" max="5" step="0.1" value="0" />
      <output id="vOut">0.0 V</output>
    </div>

    <div class="row3">
      <label for="color">LED 색상</label>
      <select id="color">
        <option value="ir">적외(IR, 850 nm)</option>
        <option value="red" selected>적색(625 nm)</option>
        <option value="amber">호박(590 nm)</option>
        <option value="green">녹색(530 nm)</option>
        <option value="blue">청색(470 nm)</option>
        <option value="uv">자외(UV, 395 nm)</option>
        <option value="white">백색</option>
      </select>
      <output id="vfOut">Vf ≈ 2.0 V</output>
    </div>

    <div class="hint" id="hint">
      • <b>+V(정방향)</b> → 공핍층 좁아짐, <b>V ≥ Vf</b>일 때 <b>빛 방출</b><br>
      • <b>–V(역방향)</b> → 공핍층 넓어짐, <b>광자 미방출</b><br>
      • 파장이 짧을수록 에너지가 커서 Vf ↑
    </div>
  </div>

  <div class="stage">
    <div class="sim"><canvas id="sim"></canvas></div>
    <div class="legend">
      <span><i style="background:#d1d5db"></i>도핑 영역(p–n)</span>
      <span><i style="background:#facc15"></i>공핍층(폭이 전압에 따라 변화)</span>
      <span><i style="background:#34d399"></i>정방향 시 광자 방출</span>
    </div>
  </div>

  <div class="brand">왕왕물리시뮬레이션</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('sim');
  const ctx = canvas.getContext('2d');
  const $bias = document.getElementById('bias');
  const $vOut = document.getElementById('vOut');
  const $color = document.getElementById('color');
  const $vfOut = document.getElementById('vfOut');
  const $hint = document.getElementById('hint');

  // LED 색상별 대표 파라미터 (교육용 근사치)
  // vf: 대표 순방향 전압(10~20mA급), hue: 광자 색상, name: 표기, lam: 파장
  const COLOR_PROFILES = {
    ir:    { vf: 1.2,  hue: 'rgba(255,90,90,',  name:'적외(IR)',  lam:'850 nm' },
    red:   { vf: 2.0,  hue: 'rgba(255,80,80,',  name:'적색',       lam:'625 nm' },
    amber: { vf: 2.1,  hue: 'rgba(255,180,60,', name:'호박',       lam:'590 nm' },
    green: { vf: 2.9,  hue: 'rgba(110,231,183,',name:'녹색',       lam:'530 nm' },
    blue:  { vf: 3.2,  hue: 'rgba(100,160,255,',name:'청색',       lam:'470 nm' },
    uv:    { vf: 3.4,  hue: 'rgba(180,140,255,',name:'자외(UV)',  lam:'395 nm' },
    white: { vf: 3.1,  hue: 'rgba(255,255,220,',name:'백색',       lam:'(청색칩+형광체)' },
  };
  let current = COLOR_PROFILES[$color.value];

  let V = +$bias.value;   // -5 ~ +5
  let W=0, H=0;
  const photons = [];

  // 공핍층 모델 (교육용)
  const BASE_DEPL = 0.18; // 폭 비율(캔버스 폭 대비)
  const K = 0.06;         // 전압에 따른 변화 민감도

  // 크기 설정
  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    canvas.width = W = Math.round(rect.width * dpr);
    canvas.height = H = Math.round(rect.height * dpr);
    ctx.setTransform(1,0,0,1,0,0);
  }
  window.addEventListener('resize', resize);

  // ‘광자’ 스폰 (정방향에서만, V >= Vf 조건)
  function spawn(dt){
    if (V <= 0) return;
    const over = Math.max(0, V - current.vf);   // 임계 초과분
    if (over <= 0) return;                      // 임계 전까지는 방출 X

    // +5V에서 초당 60개 → 임계 초과분에 비례시킴
    // over=0일 때 0, over≈(5 - vf)일 때 ~60
    const maxOver = Math.max(0.5, 5 - current.vf);
    const rate = 60 * (over / maxOver);
    let want = rate * dt;
    let n = Math.floor(want); if (Math.random() < want - n) n++;

    for (let i=0;i<n;i++){
      photons.push({
        x: W*0.5, y: H*0.5 + (Math.random()-0.5)*H*0.25,
        vx: (W*0.25) + Math.random()*W*0.15,
        vy: (Math.random()-0.5)*40,
        life: 0, maxLife: 1.1 + Math.random()*0.7
      });
    }
    // 제한
    if (photons.length > 500) photons.splice(0, photons.length - 500);
  }

  function step(dt){
    for (let i=photons.length-1;i>=0;i--){
      const p = photons[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life += dt;
      if (p.life > p.maxLife || p.x > W*0.95) photons.splice(i,1);
    }
  }

  function drawJunction(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);

    // 배경
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = "#000"; ctx.fillRect(0,0,W,H);

    // p/n 영역 박스
    const left = W*0.15, right=W*0.85, top=H*0.22, bottom=H*0.78;
    const mid = (left + right)/2;

    // p영역
    ctx.fillStyle = "#374151";
    ctx.fillRect(left, top, (mid-left)-2, bottom-top);
    // n영역
    ctx.fillStyle = "#0f172a";
    ctx.fillRect(mid+2, top, (right-mid)-2, bottom-top);

    // 공핍층 폭 계산
    const raw = BASE_DEPL * W * (1 - K * V);
    const depl = Math.max(W*0.06, Math.min(W*0.35, raw)); // 클램프
    const dL = mid - depl/2, dR = mid + depl/2;

    // 공핍층
    const grad = ctx.createLinearGradient(dL,0,dR,0);
    grad.addColorStop(0,"rgba(251,191,36,0.20)");
    grad.addColorStop(0.5,"rgba(251,191,36,0.35)");
    grad.addColorStop(1,"rgba(251,191,36,0.20)");
    ctx.fillStyle = grad;
    ctx.fillRect(dL, top, depl, bottom-top);

    // 내부 라벨
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // P / N 라벨
    ctx.fillStyle = "#9aa0a6";
    ctx.font = `${Math.round(18*dpr)}px system-ui`;
    ctx.fillText("P", (left + mid) / 2, (top + bottom) / 2);
    ctx.fillText("N", (mid + right) / 2, (top + bottom) / 2);

    // 공핍층 라벨 (반투명 노란색)
    ctx.fillStyle = "rgba(251,191,36,0.7)";
    ctx.font = `600 ${Math.round(18*dpr)}px system-ui`;
    ctx.fillText("공핍층", mid, (top + bottom) / 2);

    // 전압 방향 표시 (굵기+길이 가변)
    ctx.strokeStyle = V>=0 ? "rgba(110,231,183,0.8)" : "rgba(147,197,253,0.8)";
    ctx.lineWidth = 8;

    const trackLen = right - left;
    const maxLen = Math.min(120*dpr, trackLen * 0.6);
    const baseLen = 30*dpr;
    const len = baseLen + (Math.abs(V)/5) * (maxLen - baseLen);

    const head = Math.max(10*dpr, 1.5 * ctx.lineWidth);
    ctx.beginPath();
    const axY = top - 16*dpr;

    if (V>=0){
      ctx.moveTo(left, axY);
      ctx.lineTo(left + len, axY);
      ctx.moveTo(left + len - head, axY - head*0.66);
      ctx.lineTo(left + len, axY);
      ctx.lineTo(left + len - head, axY + head*0.66);
    }else{
      ctx.moveTo(right, axY);
      ctx.lineTo(right - len, axY);
      ctx.moveTo(right - len + head, axY - head*0.66);
      ctx.lineTo(right - len, axY);
      ctx.lineTo(right - len + head, axY + head*0.66);
    }
    ctx.stroke();

    // 상태 텍스트
    ctx.fillStyle = "#e5e7eb";
    ctx.font = `${Math.round(12*dpr)}px system-ui`;
    let status;
    if (V > 0) {
      if (V >= current.vf) status = `정방향 (+V): V ≥ Vf(≈${current.vf.toFixed(1)}V) → 방출 시작`;
      else status = `정방향 (+V): V < Vf(≈${current.vf.toFixed(1)}V) → 방출 없음`;
    } else if (V < 0) {
      status = "역방향 (−V): 공핍층 ⬆, 빛 없음";
    } else {
      status = "0 V: 거의 변화 없음";
    }
    ctx.fillText(`${status} | 선택: ${current.name} ${current.lam}`, left, bottom + 18*dpr);
  }

  function drawPhotons(){
    if (V <= 0 || V < current.vf) return;
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    for (const p of photons){
      const t = p.life / p.maxLife;
      const alpha = Math.max(0, 1 - t);
      // 선택한 색상에 맞는 광자 색
      ctx.fillStyle = `${current.hue}${0.85*alpha})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 2.4*dpr, 0, Math.PI*2);
      ctx.fill();

      // 꼬리
      ctx.strokeStyle = `${current.hue}${0.38*alpha})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(p.x - p.vx*0.02, p.y - p.vy*0.02);
      ctx.lineTo(p.x, p.y);
      ctx.stroke();
    }
  }

  function loop(){
    const now = performance.now();
    const dt = Math.min(0.05, (now - (loop._last||now))/1000);
    loop._last = now;

    spawn(dt);
    step(dt);
    drawJunction();
    drawPhotons();

    requestAnimationFrame(loop);
  }

  // UI
  function refreshUITexts(){
    $vOut.textContent = V.toFixed(1) + " V";
    $vfOut.textContent = `Vf ≈ ${current.vf.toFixed(1)} V`;
    $hint.innerHTML =
      `• <b>+V(정방향)</b> → 공핍층 좁아짐, <b>V ≥ Vf</b>일 때 <b>빛 방출</b> 시작 (색에 따라 Vf 다름)<br>` +
      `• <b>–V(역방향)</b> → 공핍층 넓어짐, <b>광자 미방출</b><br>` +
      `• 참고: 대략적으로 <i>E = hc/λ</i> 이므로 파장이 짧을수록(청·자외) 에너지가 커서 대표 Vf가 큽니다.`;
  }

  $bias.addEventListener('input', e=>{
    V = +e.target.value;
    refreshUITexts();
  });
  $color.addEventListener('change', e=>{
    current = COLOR_PROFILES[e.target.value];
    // 색 바꾸면 기존 광자 잔상 정리
    photons.length = 0;
    refreshUITexts();
  });

  // 시작
  function init(){
    resize();
    refreshUITexts();
    requestAnimationFrame(loop);
  }
  init();
})();
</script>
</body>
</html>
