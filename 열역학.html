<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ì—´ê¸°ê´€ ê³¼ì • ì‹œë®¬ë ˆì´í„° (ê²Œì´ë¯¸í”¼ì¼€ì´ì…˜)</title>

<!-- ë¡œì»¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ -->
<script src="./libs/p5.min.js"></script>
<script src="./libs/three.min.js"></script>

<style>
:root{
  --bg:#f4f9ff;
  --panel:#fff;
  --ink:#0f172a;
  --muted:#5b657a;
  --accent:#2563eb;
  --border:#e6eef9;
  --radius:18px;
  --shadow:0 10px 30px rgba(15,23,42,.08);
}
*{box-sizing:border-box}
body{
  margin:0;
  background:radial-gradient(1200px 800px at 10% -10%,#eef6ff 0%,#f4f9ff 50%,#edf4ff 100%);
  color:var(--ink);
  font:15px/1.55 -apple-system,system-ui,Segoe UI,Roboto,Pretendard,"Noto Sans KR",sans-serif;
}
header{padding:14px 18px}
header h1{margin:0;font-size:20px;font-weight:700}
#app{
  display:grid;
  grid-template-columns:minmax(420px,1.2fr) minmax(520px,1fr);
  gap:22px;
  padding:14px 18px 28px;
}
.card{
  background:var(--panel);
  border:1px solid var(--border);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  overflow:hidden;
}
.card h2{
  margin:0;
  padding:12px 14px;
  font-size:16px;
  border-bottom:1px solid var(--border);
  background:#f8fbff;
}
#threeWrap{position:relative;height:520px}
#threeContainer{width:100%;height:100%}
.hudBox{
  position:absolute;
  left:12px;
  top:12px;
  z-index:5;
  padding:8px 12px;
  border-radius:12px;
  border:1px solid var(--border);
  font-weight:800;
  letter-spacing:.2px;
  box-shadow:var(--shadow);
  pointer-events:none;
  backdrop-filter:blur(2px);
}
#controls{
  padding:12px 14px;
  display:grid;
  gap:10px;
}
.row{
  display:grid;
  grid-template-columns:100px 1fr 90px;
  align-items:center;
  gap:10px;
}
input[type=range]{width:100%}
select,.pill{
  background:#f7fbff;
  border:1px solid var(--border);
  border-radius:12px;
  padding:8px 10px;
}
.pill{
  display:inline-flex;
  gap:8px;
  align-items:center;
}
.disabled{opacity:.45;filter:saturate(.2)}
#readouts{
  display:grid;
  grid-template-columns:repeat(3,1fr);
  gap:10px;
  padding:10px 14px 16px;
}
.stat{
  background:#f9fbff;
  border:1px solid var(--border);
  border-radius:14px;
  padding:10px 12px;
}
.stat b{
  display:block;
  font-size:12px;
  color:var(--muted);
  margin-bottom:6px;
}
.stat span{
  font-weight:700;
  font-variant-numeric:tabular-nums;
  font-size:16px;
}
#pvCard{
  display:grid;
  grid-template-rows:auto auto 1fr auto;
}
#pvPanel{height:320px}
#legend{
  display:flex;
  gap:12px;
  align-items:center;
  padding:8px 12px;
  border-top:1px solid var(--border);
  background:#f8fbff;
}
.dot{width:12px;height:12px;border-radius:50%}
.kpa{color:#2563eb}
.L{color:#059669}

/* ====== ë„ì „ ëª¨ë“œ UI ====== */
.challengeBox{
  margin:0 12px 10px;
  padding:8px 10px 6px;
  border-radius:14px;
  border:1px dashed #cbd5f5;
  background:#f9fbff;
}
.challengeTop{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  align-items:center;
  margin-bottom:4px;
}
.challengeTitle{
  font-size:13px;
  font-weight:600;
}
.challengeBtn{
  border-radius:999px;
  border:1px solid #bfdbfe;
  background:#eff6ff;
  padding:5px 10px;
  font-size:12px;
  cursor:pointer;
}
.challengeBtn:disabled{
  opacity:0.5;
  cursor:default;
}
.challengeStats{
  display:flex;
  flex-wrap:wrap;
  gap:10px;
  font-size:12px;
  color:#4b5563;
  margin-bottom:3px;
}
.bestScoreBox{
  margin-left:auto;
  display:flex;
  align-items:center;
  gap:4px;
  font-size:24px;
}
.bestScoreBox .bestIcon{
  font-size:24px;
  filter:drop-shadow(0 0 4px rgba(255,200,0,.7));
}
.bestScoreBox .bestValue{
  font-size:24px;
  font-weight:700;
  color: #facc15;
  text-shadow: 0 0 8px #fef08a, 0 0 14px #facc15;
}
.challengeChoices{
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  margin:4px 0 2px;
}
.choiceBtn{
  border-radius:999px;
  border:1px solid #d4d4ff;
  background:#eef2ff;
  padding:4px 10px;
  font-size:12px;
  cursor:pointer;
}
.choiceBtn:disabled{
  opacity:0.5;
  cursor:default;
}
.choiceBtn.primary{
  background:#2563eb;
  border-color:#1d4ed8;
  color:#fff;
}
.challengeMsg{
  font-size:11px;
  color:#6b7280;
  min-height:18px;
  margin-top:3px;
}

/* ì‘ì€ í™”ë©´ ëŒ€ì‘ */
@media (max-width:980px){
  #app{
    grid-template-columns:1fr;
  }
  #threeWrap{height:420px}
}
@media (max-width:640px){
  #controls .row{
    grid-template-columns:90px 1fr 80px;
  }
}
</style>
</head>
<body>
<header><h1>ì—´ê¸°ê´€ ê³¼ì • ì‹œë®¬ë ˆì´í„°</h1></header>

<div id="app">
  <div class="card" id="threeCard">
    <h2>í”¼ìŠ¤í†¤ + ê¸°ì²´ ì…ì</h2>
    <div id="threeWrap">
      <div id="threeContainer"></div>
      <div id="pressureHud" class="hudBox">P = -- kPa</div>
    </div>
    <div id="readouts">
      <div class="stat"><b>ì••ë ¥ P</b><span id="Pout">-</span> <small class="kpa">kPa</small></div>
      <div class="stat"><b>ë¶€í”¼ V</b><span id="Vout">-</span> <small class="L">L</small></div>
      <div class="stat"><b>ì˜¨ë„ T</b><span id="Tout">-</span> <small>K</small></div>
    </div>
  </div>

  <div class="card" id="pvCard">
    <h2>ê³¼ì • ì„ íƒ / ì¡°ì‘ &nbsp;<span class="pill">n=0.04 mol</span></h2>

    <div id="controls">
      <div class="row">
        <label for="mode">ê³¼ì •</label>
        <select id="mode">
          <option value="isochoric">ë“±ì  (V ì¼ì •)</option>
          <option value="isobaric">ë“±ì•• (P ì¼ì •)</option>
          <option value="isothermal">ë“±ì˜¨ (T ì¼ì •)</option>
          <option value="adiabatic">ë‹¨ì—´ (Q=0)</option>
        </select>
        <span></span>
      </div>
      <div class="row" id="pistonRow">
        <label>í”¼ìŠ¤í†¤</label>
        <input type="range" id="piston" min="0.05" max="0.25" step="0.001" />
        <span id="pistonLbl">0.150 m</span>
      </div>
      <div class="row" id="tempRow">
        <label>ì˜¨ë„ T</label>
        <input type="range" id="temp" min="150" max="600" step="1" />
        <span id="tempLbl">300 K</span>
      </div>
      <div class="row">
        <label>ê·¸ë˜í”„</label>
        <span class="pill">
          <input type="checkbox" id="showRefs" checked />
          <label for="showRefs">ì°¸ê³  ë“±ì˜¨ì„  (Tâ†“/Tâ†‘)</label>
        </span>
        <span></span>
      </div>
    </div>

    <!-- ===== ë„ì „ ëª¨ë“œ ë°•ìŠ¤ ===== -->
    <div class="challengeBox">
      <div class="challengeTop">
        <div class="challengeTitle">ë„ì „ ëª¨ë“œ</div>
        <button id="btnChallengeStart" class="challengeBtn">ë„ì „ ì‹œì‘</button>
        <div style="font-size:11px;color:#6b7280;">ì´ 10ë¼ìš´ë“œ Â· ì •ë‹µë‹¹ 50ì </div>
      </div>
      <div class="challengeStats">
        <div>ë¼ìš´ë“œ: <b><span id="chRound">-</span> / 10</b></div>
        <div>ì ìˆ˜: <b><span id="chScore">0</span>ì </b></div>
        <div class="bestScoreBox">
          <span>ìµœê³ ì ìˆ˜</span>
          <span class="bestIcon">ğŸ†</span>
          <span id="chBest" class="bestValue">0</span>
        </div>
      </div>
      <div class="challengeChoices">
        <!-- 1~5ë¼ìš´ë“œ: ê³¼ì • ì´ë¦„ ë§ì¶”ê¸° -->
        <button class="choiceBtn" data-answer="adiabatic">ë‹¨ì—´</button>
        <button class="choiceBtn" data-answer="isothermal">ë“±ì˜¨</button>
        <button class="choiceBtn" data-answer="isobaric">ë“±ì••</button>
        <button class="choiceBtn" data-answer="isochoric">ë“±ì </button>

        <!-- 6~10ë¼ìš´ë“œ: ë”°ë¼ ê·¸ë¦¬ê¸° ì™„ë£Œ ë²„íŠ¼ -->
        <button id="btnCopyDone" class="choiceBtn primary" style="margin-left:auto;">ê·¸ë¦¬ê¸° ì™„ë£Œ</button>
      </div>
      <div id="chMessage" class="challengeMsg">
        ë„ì „ ì‹œì‘ ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ì£¼í™©ìƒ‰ ì˜ˆì‹œ ê³¡ì„ ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤.
      </div>
    </div>

    <div id="pvPanel"></div>
    <div id="legend">
      <div class="dot" style="background:#2563eb"></div><small>í˜„ì¬ ê¶¤ì </small>
      <div class="dot" style="background:#f97316"></div><small>ë„ì „ìš© ëª©í‘œ ê³¡ì„ </small>
      <div class="dot" style="background:#10b981"></div><small>ì°¸ê³  ë“±ì˜¨ì„ </small>
      <div style="margin-left:auto"></div>
      <small>Q=<span id="Qout">0.00</span> J,&nbsp; W=<span id="Wout">0.00</span> J,&nbsp; Î”U=<span id="DUout">0.00</span> J</small>
    </div>
  </div>
</div>

<script>
/* ===== ìƒìˆ˜/ìƒíƒœ ===== */
const R=8.314,n=0.04,Cv=1.5*R,Cp=2.5*R,gamma=5/3;
const r=0.05,A=Math.PI*r*r,hLim={min:0.05,max:0.25},TLim={min:150,max:600};
let state={
  mode:'isochoric',
  h:0.15,T:300,
  P:0,V:0,
  Pc:null,Tc:null,Vc:null,
  adi_Tc:null,adi_Pc:null,
  Q:0,W:0,
  U:n*Cv*300,U0:null,
  last:null,
  Area:A
};

const $=id=>document.getElementById(id);
const modeSel=$('mode'), piston=$('piston'), temp=$('temp'), pistonLbl=$('pistonLbl'), tempLbl=$('tempLbl');
const Pout=$('Pout'), Vout=$('Vout'), Tout=$('Tout'), Qout=$('Qout'), Wout=$('Wout'), DUout=$('DUout');
const hud=$('pressureHud');

const V=h=>A*h, P=(T,V)=>n*R*T/V, clamp=(x,a,b)=>Math.max(a,Math.min(b,x));

/* ===== Three.js ===== */
let scene,camera,renderer,pistonMesh,rod,particles=[],lastT=state.T,gasMat;

/* ì»¤ìŠ¤í…€ ì¹´ë©”ë¼ ì»¨íŠ¸ë¡¤ */
let camTarget=new THREE.Vector3(0,0.08,0);
let sph={r:0.62, theta:Math.atan2(0.56,0.32), phi:Math.acos(0.18/0.62)};
const sphLim={r:[0.28,1.6], phi:[0.05,Math.PI*0.49]};
let isDrag=false, lastX=0, lastY=0;

function applySpherical(){
  const {r,theta,phi}=sph;
  const sinP=Math.sin(phi), cosP=Math.cos(phi);
  const x=r*sinP*Math.cos(theta), y=r*cosP, z=r*sinP*Math.sin(theta);
  camera.position.set(camTarget.x+x, camTarget.y+y, camTarget.z+z);
  camera.lookAt(camTarget);
}

function init3D(){
  const ctn=$('threeContainer'), w=ctn.clientWidth||720, h=ctn.clientHeight||520;
  scene=new THREE.Scene();
  scene.background=new THREE.Color(0xf2f7ff);
  camera=new THREE.PerspectiveCamera(35,w/h,0.01,10);
  renderer=new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(w,h,false);
  ctn.appendChild(renderer.domElement);

  scene.add(new THREE.AmbientLight(0xffffff,.8));
  const d=new THREE.DirectionalLight(0xffffff,.85);
  d.position.set(1,1.2,1.2);
  scene.add(d);

  const floor=new THREE.Mesh(
    new THREE.CylinderGeometry(0.35,0.35,0.01,64),
    new THREE.MeshStandardMaterial({color:0xe8eefc,roughness:.9,metalness:.1})
  );
  floor.position.y=-0.005;
  scene.add(floor);

  const wall=new THREE.Mesh(
    new THREE.CylinderGeometry(r,r,hLim.max+0.02,48,1,true),
    new THREE.MeshPhysicalMaterial({
      color:0x79b6ff,
      transparent:true,
      opacity:.1,
      roughness:.1,
      thickness:1.2,
      transmission:.85
    })
  );
  wall.position.y=hLim.max/2;
  scene.add(wall);

  const bottom=new THREE.Mesh(
    new THREE.CylinderGeometry(r,r,0.01,48),
    new THREE.MeshStandardMaterial({color:0xcad7fb,metalness:.4,roughness:.3})
  );
  bottom.position.y=0;
  scene.add(bottom);

  pistonMesh=new THREE.Mesh(
    new THREE.CylinderGeometry(r*1.005,r*1.005,0.01,48),
    new THREE.MeshStandardMaterial({color:0x93b4ff,metalness:.7,roughness:.25})
  );
  pistonMesh.position.y=state.h;
  scene.add(pistonMesh);

  rod=new THREE.Mesh(
    new THREE.CylinderGeometry(0.006,0.006,0.3,24),
    new THREE.MeshStandardMaterial({color:0xa1b7ff,metalness:.9,roughness:.2})
  );
  rod.position.set(0,state.h+0.15,0);
  scene.add(rod);

  initParticles(70);
  applySpherical();

  window.addEventListener('resize',()=>{
    const w=ctn.clientWidth||720,h=ctn.clientHeight||520;
    camera.aspect=w/h;
    camera.updateProjectionMatrix();
    renderer.setSize(w,h,false);
  });

  const dom=renderer.domElement;
  dom.addEventListener('pointerdown',e=>{
    isDrag=true; lastX=e.clientX; lastY=e.clientY;
    dom.setPointerCapture(e.pointerId);
  });
  dom.addEventListener('pointermove',e=>{
    if(!isDrag) return;
    const dx=(e.clientX-lastX), dy=(e.clientY-lastY);
    lastX=e.clientX; lastY=e.clientY;
    sph.theta -= dx*0.005;
    sph.phi   -= dy*0.005;
    sph.phi = clamp(sph.phi, sphLim.phi[0], sphLim.phi[1]);
  });
  dom.addEventListener('pointerup',e=>{
    isDrag=false;
    dom.releasePointerCapture(e.pointerId);
  });
  dom.addEventListener('wheel',e=>{
    e.preventDefault();
    const scale=Math.exp(e.deltaY*0.001);
    sph.r=clamp(sph.r*scale, sphLim.r[0], sphLim.r[1]);
  }, {passive:false});
}

function initParticles(N){
  particles.length=0;
  const geom=new THREE.SphereGeometry(0.005,16,16);
  gasMat=new THREE.MeshStandardMaterial({color:0xffffff,emissive:0x000000,roughness:.3,metalness:.1});
  setGasColor(state.T);
  for(let i=0;i<N;i++){
    const m=new THREE.Mesh(geom,gasMat);
    const rr=Math.sqrt(Math.random())*(r-0.006), th=Math.random()*Math.PI*2;
    m.position.set(rr*Math.cos(th), 0.01+Math.random()*(state.h-0.02), rr*Math.sin(th));
    const vS=0.25*Math.sqrt(state.T/300);
    const dir=new THREE.Vector3(Math.random()*2-1,Math.random()*2-1,Math.random()*2-1).normalize();
    m.userData.v=dir.multiplyScalar(vS*(0.4+0.6*Math.random()));
    particles.push(m);
    scene.add(m);
  }
}
function setGasColor(T){
  const t=(T-TLim.min)/(TLim.max-TLim.min);
  const h=0.66*(1-Math.max(0,Math.min(1,t)));
  gasMat.color.setHSL(h,1.0,0.52);
  gasMat.emissive.setHSL(h,0.7,0.35);
}

/* HUD(ì••ë ¥) */
function updatePressureHud(PkPa){
  const t=Math.max(0,Math.min(1, PkPa/300));
  const hue=210*(1-t);
  const bg=`hsl(${hue}deg 85% 55%)`;
  const border=`hsl(${hue}deg 70% 42%)`;
  const textDark = t < 0.45;
  hud.style.backgroundColor=bg;
  hud.style.borderColor=border;
  hud.style.color=textDark ? '#0f172a' : '#ffffff';
  hud.textContent=`P = ${PkPa.toFixed(1)} kPa`;
}

function animate(){
  requestAnimationFrame(animate);
  const dt=0.016,Rw=r-0.006,y0=0.006,y1=state.h-0.006;
  for(const p of particles){
    const v=p.userData.v;
    p.position.addScaledVector(v,dt);
    const rad=Math.hypot(p.position.x,p.position.z);
    if(rad>Rw){
      const nx=p.position.x/rad,nz=p.position.z/rad;
      const vd=v.x*nx+v.z*nz;
      v.x-=2*vd*nx; v.z-=2*vd*nz;
      const k=Rw/rad; p.position.x*=k; p.position.z*=k;
    }
    if(p.position.y<y0){ p.position.y=y0; v.y=Math.abs(v.y); }
    if(p.position.y>y1){ p.position.y=y1; v.y=-Math.abs(v.y); }
  }
  pistonMesh.position.y=state.h;
  rod.position.y=state.h+0.15;

  applySpherical();
  renderer.render(scene,camera);
}

/* ===== ìƒíƒœ ê°±ì‹  ë¡œì§ ===== */
function reset(mode, options){
  options = options || {};
  const resetPVFlag   = options.resetPV   !== false; // ê¸°ë³¸ê°’: true
  const resetEnergy   = options.resetEnergy !== false; // ê¸°ë³¸ê°’: true

  state.mode = mode;
  state.V    = V(state.h);
  state.P    = P(state.T, state.V);

  state.Pc   = (mode==='isobaric')   ? state.P : null;
  state.Tc   = (mode==='isothermal') ? state.T : null;
  state.Vc   = (mode==='isochoric')  ? state.V : null;

  if(mode==='adiabatic'){
    state.adi_Tc = state.T*Math.pow(state.V,gamma-1);
    state.adi_Pc = state.P*Math.pow(state.V,gamma);
  }else{
    state.adi_Tc = state.adi_Pc = null;
  }

  piston.disabled = (mode==='isochoric');
  temp.disabled   = (mode==='isothermal' || mode==='adiabatic');
  $('pistonRow').classList.toggle('disabled', piston.disabled);
  $('tempRow').classList.toggle('disabled', temp.disabled);

  if(resetEnergy){
    state.Q  = 0;
    state.W  = 0;
    state.U  = n*Cv*state.T;
    state.U0 = state.U;
  }

  state.last = { P:state.P, V:state.V, T:state.T };

  if(resetPVFlag && window.resetPV){
    window.resetPV();
  }

  rescaleV(state.T);
  updatePressureHud(state.P/1000);
  readouts();
}

function step(changed){
  let Vn=V(state.h), Tn=state.T, Pn=P(Tn,Vn);
  if(state.mode==='isochoric'){
    Vn=state.Vc;
    state.h=Vn/(state.Area||A);
    Pn=P(Tn,Vn);
  }else if(state.mode==='isobaric'){
    const P0=state.Pc;
    if(changed==='h'){
      Tn=P0*Vn/(n*R);
      state.T=clamp(Tn,TLim.min,TLim.max);
      if(state.T!==Tn){
        Tn=state.T;
        Vn=n*R*Tn/P0;
        state.h=clamp(Vn/A,hLim.min,hLim.max);
        Vn=V(state.h);
      }
    }else if(changed==='T'){
      Vn=n*R*Tn/P0;
      state.h=clamp(Vn/A,hLim.min,hLim.max);
      Vn=V(state.h);
    }
    Pn=P0;
  }else if(state.mode==='isothermal'){
    Tn=state.Tc;
    state.T=Tn;
    Pn=P(Tn,Vn);
  }else if(state.mode==='adiabatic'){
    Tn=state.adi_Tc/Math.pow(Vn,gamma-1);
    Pn=state.adi_Pc/Math.pow(Vn,gamma);
    state.T=Tn;
  }

  const dV=Vn-state.last.V;
  const dT=Tn-state.last.T;
  let dW=0,dQ=0,dU=n*Cv*dT;

  if(state.mode==='isochoric'){
    dW=0; dQ=dU;
  }else if(state.mode==='isobaric'){
    dW=Pn*dV; dQ=dU+dW;
  }else if(state.mode==='isothermal'){
    dU=0;
    if(Vn>0&&state.last.V>0) dW=n*R*Tn*Math.log(Vn/state.last.V);
    dQ=dW;
  }else{
    dQ=0; dW=-dU;
  }

  state.Q+=dQ; state.W+=dW; state.U+=dU;
  state.P=Pn; state.V=Vn;
  state.last={P:Pn,V:Vn,T:Tn};

  piston.value=state.h;
  pistonLbl.textContent=state.h.toFixed(3)+' m';
  temp.value=state.T;
  tempLbl.textContent=Math.round(state.T)+' K';

  rescaleV(state.T);
  readouts();
  updatePressureHud(state.P/1000);
  window.pushPV && window.pushPV(state.P/1000, state.V*1000);
}

function rescaleV(Tnew){
  const s=Math.sqrt(Tnew/(lastT||Tnew));
  particles.forEach(p=>p.userData.v.multiplyScalar(s));
  setGasColor(Tnew);
  lastT=Tnew;
}
function readouts(){
  Pout.textContent=(state.P/1000).toFixed(1);
  Vout.textContent=(state.V*1000).toFixed(3);
  Tout.textContent=Math.round(state.T);
  Qout.textContent=state.Q.toFixed(2);
  Wout.textContent=state.W.toFixed(2);
  DUout.textContent=(state.U-state.U0).toFixed(2);
}

/* ì…ë ¥ ì—°ê²° */
piston.min=hLim.min; piston.max=hLim.max; piston.step=0.001; piston.value=state.h;
temp.min=TLim.min; temp.max=TLim.max; temp.step=1; temp.value=state.T;
pistonLbl.textContent=state.h.toFixed(3)+' m';
tempLbl.textContent=Math.round(state.T)+' K';
modeSel.addEventListener('change', e => {
  const newMode = e.target.value;

  // ë„ì „ ëª¨ë“œ + ë”°ë¼ ê·¸ë¦¬ê¸°(copy) ë¼ìš´ë“œì—ì„œëŠ”
  // ê¶¤ì /ì—ë„ˆì§€ ì´ˆê¸°í™” ì—†ì´ "ê³¼ì • ìƒìˆ˜"ë§Œ ë°”ê¿”ì£¼ê¸°
  if (GAME.active && GAME.currentMode === 'copy') {
    reset(newMode, { resetPV:false, resetEnergy:false });
  } else {
    // í‰ì†Œì²˜ëŸ¼ ì™„ì „ ì´ˆê¸°í™”
    reset(newMode);
  }
});
piston.addEventListener('input',e=>{state.h=+e.target.value; step('h');});
temp.addEventListener('input',e=>{state.T=+e.target.value; step('T');});

/* ===== p5: PV ê·¸ë˜í”„ + ë„ì „ ê³¡ì„  ===== */
let pvSketch=p=>{
  const pad=48,P_MAX=300;
  let path=[];
  let challengePath=[];      // [{PkPa,VL}]
  let challengeMeta=null;    // {mode:'identify'|'copy'|'cycle', type:'...'}
  const MAX_PATH=1200;

  p.setup=()=>{
    const parent=$('pvPanel');
    const W=parent.clientWidth||560,H=parent.clientHeight||340;
    const c=p.createCanvas(W,H);
    c.parent('pvPanel');
    p.pixelDensity(1);
    p.frameRate(45);
    window.resetPV();
  };
  p.windowResized=()=>{
    const parent=$('pvPanel');
    p.resizeCanvas(parent.clientWidth||560,parent.clientHeight||340);
  };

  const toXY=(PkPa,VL)=>{
    const w=p.width-2*pad,h=p.height-2*pad;
    return {
      x:pad+(VL/2)*w,
      y:p.height-pad-(PkPa/P_MAX)*h
    };
  };
  const axes=()=>{
    p.push();
    p.translate(pad,p.height-pad);
    const w=p.width-2*pad,h=p.height-2*pad;
    p.stroke('#94a3b8'); p.strokeWeight(1.2);
    p.line(0,0,w,0); p.line(0,0,0,-h);
    p.textSize(12); p.noStroke(); p.fill('#475569');
    for(let i=0;i<=10;i++){
      let x=i/10*w;
      p.stroke('#e2e8f0'); p.line(x,0,x,-h);
      p.noStroke(); p.text((0.2*i).toFixed(1),x-8,16);
    }
    for(let i=0;i<=10;i++){
      let y=-i/10*h;
      p.stroke('#e2e8f0'); p.line(0,y,w,y);
      p.noStroke(); p.text((30*i).toFixed(0),-36,y+4);
    }
    p.noStroke();
    p.text('V [L]', w-30,16);
    p.push();
    p.translate(-32,-h+6);
    p.rotate(-Math.PI/2);
    p.text('P [kPa]',0,0);
    p.pop();
    p.pop();
  };

  const iso=(TK,col)=>{
    p.stroke(col);
    p.noFill();
    p.strokeWeight(1.4);
    p.beginShape();
    for(let VL=0.1;VL<=2.0;VL+=0.01){
      const V=VL/1000;
      const Pv=(n*R*TK)/V/1000;
      const {x,y}=toXY(Pv,VL);
      p.vertex(x,y);
    }
    p.endShape();
  };

  function drawChallengeCurve(){
    if(!challengePath.length) return;
    p.stroke('#f97316');
    p.noFill();
    p.strokeWeight(2.3);
    p.beginShape();
    for(const pt of challengePath){
      const {x,y}=toXY(pt.PkPa, pt.VL);
      p.vertex(x,y);
    }
    p.endShape();
  }

  // ê²½ë¡œ push / reset / ë„ì „ ê³¡ì„  ì—°ë™
  window.pushPV=(PkPa,VL)=>{
    const pt=toXY(PkPa,VL);
    path.push({x:pt.x,y:pt.y,PkPa,VL});
    if(path.length>MAX_PATH) path.shift();
  };
  window.resetPV=()=>{
    path.length=0;
    window.pushPV(state.P/1000,state.V*1000);
  };
  window.setChallengeCurve = (pts, meta)=>{
    challengePath = pts || [];
    challengeMeta = meta || null;
  };
  window.clearChallengeCurve = ()=>{
    challengePath.length=0;
    challengeMeta=null;
  };

  // í˜„ì¬ pathì™€ challengePath ìœ ì‚¬ë„ í‰ê°€ (ì •ê·œí™” ì¢Œí‘œ ê¸°ì¤€, ë‚œì´ë„ â†“)
  window.checkChallengeMatch = ()=>{
    if(!challengePath.length || path.length<20) return false;

    const sampleN = 40;
    const norm = arr=>{
      if(!arr.length) return [];
      return arr.map(p=>({
        v:p.VL/2.0,
        p:p.PkPa/300
      }));
    };
    const tArr = norm(challengePath);
    const uArr = norm(path.map(p=>({VL:p.VL,PkPa:p.PkPa})));

    const pickSamples = (arr)=>{
      const res=[];
      for(let i=0;i<sampleN;i++){
        const idx=Math.floor(i*(arr.length-1)/(sampleN-1));
        res.push(arr[idx]);
      }
      return res;
    };
    const T = pickSamples(tArr);
    const U = pickSamples(uArr);

    let sum=0;
    for(let i=0;i<sampleN;i++){
      const dv = T[i].v - U[i].v;
      const dp = T[i].p - U[i].p;
      sum += Math.sqrt(dv*dv+dp*dp);
    }
    const avgErr = sum/sampleN;
    // â˜… ë‚œì´ë„ ì¡°ì •: 0.08 â†’ 0.14 ë¡œ ì™„í™”
window.checkChallengeMatch = ()=>{
  if(!challengePath.length || path.length<20) return false;

  const sampleN = 40;
  const norm = arr=>{
    if(!arr.length) return [];
    return arr.map(p=>({
      v:p.VL/2.0,
      p:p.PkPa/300
    }));
  };
  const tArr = norm(challengePath);
  const uArr = norm(path.map(p=>({VL:p.VL,PkPa:p.PkPa})));

  const pickSamples = (arr)=>{
    const res=[];
    for(let i=0;i<sampleN;i++){
      const idx=Math.floor(i*(arr.length-1)/(sampleN-1));
      res.push(arr[idx]);
    }
    return res;
  };
  const T = pickSamples(tArr);
  const U = pickSamples(uArr);

  let sum=0;
  for(let i=0;i<sampleN;i++){
    const dv = T[i].v - U[i].v;
    const dp = T[i].p - U[i].p;
    sum += Math.sqrt(dv*dv+dp*dp);
  }
  const avgErr = sum/sampleN;

  // â˜… ë¼ìš´ë“œë³„ íŒì • ê¸°ì¤€
  // ê¸°ë³¸: 1~8ë¼ìš´ë“œ â†’ 0.14
  // 9~10ë¼ìš´ë“œ(ì‚¬ì´í´) â†’ 0.22 ë¡œ í›¨ì”¬ ëŠìŠ¨í•˜ê²Œ
  let threshold = 0.14;
  if (window.GAME) {
    const r = window.GAME.round || 0;
    if (r >= 9) {
      threshold = 0.22;
    }
  }

  return avgErr < threshold;
};
  };

  p.draw=()=>{
    p.clear();
    p.noStroke();
    p.fill('#fff');
    p.rect(0,0,p.width,p.height);

    axes();

    // ì°¸ê³  ë“±ì˜¨ì„  (ë…¹ìƒ‰)
    if($('showRefs').checked){
      iso(480,'#22c55e');
      iso(220,'#16a34a');
    }

    // ë„ì „ìš© ëª©í‘œ ê³¡ì„  (ì£¼í™©ìƒ‰)
    drawChallengeCurve();

    // í˜„ì¬ ê¶¤ì 
    if(path.length>1){
      p.stroke('#2563eb');
      p.noFill();
      p.strokeWeight(2.0);
      p.beginShape();
      path.forEach(q=>p.vertex(q.x,q.y));
      p.endShape();
    }

    const {x,y}=(()=>{
      const PkPa=state.P/1000, VL=state.V*1000;
      return toXY(PkPa,VL);
    })();
    p.noStroke();
    p.fill('#2563eb');
    p.circle(x,y,6);
  };
};
new p5(pvSketch);

/* ì‹¤í–‰ */
init3D();
reset('isochoric');
animate();

/* ===== ë„ì „ ëª¨ë“œ ë¡œì§ ===== */
const btnChallengeStart = document.getElementById('btnChallengeStart');
const btnCopyDone       = document.getElementById('btnCopyDone');
const chRoundEl         = document.getElementById('chRound');
const chScoreEl         = document.getElementById('chScore');
const chBestEl          = document.getElementById('chBest');
const chMsgEl           = document.getElementById('chMessage');
const choiceButtons     = Array.from(document.querySelectorAll('.choiceBtn[data-answer]'));

const GAME = {
  active:false,
  round:0,
  totalRounds:10,
  score:0,
  bestScore: Number(localStorage.getItem('thermoEngineBestScore') || 0) || 0,
  currentType:null,   // 'adiabatic' | 'isothermal' | 'isobaric' | 'isochoric' | 'cycle'
  currentMode:null    // 'identify' | 'copy'
};
window.GAME = GAME; // Firebaseì—ì„œ ì ‘ê·¼í•  ìˆ˜ ìˆë„ë¡ ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ

function updateGameUI(){
  chRoundEl.textContent = GAME.active ? GAME.round : '-';
  chScoreEl.textContent = GAME.score;
  chBestEl.textContent  = GAME.bestScore;
}
function setGameMessage(msg, good=false){
  chMsgEl.textContent = msg || '';
  chMsgEl.style.color = good ? '#15803d' : '#6b7280';
}
function setControlsEnabled(enabled){
  modeSel.disabled   = !enabled;
  piston.disabled    = !enabled;
  temp.disabled      = !enabled;
  document.getElementById('showRefs').disabled = !enabled;
  document.getElementById('pistonRow').classList.toggle('disabled',!enabled);
  document.getElementById('tempRow').classList.toggle('disabled',!enabled);
}
function applyCorrectScore(isCorrect){
  if(!GAME.active) return;
  if(isCorrect){
    GAME.score += 50;
    setGameMessage('ì •ë‹µì…ë‹ˆë‹¤! +50ì  ğŸ‰', true);
    if(GAME.score > GAME.bestScore){
      GAME.bestScore = GAME.score;
      localStorage.setItem('thermoEngineBestScore', String(GAME.bestScore));
      if(window.saveBestScoreToFirebase){
        try{ window.saveBestScoreToFirebase(GAME.bestScore); }catch(e){}
      }
    }
  }else{
    setGameMessage('ì•„ì‰½ì§€ë§Œ ì˜¤ë‹µì…ë‹ˆë‹¤. ë‹¤ìŒ ë¼ìš´ë“œë¡œ ë„˜ì–´ê°‘ë‹ˆë‹¤.');
  }
  updateGameUI();
}
function endChallenge(){
  setControlsEnabled(true);
  btnChallengeStart.disabled = false;
  window.clearChallengeCurve && window.clearChallengeCurve();
  setGameMessage(`ë„ì „ ì¢…ë£Œ! ìµœì¢… ì ìˆ˜ëŠ” ${GAME.score}ì ì…ë‹ˆë‹¤.`, true);
  GAME.active=false;
  GAME.round=0;
  GAME.currentType=null;
  GAME.currentMode=null;
  updateGameUI();
}

function generateCurve(type, mode, round){
  const pts  = [];
  const rand = (a,b)=>a+(b-a)*Math.random();

  // í”¼ìŠ¤í†¤/ìŠ¬ë¼ì´ë”ë¡œ ì‹¤ì œ ë„ë‹¬ ê°€ëŠ¥í•œ ë¶€í”¼ ë²”ìœ„ (ë¦¬í„°)
  const V_MIN_L = A * hLim.min * 1000; // ~0.39 L
  const V_MAX_L = A * hLim.max * 1000; // ~1.96 L

  // ì˜¨ë„ ë²”ìœ„ (ìŠ¬ë¼ì´ë”ì™€ ë§ì¶°ì„œ)
  const T_MIN = TLim.min; // 150 K
  const T_MAX = TLim.max; // 600 K

  // ì˜¨ë„ ê³„ì‚°: T = P[kPa] * V[L] / (n R)
  const calcT = (PkPa, VL) => (PkPa * VL) / (n * R);

  // ===== ë“±ì  ê³¼ì • (V = const) =====
  if (type === 'isochoric') {
    const N = (mode === 'identify' ? 60 : 80);
    let Vc, T1, T2;

    for (let attempt = 0; attempt < 50; attempt++) {
      Vc = rand(V_MIN_L * 1.05, V_MAX_L * 0.95);      // ì‚´ì§ ì—¬ìœ 
      T1 = rand(180, 260);
      T2 = rand(360, 540);
      const P1 = (n * R * T1) / Vc;
      const P2 = (n * R * T2) / Vc;
      // ì••ë ¥ì´ ë„ˆë¬´ í¬ê±°ë‚˜ ì‘ì§€ ì•Šë„ë¡
      if (P1 < 40 || P1 > 280 || P2 < 40 || P2 > 280) continue;
      break;
    }

    for (let i = 0; i < N; i++) {
      const t  = i / (N - 1);
      const T  = T1 * (1 - t) + T2 * t;
      const Pk = (n * R * T) / Vc;
      pts.push({ VL: Vc, PkPa: Pk });
    }
  }

  // ===== ë“±ì•• ê³¼ì • (P = const) =====
  else if (type === 'isobaric') {
    const N = (mode === 'identify' ? 60 : 80);
    let Pc, T1, T2, V1, V2;

    for (let attempt = 0; attempt < 50; attempt++) {
      Pc = rand(80, 220);          // kPa
      T1 = rand(190, 260);
      T2 = rand(360, 520);

      V1 = (n * R * T1) / Pc;      // L
      V2 = (n * R * T2) / Pc;

      // í”¼ìŠ¤í†¤ ê°€ëŠ¥í•œ ë¶€í”¼ ë²”ìœ„ ì•ˆì— ë“¤ì–´ê°€ì•¼ í•¨
      if (V1 < V_MIN_L || V1 > V_MAX_L) continue;
      if (V2 < V_MIN_L || V2 > V_MAX_L) continue;

      // ì˜¨ë„ ë²”ìœ„ë„ ìŠ¬ë¼ì´ë” ë²”ìœ„ ì•ˆ
      if (T1 < T_MIN || T1 > T_MAX) continue;
      if (T2 < T_MIN || T2 > T_MAX) continue;

      break;
    }

    for (let i = 0; i < N; i++) {
      const t  = i / (N - 1);
      const V  = V1 * (1 - t) + V2 * t;
      const T  = (n * R * T1 / V1) * (V / Pc); // êµ³ì´ ë‹¤ì‹œ ì¨ë„ ë˜ì§€ë§Œ, ê·¸ëƒ¥ ì„ í˜• ë³´ê°„ìœ¼ë¡œ ì¶©ë¶„
      pts.push({ VL: V, PkPa: Pc });
    }
  }

  // ===== ë“±ì˜¨ ê³¼ì • (T = const) =====
  else if (type === 'isothermal') {
    const N = (mode === 'identify' ? 80 : 100);
    let T0, V1, V2;

    for (let attempt = 0; attempt < 50; attempt++) {
      T0 = rand(220, 480);
      V1 = rand(V_MIN_L * 1.05, V_MAX_L * 0.7);
      V2 = rand(V1 + 0.3, V_MAX_L * 0.95);

      const P1 = (n * R * T0) / V1;
      const P2 = (n * R * T0) / V2;

      if (P1 < 40 || P1 > 280 || P2 < 40 || P2 > 280) continue;
      break;
    }

    for (let i = 0; i < N; i++) {
      const t  = i / (N - 1);
      const V  = V1 * (1 - t) + V2 * t;
      const Pk = (n * R * T0) / V;
      pts.push({ VL: V, PkPa: Pk });
    }
  }

  // ===== ë‹¨ì—´ ê³¼ì • (Q = 0) â€“ 1~5 ë¼ìš´ë“œì—ì„œ ëª¨ì–‘ ë§ì¶”ê¸°ìš© =====
  else if (type === 'adiabatic') {
    const N = (mode === 'identify' ? 80 : 100);
    let V1, V2, T1, P1, K;

    for (let attempt = 0; attempt < 50; attempt++) {
      V1 = rand(V_MIN_L * 1.1, V_MAX_L * 0.8);
      V2 = rand(V1 + 0.25, V_MAX_L * 0.95);
      T1 = rand(220, 420);

      P1 = (n * R * T1) / V1;
      if (P1 < 60 || P1 > 260) continue;

      // P * V^Î³ = const
      K  = P1 * Math.pow(V1, gamma);

      // ëì ì—ì„œë„ ì˜¨ë„ ë²”ìœ„ ì•ˆì— ë“¤ì–´ê°€ëŠ”ì§€ ê²€ì‚¬
      const P2 = K / Math.pow(V2, gamma);
      const T2 = calcT(P2, V2);
      if (T2 < T_MIN || T2 > T_MAX) continue;

      break;
    }

    for (let i = 0; i < N; i++) {
      const t  = i / (N - 1);
      const V  = V1 * (1 - t) + V2 * t;
      const Pk = K / Math.pow(V, gamma);
      pts.push({ VL: V, PkPa: Pk });
    }
  }

  // ===== ì—´ê¸°ê´€ ì‚¬ì´í´ (ë“±ì••+ë“±ì  ì‚¬ê°í˜•) =====
else if (type === 'cycle') {
  // 9ë¼ìš´ë“œ: ë“±ì••+ë“±ì  ì‚¬ê°í˜• ì‚¬ì´í´ (ê¸°ì¡´ ë°©ì‹ ìœ ì§€)
  if (round < 10) {
    let V1, V2, P1, P2;

    const maxTry = 50;
    for (let attempt = 0; attempt < maxTry; attempt++) {
      V1 = rand(V_MIN_L * 1.1, V_MAX_L * 0.7);
      V2 = V1 + rand(0.4, 0.7);
      if (V2 >= V_MAX_L * 0.98) continue;

      P1 = rand(90, 130);
      P2 = P1 + rand(40, 70);

      const corners = [
        { V: V1, P: P1 },
        { V: V2, P: P1 },
        { V: V2, P: P2 },
        { V: V1, P: P2 }
      ];

      let ok = true;
      for (const c of corners) {
        const T = calcT(c.P, c.V);
        if (T < T_MIN || T > T_MAX) { ok = false; break; }
      }
      if (ok) break;
    }

    const Nseg = (mode === 'identify' ? 30 : 40);

    // 1: ë“±ì•• íŒ½ì°½ (P=P2, V1â†’V2)
    for (let i = 0; i < Nseg; i++) {
      const t = i / (Nseg - 1);
      pts.push({ VL: V1 + (V2 - V1) * t, PkPa: P2 });
    }
    // 2: ë“±ì  ëƒ‰ê° (V=V2, P2â†’P1)
    for (let i = 0; i < Nseg; i++) {
      const t = i / (Nseg - 1);
      pts.push({ VL: V2, PkPa: P2 + (P1 - P2) * t });
    }
    // 3: ë“±ì•• ì••ì¶• (P=P1, V2â†’V1)
    for (let i = 0; i < Nseg; i++) {
      const t = i / (Nseg - 1);
      pts.push({ VL: V2 + (V1 - V2) * t, PkPa: P1 });
    }
    // 4: ë“±ì  ê°€ì—´ (V=V1, P1â†’P2)
    for (let i = 0; i < Nseg; i++) {
      const t = i / (Nseg - 1);
      pts.push({ VL: V1, PkPa: P1 + (P2 - P1) * t });
    }
  }

  // ğŸ”¥ 10ë¼ìš´ë“œ: ë“±ì˜¨ + ë‹¨ì—´ì´ ì„ì¸ Carnot ìŠ¤íƒ€ì¼ ì‚¬ì´í´
  else {
    let V1, V2, V3, V4, T_hot, T_cold;
    let P1, P2, P3, P4;

    const maxTry = 60;
    const expo = 1 / (gamma - 1); // TV^{Î³-1}=const ì—ì„œ Vë¹„ ê³„ì‚°ìš©

    for (let attempt = 0; attempt < maxTry; attempt++) {
      // ì°¨ê°€ìš´ ìª½/ëœ¨ê±°ìš´ ìª½ ì˜¨ë„ ì„ íƒ (ìŠ¬ë¼ì´ë” ë²”ìœ„ ì•ˆ)
      T_cold = rand(220, 320);
      T_hot  = rand(T_cold + 80, Math.min(T_cold + 200, T_MAX - 20));

      // ì‹œì‘ ë¶€í”¼ V1, isothermalì—ì„œ ë„ë‹¬í•  ë¶€í”¼ V2
      V1 = rand(V_MIN_L * 1.1, V_MAX_L * 0.6);
      V2 = rand(V1 + 0.25, V_MAX_L * 0.7);

      // adiabatic: T_hot V2^{Î³-1} = T_cold V3^{Î³-1} â†’ V3
      const r = Math.pow(T_hot / T_cold, expo);
      V3 = V2 * r;
      V4 = V1 * r;

      // ë¶€í”¼ ë²”ìœ„ ì²´í¬
      if (V3 < V_MIN_L * 1.02 || V3 > V_MAX_L * 0.98) continue;
      if (V4 < V_MIN_L * 1.02 || V4 > V_MAX_L * 0.98) continue;

      // ì••ë ¥ ê³„ì‚°
      P1 = (n * R * T_hot)  / V1;
      P2 = (n * R * T_hot)  / V2;
      P3 = (n * R * T_cold) / V3;
      P4 = (n * R * T_cold) / V4;

      // ì••ë ¥ ë²”ìœ„ [40, 280]kPa
      const Ps = [P1, P2, P3, P4];
      if (Ps.some(p => p < 40 || p > 280)) continue;

      break;
    }

    const Nseg = 40;

    // 1: ë“±ì˜¨ íŒ½ì°½ (T = T_hot, V1 â†’ V2)
    for (let i = 0; i < Nseg; i++) {
      const t  = i / (Nseg - 1);
      const V  = V1 * (1 - t) + V2 * t;
      const Pk = (n * R * T_hot) / V;
      pts.push({ VL: V, PkPa: Pk });
    }

    // 2: ë‹¨ì—´ íŒ½ì°½ (V2 â†’ V3)
    const K1 = P2 * Math.pow(V2, gamma); // P V^Î³ = const
    for (let i = 0; i < Nseg; i++) {
      const t  = i / (Nseg - 1);
      const V  = V2 * (1 - t) + V3 * t;
      const Pk = K1 / Math.pow(V, gamma);
      pts.push({ VL: V, PkPa: Pk });
    }

    // 3: ë“±ì˜¨ ì••ì¶• (T = T_cold, V3 â†’ V4)
    for (let i = 0; i < Nseg; i++) {
      const t  = i / (Nseg - 1);
      const V  = V3 * (1 - t) + V4 * t;
      const Pk = (n * R * T_cold) / V;
      pts.push({ VL: V, PkPa: Pk });
    }

    // 4: ë‹¨ì—´ ì••ì¶• (V4 â†’ V1)
    const K2 = P4 * Math.pow(V4, gamma);
    for (let i = 0; i < Nseg; i++) {
      const t  = i / (Nseg - 1);
      const V  = V4 * (1 - t) + V1 * t;
      const Pk = K2 / Math.pow(V, gamma);
      pts.push({ VL: V, PkPa: Pk });
    }
  }
}

  return pts;
}


// â˜… 6~10 ë¼ìš´ë“œì—ì„œ ì‹œì‘ì ì„ ë§ì¶°ì£¼ëŠ” í•¨ìˆ˜
function applyStartFromChallengePoint(startPt){
  if(!startPt) return;
  const V_L = startPt.VL;        // L
  const V_m3 = V_L/1000;         // m^3
  const P_Pa = startPt.PkPa*1000;// Pa
  const T_K  = P_Pa*V_m3/(n*R);  // ì´ìƒê¸°ì²´ì‹

  state.h = clamp(V_m3/A, hLim.min, hLim.max);
  state.T = clamp(T_K, TLim.min, TLim.max);
  state.V = V(state.h);
  state.P = P(state.T,state.V);

  // ëª¨ë“œë³„ ìƒìˆ˜ ì¬ì„¤ì •
  state.Pc = (state.mode==='isobaric') ? state.P : null;
  state.Tc = (state.mode==='isothermal') ? state.T : null;
  state.Vc = (state.mode==='isochoric') ? state.V : null;
  if(state.mode==='adiabatic'){
    state.adi_Tc = state.T*Math.pow(state.V,gamma-1);
    state.adi_Pc = state.P*Math.pow(state.V,gamma);
  }else{
    state.adi_Tc = state.adi_Pc = null;
  }

  state.last = {P:state.P,V:state.V,T:state.T};
  state.Q=0; state.W=0; state.U=n*Cv*state.T; state.U0=state.U;

  piston.value = state.h;
  pistonLbl.textContent = state.h.toFixed(3)+' m';
  temp.value   = state.T;
  tempLbl.textContent   = Math.round(state.T)+' K';

  rescaleV(state.T);
  readouts();
  updatePressureHud(state.P/1000);
  window.resetPV && window.resetPV();
}

function setupRound(){
  let type, mode;

  if(GAME.round<=5){
    const types=['adiabatic','isothermal','isobaric','isochoric'];
    type = types[Math.floor(Math.random()*types.length)];
    mode = 'identify';
    choiceButtons.forEach(b=>b.disabled=false);
    btnCopyDone.disabled = true;
   }else if(GAME.round<=8){
    const typesCopy=['isothermal','isobaric','isochoric']; // â˜… ë‹¨ì—´ ì œê±°
    type = typesCopy[Math.floor(Math.random()*typesCopy.length)];
    mode = 'copy';
    choiceButtons.forEach(b=>b.disabled=true);
    btnCopyDone.disabled = false;
  }else{
    type = 'cycle';
    mode = 'copy';
    choiceButtons.forEach(b=>b.disabled=true);
    btnCopyDone.disabled = false;
  }

  GAME.currentType = type;
  GAME.currentMode = mode;

  const pts = generateCurve(type, mode, GAME.round);
  window.setChallengeCurve && window.setChallengeCurve(pts,{mode,type,round:GAME.round});

  // ì»¨íŠ¸ë¡¤ ê¸°ë³¸ê°’: ë“±ì 
  reset('isochoric');
  document.getElementById('showRefs').checked = (GAME.round<=5);

  // â˜… 6~10 ë¼ìš´ë“œ(copy)ëŠ” ì‹œì‘ì ì„ ê³¡ì„ ê³¼ ë§ì¶°ì£¼ê¸°
  if(mode==='copy' && pts && pts.length){
    applyStartFromChallengePoint(pts[0]);
  }else{
    window.resetPV && window.resetPV();
  }

  if(GAME.round<=5){
    setGameMessage('ì£¼í™©ìƒ‰ ì˜ˆì‹œ ê³¡ì„ ì„ ë³´ê³  ì–´ë–¤ ê³¼ì •ì¸ì§€ ê³ ë¥´ì„¸ìš” (ë‹¨ì—´Â·ë“±ì˜¨Â·ë“±ì••Â·ë“±ì ).');
  }else if(GAME.round<=8){
    setGameMessage('ì£¼í™©ìƒ‰ ê³¡ì„ ì„ ì°¸ê³ í•˜ì—¬ ìŠ¬ë¼ì´ë”/ê³¼ì •ì„ ì¡°ì ˆí•´ ë¹„ìŠ·í•œ ê³¡ì„ ì„ ê·¸ë¦¬ê³ , [ê·¸ë¦¬ê¸° ì™„ë£Œ]ë¥¼ ëˆ„ë¥´ì„¸ìš”.');
  }else{
    setGameMessage('ì—´ê¸°ê´€ ì‚¬ì´í´(ì‚¬ê°í˜• ë£¨í”„)ì„ ë”°ë¼ ê·¸ë ¤ ë³´ì„¸ìš”. ì¶©ë¶„íˆ ë¹„ìŠ·í•˜ë©´ ì •ë‹µ ì²˜ë¦¬ë©ë‹ˆë‹¤.');
  }
}

function nextRound(){
  if(!GAME.active) return;
  if(GAME.round>=GAME.totalRounds){
    endChallenge();
    return;
  }
  GAME.round++;
  updateGameUI();
  setupRound();
}

function startChallenge(){
  GAME.active = true;
  GAME.round  = 0;
  GAME.score  = 0;
  GAME.currentType=null;
  GAME.currentMode=null;
  setControlsEnabled(true);
  btnChallengeStart.disabled = true;
  nextRound();
}

function handleChoiceAnswer(answer){
  if(!GAME.active || GAME.currentMode!=='identify') return;
  const correct = (answer===GAME.currentType);
  applyCorrectScore(correct);
  setTimeout(nextRound, 600);
}
function handleCopyDone(){
  if(!GAME.active || GAME.currentMode!=='copy') return;
  if(!window.checkChallengeMatch){
    applyCorrectScore(false);
    setTimeout(nextRound, 600);
    return;
  }
  const ok = window.checkChallengeMatch();
  applyCorrectScore(ok);
  setTimeout(nextRound, 600);
}

/* ë²„íŠ¼ ì—°ê²° */
btnChallengeStart.addEventListener('click', startChallenge);
choiceButtons.forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const ans = btn.getAttribute('data-answer');
    handleChoiceAnswer(ans);
  });
});
btnCopyDone.addEventListener('click', handleCopyDone);

// ì´ˆê¸° UI
updateGameUI();
setGameMessage('ë„ì „ ì‹œì‘ ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ì£¼í™©ìƒ‰ ì˜ˆì‹œ ê³¡ì„ ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤.');
</script>

<!-- ===== Firebase ì—°ë™ (ìµœê³ ì ìˆ˜ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸°) ===== -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
  import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";
  import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCO36JgPpNz8swADxTMVJUFVALWM5o171w",
    authDomain: "simulation-67cd3.firebaseapp.com",
    projectId: "simulation-67cd3",
    storageBucket: "simulation-67cd3.appspot.com",
    messagingSenderId: "615983461615",
    appId: "1:615983461615:web:002e07bcea878eb6d5571a",
    measurementId: "G-9RGN7LYE5W"
  };

  const app  = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db   = getFirestore(app);

  const SIM_ID = "ì—´ê¸°ê´€ ì‹œë®¬ë ˆì´í„°";

  let firebaseUser = null;

  async function saveBestScore(score) {
    if (!firebaseUser) return;
    try {
      const ref = doc(db, "users", firebaseUser.uid, "simulations", SIM_ID);
      await setDoc(ref, { score: Number(score) || 0 }, { merge: true });
    } catch (err) {
      console.error("[ì—´ê¸°ê´€] ìµœê³  ì ìˆ˜ ì €ì¥ ì˜¤ë¥˜:", err);
    }
  }

  async function loadBestScore() {
    if (!firebaseUser) return;
    try {
      const ref = doc(db, "users", firebaseUser.uid, "simulations", SIM_ID);
      const snap = await getDoc(ref);
      if (snap.exists()) {
        const data  = snap.data();
        const score = Number(data.score || 0) || 0;
        if (window.GAME) {
          window.GAME.bestScore = score;
          const el = document.getElementById("chBest");
          if (el) el.textContent = score;
        }
      }
    } catch (err) {
      console.error("[ì—´ê¸°ê´€] ìµœê³  ì ìˆ˜ ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜:", err);
    }
  }

  window.saveBestScoreToFirebase = saveBestScore;

  onAuthStateChanged(auth, async (user) => {
    firebaseUser = user;
    if (user) {
      await loadBestScore();
    }
  });
</script>
</body>
</html>
