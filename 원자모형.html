<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>수소원자모형 양자화 시뮬레이터</title>

<!-- p5.js -->
<script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
<!-- Three.js UMD + OrbitControls (r124 고정) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.124.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.124.0/examples/js/controls/OrbitControls.js"></script>

<style>
  :root{--bg:#f7fafc;--panel:#fff;--ink:#0b1020;--ink-dim:#4b5563;--accent:#2563eb;--line:#e5e7eb}
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",Apple SD Gothic Neo,sans-serif}
  header{padding:12px 16px;border-bottom:1px solid var(--line);display:flex;justify-content:space-between;align-items:center;background:#fff;position:sticky;top:0;z-index:1}
  header h1{margin:0;font-size:18px}
  header .hint{font-size:12px;color:var(--ink-dim)}
  .app{display:grid;grid-template-columns:1fr 1fr;gap:12px;padding:12px;min-height:calc(100vh - 60px)}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:14px;display:grid;grid-template-rows:auto auto 1fr auto;box-shadow:0 6px 18px rgba(0,0,0,.04)}
  .panel h2{font-size:16px;margin:12px}
  .controls{display:flex;flex-wrap:wrap;gap:10px;padding:0 12px 8px}
  .controls.controls-3d{gap:8px;padding:0 12px 6px;max-height:56px;overflow:hidden}
  .group{display:flex;align-items:center;gap:8px;background:#f3f4f6;border:1px solid var(--line);padding:6px 10px;border-radius:10px}
  .pill{padding:2px 8px;border:1px solid var(--line);border-radius:999px;font-size:11px;color:var(--ink-dim);background:#fff}
  .canvas-wrap{position:relative;overflow:hidden;border-top:1px solid var(--line);border-bottom-left-radius:14px;border-bottom-right-radius:14px}
  #p5-wrap{min-height:720px}
  #three-wrap{min-height:640px;height:640px}
  #p5-container,#three-container{width:100%;height:100%}
  .note{padding:10px 12px;border-top:1px solid var(--line);font-size:12px;color:var(--ink-dim);background:#fff}
  button.primary{cursor:pointer;background:var(--accent);color:#fff;border:none;padding:6px 10px;border-radius:8px;font-weight:700}
  @media (max-width:1024px){.app{grid-template-columns:1fr}}
</style>
</head>
<body>
<header>
  <h1>수소원자모형 양자화 시뮬레이터  <span class="pill">보어의 원자이론</span></h1>
  <div class="hint">왕왕 물리시뮬레이션</div>
</header>

<main class="app">
  <!-- 2D: 궤도의 양자화 -->
  <section class="panel">
    <h2>궤도의 양자화 </h2>
    <div class="controls" id="ctrl-2d">
      <div class="group"><label>주양자수 n</label>
        <input id="nSlider" type="range" min="1" max="8" step="1" value="3"/><span id="nLabel" class="pill">n = 3</span></div>
      <div class="group"><label>파동 진폭</label>
        <input id="ampSlider" type="range" min="2" max="50" step="1" value="12"/><span id="ampLabel" class="pill">A = 12</span></div>
      <div class="group"><label>애니메이션</label>
        <select id="animMode"><option value="standing" selected>정지파</option><option value="traveling">주행파</option></select></div>
    </div>
    <div class="canvas-wrap" id="p5-wrap"><div id="p5-container"></div></div>
    <div class="note">조건: <b>2πR = n·λ</b>, <b>L = nħ</b>.</div>
  </section>

  <!-- 3D: 오비탈 -->
  <section class="panel">
    <h2>오비탈 (s, p, d, f) 전자구름 + 등가면</h2>
    <div class="controls controls-3d" id="ctrl-3d">
      <div class="group"><label>l</label>
        <select id="l3"><option value="0">0 (s)</option><option value="1" selected>1 (p)</option><option value="2">2 (d)</option><option value="3">3 (f)</option></select></div>
      <div class="group"><label>m</label><select id="m3"></select></div>
      <div class="group">
        <label for="orbitalToggle">오비탈 모형(등가면)</label>
        <input id="orbitalToggle" type="checkbox" checked />
      </div>
      <button id="regen" class="primary">재생성</button>
    </div>
    <div class="canvas-wrap" id="three-wrap"><div id="three-container"></div></div>
    <div class="note"></div>
  </section>
</main>

<script>
// ===== 공통 설정 =====
const CONFIG = {
  renderer: { pixelRatioMax: 1.25, bg: 0xffffff },
  points:   { count: 60000, size: 0.3, opacity: 0.3, shapeBeta: 1.6 }, // 요청값
  iso:      { scale: 1.5, exp: 0.7, opacity: 0.9 },
  axes:     { len: 1.8, thick: 0.02, opacity: 0.8, labelScale: [0.35, 0.18] },
  colors:   { pos:[0.20,0.55,1.00], neg:[1.00,0.35,0.30] }
};
</script>

<!-- 2D: p5 -->
<script>
(()=>{
  const nS=document.getElementById('nSlider'), aS=document.getElementById('ampSlider');
  const nL=document.getElementById('nLabel'), aL=document.getElementById('ampLabel');
  const am=document.getElementById('animMode');

  let sketch=p=>{
    let t=0;
    const getWH=()=>{const parent=document.getElementById('p5-container');return [parent.clientWidth,Math.max(parent.clientHeight,720)]};
    p.setup = ()=>{const [w,h]=getWH(); p.createCanvas(w,h).parent('p5-container'); p.angleMode(p.RADIANS);};
    p.windowResized = ()=>{const [w,h]=getWH(); p.resizeCanvas(w,h);};
    p.draw=()=>{
      p.background(250,252,255);
      const n=+nS.value, A=+aS.value; nL.textContent=`n = ${n}`; aL.textContent=`A = ${A}`;
      p.translate(p.width/2,p.height/2);
      const R=Math.min(p.width,p.height)*(0.10+0.02*n);
      p.noFill(); p.stroke(30,41,59); p.strokeWeight(1.5); p.circle(0,0,R*2);
      p.stroke(37,99,235); p.strokeWeight(2.2); p.beginShape();
      const seg=1200;
      for(let i=0;i<=seg;i++){
        const th=i/seg*p.TWO_PI;
        const ph=(am.value==='standing'?Math.cos(t*1.2)*Math.sin(n*th):Math.sin(n*th-t*1.6));
        const r=R+A*ph; p.vertex(r*Math.cos(th), r*Math.sin(th));
      }
      p.endShape();
      p.noStroke(); p.fill(239,68,68);
      for(let k=0;k<2*n;k++){const th=k*Math.PI/n; p.circle(R*Math.cos(th), R*Math.sin(th), 6);}
      p.noStroke(); p.fill(71,85,105); p.textAlign(p.CENTER); p.textSize(14); p.text('2πR = n·λ,  L = nħ', 0, -R-24);
      t+=0.02;
    };
  };
  new p5(sketch);
})();
</script>

<!-- 3D: Three.js -->
<script>
(()=>{
  // DOM
  const wrap=document.getElementById('three-container');
  const box=document.getElementById('three-wrap');
  const lSel=document.getElementById('l3');
  const mSel=document.getElementById('m3');
  const btn=document.getElementById('regen');
  const tgl=document.getElementById('orbitalToggle');
  let showIso = tgl.checked;   // 등가면만 토글

  // Scene / Camera / Renderer
  const scene=new THREE.Scene(); scene.background=new THREE.Color(CONFIG.renderer.bg);
  const cam=new THREE.PerspectiveCamera(45,1,0.1,100); cam.position.set(3.2,2.8,3.8);
  const rnd=new THREE.WebGLRenderer({antialias:true,powerPreference:'high-performance'});
  rnd.setPixelRatio(Math.min(window.devicePixelRatio, CONFIG.renderer.pixelRatioMax));
  rnd.setSize(box.clientWidth||880, Math.max(box.clientHeight||640,560), false);
  wrap.appendChild(rnd.domElement);
  Object.assign(rnd.domElement.style,{display:'block',width:'100%',height:'100%'});

  // Controls
  const ControlsCtor=(THREE&&THREE.OrbitControls)||window.OrbitControls;
  const ctl=new ControlsCtor(cam,rnd.domElement); ctl.enableDamping=true; ctl.target.set(0,0,0); cam.lookAt(0,0,0);

  // Lights & nucleus
  scene.add(new THREE.AmbientLight(0xffffff,0.9));
  const dl=new THREE.DirectionalLight(0xffffff,0.65); dl.position.set(3,5,2); scene.add(dl);
  scene.add(new THREE.Mesh(new THREE.SphereGeometry(0.06,24,24), new THREE.MeshStandardMaterial({color:0xef4444,roughness:0.5})));

  // === XYZ 축 + 라벨 ===
  (function makeAxes(){
    const {len:AX_LEN, thick:AX_THICK, opacity:AX_OPA, labelScale} = CONFIG.axes;
    function labelSprite(text,color='#111827'){
      const c=document.createElement('canvas'); c.width=256; c.height=128;
      const g=c.getContext('2d'); g.scale(2,2);
      g.font='bold 28px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
      g.textAlign='center'; g.textBaseline='middle';
      g.strokeStyle='rgba(0,0,0,0.35)'; g.lineWidth=3; g.fillStyle=color;
      g.strokeText(text,64,32); g.fillText(text,64,32);
      const tex=new THREE.CanvasTexture(c);
      return new THREE.Sprite(new THREE.SpriteMaterial({map:tex,transparent:true}));
    }
    function axis(dir,color,label){
      const g=new THREE.Group();
      const mat=new THREE.MeshPhongMaterial({color,transparent:true,opacity:AX_OPA});
      const shaft=new THREE.Mesh(new THREE.CylinderGeometry(AX_THICK,AX_THICK,AX_LEN*0.9,18),mat);
      shaft.position.y=AX_LEN*0.45;
      const head=new THREE.Mesh(new THREE.ConeGeometry(AX_THICK*2.0,AX_LEN*0.18,24),mat);
      head.position.y=AX_LEN*0.9;
      g.add(shaft,head);
      const q=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0),dir.clone().normalize());
      g.quaternion.copy(q);
      const sp=labelSprite(label); sp.scale.set(labelScale[0],labelScale[1],1); sp.position.y=AX_LEN*1.08;
      g.add(sp);
      return g;
    }
    const axes=new THREE.Group();
    axes.add(axis(new THREE.Vector3(1,0,0),0xff4d4d,'x'));
    axes.add(axis(new THREE.Vector3(0,1,0),0x22c55e,'y'));
    axes.add(axis(new THREE.Vector3(0,0,1),0x3b82f6,'z'));
    scene.add(axes);
  })();

  // 원형 점 텍스처
  const circTex=(()=>{const c=document.createElement('canvas'); c.width=c.height=96;
    const g=c.getContext('2d'), r=48, gr=g.createRadialGradient(r,r,0,r,r,r);
    gr.addColorStop(0,'rgba(255,255,255,1)'); gr.addColorStop(0.7,'rgba(255,255,255,1)'); gr.addColorStop(1,'rgba(255,255,255,0)');
    g.fillStyle=gr; g.beginPath(); g.arc(r,r,r,0,Math.PI*2); g.fill();
    const t=new THREE.CanvasTexture(c); t.minFilter=t.magFilter=THREE.LinearFilter; return t;})();

  // 전자구름(Points) / 등가면
  let pts,gP,mP,raf=null,isoMesh, Amax=1;

  // 수학부: 실수형 구면조화 (형상만) + 방사 엔벨롭
  const realY=(l,m,th,ph)=>{
    const s=Math.sin(th),c=Math.cos(th);
    if(l===0)return 1;
    if(l===1){if(m===0)return c; if(m===1)return s*Math.cos(ph); if(m===-1)return s*Math.sin(ph);}
    if(l===2){if(m===0)return 3*c*c-1; if(m===1)return s*c*Math.cos(ph); if(m===-1)return s*c*Math.sin(ph); if(m===2)return s*s*Math.cos(2*ph); if(m===-2)return s*s*Math.sin(2*ph);}
    if(l===3){if(m===0)return 5*c*c*c-3*c; if(m===1)return s*(5*c*c-1)*Math.cos(ph); if(m===-1)return s*(5*c*c-1)*Math.sin(ph);
             if(m===2)return s*s*c*Math.cos(2*ph); if(m===-2)return s*s*c*Math.sin(2*ph); if(m===3)return s*s*s*Math.cos(3*ph); if(m===-3)return s*s*s*Math.sin(3*ph);}
    return 0;
  };
  const rEnv=(r,l)=>Math.pow(r+1e-6,2*l)*Math.exp(-2*r);

  // |Y_l^m| 최대값 근사
  function computeAngularMax(l,m){
    let maxA=0;
    const thSeg=128, phSeg=256;
    for(let i=0;i<=thSeg;i++){
      const th=Math.PI*(i/thSeg);
      for(let j=0;j<=phSeg;j++){
        const ph=2*Math.PI*(j/phSeg);
        const a=Math.abs(realY(l,m,th,ph));
        if(a>maxA) maxA=a;
      }
    }
    return Math.max(1e-6, maxA);
  }

  function initPoints(N){
    if(pts){scene.remove(pts); gP?.dispose(); mP?.dispose();}
    gP=new THREE.BufferGeometry();
    gP.setAttribute('position',new THREE.BufferAttribute(new Float32Array(N*3),3));
    gP.setAttribute('color',new THREE.BufferAttribute(new Float32Array(N*3),3));
    mP=new THREE.PointsMaterial({
      size: CONFIG.points.size,                  // 0.3
      sizeAttenuation:true,
      map:circTex, alphaTest:.3, transparent:true, opacity:CONFIG.points.opacity, // 0.3
      vertexColors:true, depthWrite:false
    });
    pts=new THREE.Points(gP,mP); pts.frustumCulled=false; scene.add(pts);
  }

  // 각도 분포를 |Y|^β로 가중한 수용-거절 샘플링 (전자구름은 항상 표시)
  function fillPoints(N,l,m){
    const pos=gP.attributes.position.array, col=gP.attributes.color.array;
    const R=6, S=1.4/R;
    const POS=CONFIG.colors.pos, NEG=CONFIG.colors.neg;
    const beta = CONFIG.points.shapeBeta;

    let accepted=0, tried=0, batch=4000;
    if(raf)cancelAnimationFrame(raf);

    (function step(){
      const limit = Math.min(N, accepted + batch);
      while(accepted < limit && tried < N*100){
        tried++;
        // 제안 분포: 구면 균일 + 지수형 반지름 (수소형 엔벨롭)
        const u=Math.random()*2-1;
        const th=Math.acos(Math.max(-1,Math.min(1,u)));
        const ph=Math.random()*Math.PI*2;
        const r=Math.min(R, -Math.log(1-Math.random())*2.2);

        const s=Math.sin(th), cx=s*Math.cos(ph), cy=s*Math.sin(ph), cz=Math.cos(th);
        const A=realY(l,m,th,ph), aAbs=Math.abs(A);
        const p = Math.pow(aAbs / Amax, beta);      // 0~1
        if(Math.random() > p) continue;

        const val=Math.pow(aAbs,1.2)*rEnv(r,l), b=.6+.4*(val/(1+.75*val)), rr=r*S;
        pos[3*accepted]=cx*rr; pos[3*accepted+1]=cy*rr; pos[3*accepted+2]=cz*rr;
        const rgb = (A>=0)? [POS[0]*b,POS[1]*b,POS[2]*b] : [NEG[0]*b,NEG[1]*b,NEG[2]*b];
        col[3*accepted]=rgb[0]; col[3*accepted+1]=rgb[1]; col[3*accepted+2]=rgb[2];
        accepted++;
      }
      gP.setDrawRange(0,accepted);
      gP.attributes.position.needsUpdate = gP.attributes.color.needsUpdate = true;

      if(accepted < N){ raf=requestAnimationFrame(step); }
      else { gP.computeBoundingSphere(); frameAll(); }
    })();
  }

  // 등가면(오비탈 모형)
  function buildIso(l,m){
    const {scale, exp, opacity}=CONFIG.iso;
    if(isoMesh){scene.remove(isoMesh); isoMesh.geometry.dispose(); isoMesh.material.dispose();}
    const thSeg=96, phSeg=192, row=phSeg+1, P=[],C=[],I=[];
    for(let i=0;i<=thSeg;i++){
      const th=Math.PI*(i/thSeg), s=Math.sin(th), c=Math.cos(th);
      for(let j=0;j<=phSeg;j++){
        const ph=2*Math.PI*(j/phSeg), A=realY(l,m,th,ph), mag=Math.pow(Math.abs(A),exp), r=scale*(.9*mag+.05);
        P.push(r*s*Math.cos(ph), r*s*Math.sin(ph), r*c);
        (A>=0)? C.push(...CONFIG.colors.pos): C.push(...CONFIG.colors.neg);
      }
    }
    for(let i=0;i<thSeg;i++) for(let j=0;j<phSeg;j++){ const a=i*row+j,b=a+1,c=(i+1)*row+j,d=c+1; I.push(a,c,b,b,c,d); }
    const g=new THREE.BufferGeometry();
    g.setAttribute('position',new THREE.Float32BufferAttribute(P,3));
    g.setAttribute('color',new THREE.Float32BufferAttribute(C,3));
    g.setIndex(I); g.computeVertexNormals();
    isoMesh=new THREE.Mesh(g,new THREE.MeshPhongMaterial({vertexColors:true,side:THREE.DoubleSide,transparent:true,opacity}));
    scene.add(isoMesh);
    isoMesh.visible = showIso; // 현재 토글 상태 반영
  }

  // 카메라 프레이밍 (가시 객체만 고려; 전자구름은 항상 가시)
  function frameAll(margin=1.25){
    let r1=0,r2=0;
    if(isoMesh && isoMesh.visible){ isoMesh.geometry.computeBoundingSphere(); r1=isoMesh.geometry.boundingSphere.radius; }
    if(gP){ gP.computeBoundingSphere(); r2=gP.boundingSphere.radius; }
    const r=Math.max(r1,r2,1), vF=THREE.MathUtils.degToRad(cam.fov), hF=2*Math.atan(Math.tan(vF/2)*cam.aspect);
    const d=Math.max((r*margin)/Math.tan(vF/2),(r*margin)/Math.tan(hF/2));
    const dir=new THREE.Vector3().subVectors(cam.position,ctl.target).normalize();
    cam.position.copy(dir.multiplyScalar(d)).add(ctl.target); cam.updateProjectionMatrix();
  }

  // UI 로직
  function populateM(){const l=+lSel.value; mSel.innerHTML=''; for(let m=-l;m<=l;m++){const o=document.createElement('option');o.value=m;o.textContent=m;if(m===0)o.selected=true;mSel.appendChild(o)}}

  function regen(){
    const l=+lSel.value, m=+mSel.value||0;
    Amax = computeAngularMax(l,m);
    initPoints(CONFIG.points.count);      // 항상 생성
    fillPoints(CONFIG.points.count,l,m);  // 항상 샘플링
    buildIso(l,m);                        // 등가면 생성(표시는 토글에 따름)
    frameAll(1.25);
  }

  // 이벤트 바인딩
  populateM(); regen();
  lSel.addEventListener('change',()=>{populateM(); regen();});
  mSel.addEventListener('change', regen);
  btn.addEventListener('click', regen);

  // 등가면 토글: 전자구름은 그대로 두고 등가면만 on/off
  tgl.addEventListener('change', ()=>{
    showIso = tgl.checked;
    if(isoMesh){
      isoMesh.visible = showIso;
      frameAll(1.25);
    }else if(showIso){
      // 아직 등가면이 없다면 만들어서 보여줌
      const l=+lSel.value, m=+mSel.value||0;
      buildIso(l,m);
      frameAll(1.25);
    }
  });

  function onResize(){const w=box.clientWidth||880,h=Math.max(box.clientHeight||640,560); cam.aspect=w/h; cam.updateProjectionMatrix(); rnd.setSize(w,h,false); frameAll(1.25)}
  if('ResizeObserver'in window){new ResizeObserver(onResize).observe(box)} else {addEventListener('resize',onResize)}
  onResize();

  (function loop(){requestAnimationFrame(loop); ctl.update(); rnd.render(scene,cam)})();
})();
</script>
</body>
</html>
