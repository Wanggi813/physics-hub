<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>ë Œì¦ˆì˜ êµ´ì ˆ</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="./libs/p5.min.js"></script>
<style>
  :root{
    --bg1:#f7fbff; --bg2:#eef6ff; --ink:#0f172a; --sub:#546076; --axis:#2563eb;
    --accent:#2563eb; --good:#16a34a; --warn:#f59e0b; --bad:#ef4444;
    --panel:#ffffff; --line:#e6eef9; --shadow:0 12px 36px rgba(15,23,42,.12); --radius:14px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--ink);
    background: radial-gradient(1200px 800px at 10% -10%, var(--bg2) 0%, var(--bg1) 60%);
    font:16px/1.7 system-ui,-apple-system,Segoe UI,Roboto,Pretendard,'Noto Sans KR',sans-serif;
  }
  #sketch{position:fixed; inset:0}
  .overlay{
    position:fixed; top:14px; right:14px; z-index:10; width:min(380px, 92vw);
    background:var(--panel); border:1px solid var(--line); border-radius:var(--radius); box-shadow:var(--shadow);
    padding:14px 14px 12px;
  }
  .overlay h2{margin:0 0 8px; font-size:17px}
  .row{display:flex; align-items:center; gap:10px; margin:10px 0}
  label{font-size:14.5px; color:var(--sub)}
  select,input[type="range"]{width:100%; accent-color:var(--accent)}
  .kv{display:grid; grid-template-columns:1fr 1fr; gap:10px 14px; margin-top:10px}
  .kv div{background:#f7fafc; border:1px solid var(--line); border-radius:10px; padding:8px 10px; font-size:15px}
  .kv b{display:block; font-weight:700; color:#65748b; margin-bottom:3px; font-size:14px}
  .badge{display:inline-block; padding:3px 10px; border-radius:999px; font-size:13px; margin-right:6px}
  .real{background:#e8f7ee; border:1px solid #b7ebc3; color:#065f46}
  .virtual{background:#ffecec; border:1px solid #ffc6c6; color:#7f1d1d}
  .note{color:#65748b; font-size:14px; margin-top:8px}
  .hint{position:fixed; left:14px; bottom:14px; background:#ffffffcc; backdrop-filter: blur(4px);
        border:1px solid var(--line); border-radius:12px; padding:9px 12px; box-shadow:var(--shadow); font-size:14px}
  .hidden{display:none}
  canvas{display:block}

  /* === ë„ì „ ë°•ìŠ¤ (ë Œì¦ˆ ê²Œì„ìš©, ì™¼ìª½ ìœ„) - ë°ì€ ìƒ‰ í…Œë§ˆ === */
  .challenge-box{
    position:fixed;
    top:14px;
    left:14px;
    z-index:15;
    background:rgba(255,255,255,0.98);
    border:1px solid #e2e8f0;
    border-radius:14px;
    padding:10px 12px;
    min-width:230px;
    color:#0f172a;
    backdrop-filter:blur(8px);
    box-shadow:0 12px 28px rgba(148,163,184,0.55);
    font-size:13px;
  }
  .cb-title{
    font-size:12px;
    font-weight:800;
    letter-spacing:.08em;
    color:#2563eb;
    margin-bottom:6px;
    text-transform:uppercase;
  }
  .cb-row{
    display:flex;
    justify-content:space-between;
    align-items:baseline;
    margin-bottom:4px;
  }
  .cb-label{
    font-size:12px;
    color:#64748b;
  }
  .cb-value{
    font-size:16px;
    font-weight:800;
    min-width:60px;
    text-align:right;
    color:#0f172a;
  }
  .cb-best .cb-value{
    color:#f59e0b;
    text-shadow:0 0 5px rgba(245,158,11,0.6);
    display:flex;
    align-items:center;
    justify-content:flex-end;
    gap:4px;
  }
  .cb-best .trophy{
    font-size:18px;
  }
  .cb-btn{
    margin-top:6px;
    width:100%;
    border-radius:999px;
    border:1px solid #bfdbfe;
    background:linear-gradient(135deg,#2563eb,#38bdf8);
    color:#f9fafb;
    font-size:13px;
    font-weight:700;
    padding:6px 0;
    cursor:pointer;
  }
  .cb-btn:hover{
    filter:brightness(1.05);
  }
  .cb-btn-secondary{
    margin-top:4px;
    background:#e5e7eb;
    border-color:#cbd5e1;
    color:#111827;
    font-size:12px;
    padding:5px 0;
  }
  .cb-btn-secondary:hover{
    background:#d1d5db;
  }
  .cb-msg{
    margin-top:6px;
    font-size:11.5px;
    line-height:1.5;
    color:#4b5563;
    min-height:40px;
  }
  .cb-msg small{
    display:block;
    color:#9ca3af;
    margin-top:2px;
  }
  .cb-section{
    margin-top:6px;
  }
  .cb-subtitle{
    font-size:11px;
    color:#64748b;
    margin-bottom:4px;
  }
  .cb-choice-grid{
    display:grid;
    grid-template-columns:repeat(2,minmax(0,1fr));
    gap:4px;
  }
  .cb-choice-grid.cb-size-grid{
    grid-template-columns:repeat(3,minmax(0,1fr));
  }
  .cb-opt{
    border-radius:999px;
    border:1px solid #d1d5db;
    background:#f9fafb;
    color:#374151;
    padding:4px 6px;
    font-size:11px;
    cursor:pointer;
    text-align:center;
    white-space:nowrap;
  }
  .cb-opt:hover{
    background:#e5f0ff;
    border-color:#93c5fd;
  }
  .cb-opt.selected{
    border-color:#2563eb;
    background:radial-gradient(circle at 0% 0%,#bfdbfe,#3b82f6);
    color:#f9fafb;
    box-shadow:0 0 0 1px rgba(59,130,246,0.4);
  }
  .cb-size-section{
    margin-top:4px;
  }

  /* ìµœê³ ì ìˆ˜ íŒ ì• ë‹ˆë©”ì´ì…˜ */
  @keyframes bestPop {
    0%   { transform:scale(1); }
    30%  { transform:scale(1.25); }
    60%  { transform:scale(0.92); }
    100% { transform:scale(1); }
  }
  #lens-challenge .best-badge{
    animation:none;
  }
  #lens-challenge .best-badge.best-bump{
    animation:bestPop .6s ease-out;
  }
</style>
</head>
<body>
  <div id="sketch"></div>

  <!-- ì˜¤ë¥¸ìª½ ì„¤ì • íŒ¨ë„ (ì›ë˜ UI ê·¸ëŒ€ë¡œ) -->
  <div class="overlay">
    <h2>ì„¤ì •</h2>
    <div class="row">
      <label for="lensType">ë Œì¦ˆ ì¢…ë¥˜</label>
      <select id="lensType">
        <option value="convex">ë³¼ë¡ë Œì¦ˆ (ìˆ˜ë ´, f &gt; 0)</option>
        <option value="concave">ì˜¤ëª©ë Œì¦ˆ (ë°œì‚°, f &lt; 0)</option>
      </select>
    </div>
    <div class="row">
      <label for="focal" style="min-width:110px">ì´ˆì ê±°ë¦¬ |f| (px)</label>
      <input id="focal" type="range" min="40" max="300" value="160" />
    </div>
    <div class="row" style="gap:14px; flex-wrap:wrap">
      <label><input type="checkbox" id="showRays" checked /> ì£¼ê´‘ì„ </label>
      <label><input type="checkbox" id="showGrid" checked /> ê²©ì</label>
      <label><input type="checkbox" id="showInfo" /> ê°’ í‘œì‹œ</label>
      <label><input type="checkbox" id="showGuide" checked /> a,b & í—ˆìƒ ë³´ì¡°ì„ </label>
    </div>

    <!-- â–¼ ê°’ ì„¹ì…˜ ì „ì²´ë¥¼ ë˜í•‘: í† ê¸€ë¡œ í†µì§¸ë¡œ ìˆ¨ê¹€ -->
    <div id="kvSection">
      <h2>ì‹¤ì‹œê°„ ê°’</h2>
      <div class="kv" id="kv">
        <div><b>ì´ˆì ê±°ë¦¬ f</b><span id="kv_f">â€”</span></div>
        <div><b>ë¬¼ì²´ê±°ë¦¬ d<sub>o</sub> (= a)</b><span id="kv_do">â€”</span></div>
        <div><b>ìƒê±°ë¦¬ d<sub>i</sub> (= b)</b><span id="kv_di">â€”</span></div>
        <div><b>ë°°ìœ¨ m</b><span id="kv_m">â€”</span></div>
        <div style="grid-column:1 / -1"><b>ìƒì˜ ì„±ê²©</b><span id="kv_kind">â€”</span></div>
      </div>
      <p class="note">ê³µì‹: <em>1/f = 1/a + 1/b, &nbsp; m = -b/a</em> (í‘œì¤€ë¶€í˜¸: a&gt;0, b&gt;0(ì‹¤ìƒ)/b&lt;0(í—ˆìƒ))</p>
    </div>
    <!-- â–² ê°’ ì„¹ì…˜ -->
  </div>

  <!-- ì™¼ìª½ ì•„ë˜ íŒíŠ¸ (ê¸°ì¡´ ê·¸ëŒ€ë¡œ) -->
  <div class="hint">ë“œë˜ê·¸: ë Œì¦ˆ ì„¸ë¡œì„ , ë¬¼ì²´ ë°‘ì  â—, í™”ì‚´ì´‰ â—</div>

  <!-- ì™¼ìª½ ìœ„ ë Œì¦ˆ ë„ì „ ë°•ìŠ¤ -->
  <div class="challenge-box" id="lens-challenge">
    <div class="cb-title">ë Œì¦ˆ ë„ì „</div>
    <div class="cb-row">
      <div class="cb-label">ë¼ìš´ë“œ</div>
      <div class="cb-value" id="lens-round">-</div>
    </div>
    <div class="cb-row">
      <div class="cb-label">ì ìˆ˜</div>
      <div class="cb-value" id="lens-score">0</div>
    </div>
    <div class="cb-row cb-best">
      <div class="cb-label">ìµœê³ ì ìˆ˜</div>
      <div class="cb-value best-badge">
        <span class="trophy">ğŸ†</span>
        <span id="lens-best">0</span>
      </div>
    </div>
    <button id="lens-start" class="cb-btn">ë„ì „</button>
    <!-- ì •ë‹µì œì¶œ ë²„íŠ¼ì€ ë” ì´ìƒ ì“°ì§€ ì•Šìœ¼ë¯€ë¡œ ìˆ¨ê¹€ -->
    <button id="lens-submit" class="cb-btn cb-btn-secondary" style="display:none;">ì •ë‹µ ì œì¶œ</button>

    <div class="cb-section">
      <div class="cb-subtitle">ìƒì˜ ì¢…ë¥˜</div>
      <div class="cb-choice-grid">
        <button class="cb-opt cb-opt-kind" data-kind="ë„ë¦½ì‹¤ìƒ">ë„ë¦½ ì‹¤ìƒ</button>
        <button class="cb-opt cb-opt-kind" data-kind="ì •ë¦½ì‹¤ìƒ">ì •ë¦½ ì‹¤ìƒ</button>
        <button class="cb-opt cb-opt-kind" data-kind="ë„ë¦½í—ˆìƒ">ë„ë¦½ í—ˆìƒ</button>
        <button class="cb-opt cb-opt-kind" data-kind="ì •ë¦½í—ˆìƒ">ì •ë¦½ í—ˆìƒ</button>
      </div>
    </div>

    <div class="cb-section cb-size-section">
      <div class="cb-subtitle">í¬ê¸° (9~10ë¼ìš´ë“œì—ì„œ ì‚¬ìš©)</div>
      <div class="cb-choice-grid cb-size-grid">
        <button class="cb-opt cb-opt-size" data-size="í™•ëŒ€">í™•ëŒ€</button>
        <button class="cb-opt cb-opt-size" data-size="ë™ì¼">ë™ì¼</button>
        <button class="cb-opt cb-opt-size" data-size="ì¶•ì†Œ">ì¶•ì†Œ</button>
      </div>
    </div>

    <div class="cb-msg" id="lens-msg">
      ë„ì „ ë²„íŠ¼ì„ ëˆŒëŸ¬<br>ë Œì¦ˆ ë„ì „ ê²Œì„ì„ ì‹œì‘í•˜ì„¸ìš”.
      <small>ì´ 10ë¼ìš´ë“œ, ì •ë‹µë§ˆë‹¤ +50ì  Â· ì˜¤ë‹µì€ 0ì </small>
    </div>
  </div>

<script>
/* ===== Fullscreen Lens Simulator (ê°’ ë°•ìŠ¤ í† ê¸€) ===== */
let W, H, axisY;
let lensX;
let objectX, objectH;
let dragging = null;
let dragOffsetX = 0, dragOffsetY = 0;

let ui = {};
const EPS = 1e-4;
const GRID = 72;

/* ê²Œì„ ìƒíƒœë¥¼ p5 ìª½ì—ì„œë„ ì•Œ ìˆ˜ ìˆê²Œ ì „ì—­ìœ¼ë¡œ ë‘  */
let lensGameOn = false;
let lensGameRound = 0;
let lensRoundLocked = false;  // í•œ ë¼ìš´ë“œì—ì„œ ì¤‘ë³µ í´ë¦­ ë°©ì§€

function setup(){
  pixelDensity(1);
  createCanvas(windowWidth, windowHeight).parent('sketch');
  const c = document.querySelector('#sketch canvas');
initLayout();

  ui.lensType = document.getElementById('lensType');
  ui.focal    = document.getElementById('focal');
  ui.showRays = document.getElementById('showRays');
  ui.showGrid = document.getElementById('showGrid');
  ui.showInfo = document.getElementById('showInfo');
  ui.showGuide= document.getElementById('showGuide');
  ui.kvSection= document.getElementById('kvSection');
  ui.kv = {
    f:  document.getElementById('kv_f'),
    do: document.getElementById('kv_do'),
    di: document.getElementById('kv_di'),
    m:  document.getElementById('kv_m'),
    kind: document.getElementById('kv_kind'),
  };

  const applyKvVisibility = () => {
    if (ui.showInfo.checked) ui.kvSection.classList.remove('hidden');
    else                     ui.kvSection.classList.add('hidden');
  };
  ui.showInfo.addEventListener('change', applyKvVisibility);
  applyKvVisibility(); // ì´ˆê¸° ì ìš©
}

function initLayout(){
  W = windowWidth; H = windowHeight;
  const rawAxis = H * 0.58;
  axisY = Math.round(rawAxis / GRID) * GRID;
  lensX = W * 0.5;
  objectX = W * 0.25;
  objectH = 120;
}

function windowResized(){
  resizeCanvas(windowWidth, windowHeight);
  W = windowWidth; H = windowHeight;
  const rawAxis = H * 0.58;
  axisY = Math.round(rawAxis / GRID) * GRID;
  lensX   = constrain(lensX, 40, W-40);
  objectX = constrain(objectX, 20, W-20);
}

function draw(){
  clear();
  noStroke(); fill(255,255,255,230); rect(0,0,width,height);

  const type = ui.lensType.value;
  const fmag = parseFloat(ui.focal.value);
  const f = (type==='convex') ? +fmag : -fmag;

  if(ui.showGrid.checked) drawGrid();

  stroke('#2563eb'); strokeWeight(2.2);
  line(0, axisY, width, axisY);

  drawLensSilhouette(lensX, f, type);

  const objTip = {x: objectX, y: axisY - objectH};
  drawArrow(objectX, axisY, objTip.x, objTip.y, color(37,99,235), true);

  const incomingLeft = objectX < lensX;
  const a = Math.abs(lensX - objectX);
  const denom = (1/f) - (1/a);
  let atInfinity = false, b, m;

  if(Math.abs(denom) < EPS){ atInfinity = true; b = Infinity; m = NaN; }
  else { b = 1/denom; m = -b/a; }

  const imgX = atInfinity ? (incomingLeft ? width-10 : 10)
                          : (incomingLeft ? lensX + b : lensX - b);
  const imgH = atInfinity ? 0 : objectH * m;
  const imgTip = {x: imgX, y: axisY - imgH};
  const isReal = !atInfinity && (b > 0);

  if(ui.showRays.checked){
    drawPrincipalRays({objTip, lensX, axisY, f, type, incomingLeft});
  }

  if(!atInfinity){
    const clr = isReal ? color(22,163,74) : color(239,68,68);
    drawArrow(imgX, axisY, imgTip.x, imgTip.y, clr, isReal, !isReal);
  }else{
    push(); noStroke(); fill('#f59e0b'); textAlign(CENTER, BOTTOM); textSize(16);
    text('a â‰ˆ f  â†’  ìƒì´ ë¬´í•œ ì›ê±°ë¦¬(í‰í–‰ê´‘)', width*0.5, 26); pop();
  }

  // í—ˆìƒ ë³´ì¡°ì„ : 9~10ë¼ìš´ë“œì—ëŠ” ë‚œì´ë„ ìƒìŠ¹ì„ ìœ„í•´ ìˆ¨ê¹€
  if(ui.showGuide.checked && !atInfinity && !isReal && !(lensGameOn && lensGameRound >= 9)){
    const passPt = {x: lensX, y: objTip.y};
    push();
      stroke(100,116,139); strokeWeight(2);
      drawingContext.setLineDash([7,7]);
      line(passPt.x, passPt.y, imgTip.x, imgTip.y);
      drawingContext.setLineDash([]);
      noStroke(); fill(100,116,139);
      circle(passPt.x, passPt.y, 6);
      circle(imgTip.x, imgTip.y, 6);
    pop();
  }

  drawFoci(lensX, axisY, f);

  // a, b ë³´ì¡°ì„ : 9~10ë¼ìš´ë“œì—ëŠ” ìˆ¨ê¹€
  if(ui.showGuide.checked && !(lensGameOn && lensGameRound >= 9)){
    drawMeasureAB({a, b, lensX, objectX, imgX, axisY, showB: !atInfinity});
  }

  drawHandles();

  if(ui.showInfo.checked){
    updateKV(f, a, b, m, atInfinity, incomingLeft);
  }

  // === 6~10ë¼ìš´ë“œ: ë Œì¦ˆ ì¤‘ì‹¬ë¶€í„° ì˜¤ë¥¸ìª½ ëª¨ë‘ ì™„ì „íˆ ê°€ë¦¬ê¸° (ë¶ˆíˆ¬ëª…) ===
  if (lensGameOn && lensGameRound >= 6 && lensGameRound <= 10) {
    push();
    noStroke();
    fill(255);               // ì™„ì „ ë¶ˆíˆ¬ëª…
    rect(lensX, 0, width - lensX, height);
    pop();
  }
}

function drawGrid(){
  push();
  stroke('#e6eef9'); strokeWeight(1.2);
  for(let x=0; x<=width; x+=GRID) line(x,0,x,height);
  for(let y=axisY; y<=height; y+=GRID) line(0,y,width,y);
  for(let y=axisY-GRID; y>=0; y-=GRID) line(0,y,width,y);
  pop();
}

/* ===== ë Œì¦ˆ ì‹¤ë£¨ì—£ ===== */
function drawLensSilhouette(x, f, type){
  const top = 24, bot = height-24;
  const h = bot - top;
  const leftPts = [], rightPts = [];
  const steps = 64;

  for(let i=0;i<=steps;i++){
    const t = i/steps, y = top + t*h, s = Math.sin(t*Math.PI);
    let half;
    if(type==='convex'){ half = 6 + 18*s; } else { half = 18 - 12*s; }
    leftPts.push({x:x - half, y}); rightPts.push({x:x + half, y});
  }

  push();
    noStroke(); fill(37, 99, 235, 40);
    beginShape();
      for(const p of leftPts)  vertex(p.x, p.y);
      for(let i=rightPts.length-1;i>=0;i--) vertex(rightPts[i].x, rightPts[i].y);
    endShape(CLOSE);

    stroke('#2563eb'); strokeWeight(2.2); noFill();
    beginShape(); for(const p of leftPts)  vertex(p.x, p.y); endShape();
    beginShape(); for(const p of rightPts) vertex(p.x, p.y); endShape();

    stroke('#60a5fa'); strokeWeight(1.6);
    line(x, top, x, bot);

    noStroke(); fill('#475569'); textAlign(CENTER,TOP); textSize(16);
    text((type==='convex')?'ë³¼ë¡ë Œì¦ˆ':'ì˜¤ëª©ë Œì¦ˆ', x, 2);
  pop();
}

function drawFoci(x, y, f){
  push();
  stroke('#93c5fd'); strokeWeight(2);
  line(x+f, y-8, x+f, y+8);
  line(x-f, y-8, x-f, y+8);
  noStroke(); fill('#64748b'); textAlign(CENTER, BOTTOM); textSize(16);
  text('F', x+f, y-10); text('F', x-f, y-10);
  pop();
}

function drawArrow(baseX, baseY, tipX, tipY, clr, solid=true, dashed=false){
  push();
  stroke(clr); strokeWeight(3);
  drawingContext.setLineDash(dashed ? [8,7] : []);
  line(baseX, baseY, tipX, tipY);
  const ang = Math.atan2(tipY-baseY, tipX-baseX);
  const ah = 13, a1 = ang + Math.PI*0.9, a2 = ang - Math.PI*0.9;
  line(tipX, tipY, tipX + ah*Math.cos(a1), tipY + ah*Math.sin(a1));
  line(tipX, tipY, tipX + ah*Math.cos(a2), tipY + ah*Math.sin(a2));
  pop();
}

function drawPrincipalRays({objTip, lensX, axisY, f, type, incomingLeft}){
  const F_left  = {x:lensX - Math.abs(f), y:axisY};
  const F_right = {x:lensX + Math.abs(f), y:axisY};
  const F_in  = incomingLeft ? F_left  : F_right;
  const F_out = incomingLeft ? F_right : F_left;
  const center = {x:lensX, y:axisY};

  push();
  stroke(255, 193, 7, 230); strokeWeight(2.4);
  line(objTip.x, objTip.y, lensX, objTip.y);
  if(type==='convex'){
    extendFromThrough({x:lensX,y:objTip.y}, F_out, incomingLeft ? +1 : -1);
  }else{
    const dir = {x: lensX - F_in.x, y: objTip.y - F_in.y};
    extendFromDir({x:lensX,y:objTip.y}, dir, incomingLeft ? +1 : -1);
    drawingContext.setLineDash([6,6]); stroke(255,193,7,140);
    extendFromDir({x:lensX,y:objTip.y}, {x:-dir.x,y:-dir.y}, incomingLeft ? -1 : +1);
    drawingContext.setLineDash([]);
  }
  pop();

  push();
  stroke(56, 189, 248, 230); strokeWeight(2.4);
  line(objTip.x, objTip.y, center.x, center.y);
  const dirC = {x: center.x - objTip.x, y: center.y - objTip.y};
  extendFromDir(center, dirC, incomingLeft ? +1 : -1);
  pop();

  push();
  stroke(168, 85, 247, 230); strokeWeight(2.4);
  const hit2 = lineIntersectionWithX(objTip, F_in, lensX);
  if(hit2){ line(objTip.x, objTip.y, hit2.x, hit2.y); extendHorizontal(hit2, incomingLeft ? +1 : -1); }
  pop();
}

function extendFromThrough(P, Q, sideSign){ const dir = {x: Q.x - P.x, y: Q.y - P.y}; extendFromDir(P, dir, sideSign); }
function extendFromDir(P, dir, sideSign){
  let t;
  if(sideSign>0){
    if(Math.abs(dir.x) < 1e-6){ line(P.x, P.y, width, P.y); return; }
    t = (width - P.x)/dir.x; line(P.x, P.y, width, P.y + dir.y * t);
  }else{
    if(Math.abs(dir.x) < 1e-6){ line(P.x, P.y, 0, P.y); return; }
    t = (0 - P.x)/dir.x; line(P.x, P.y, 0, P.y + dir.y * t);
  }
}
function extendHorizontal(P, sideSign){ if(sideSign>0) line(P.x,P.y,width,P.y); else line(P.x,P.y,0,P.y); }
function lineIntersectionWithX(A, B, xLine){
  const dx = B.x - A.x; if(Math.abs(dx) < 1e-6) return null;
  const t = (xLine - A.x) / dx; return {x:xLine, y: A.y + (B.y - A.y)*t};
}

/* ===== ì¸¡ì • í™”ì‚´í‘œ a, b ===== */
function drawMeasureAB({a, b, lensX, objectX, imgX, axisY, showB}){
  const yA = axisY + 30, yB = axisY + 58;
  drawDoubleArrow(min(lensX, objectX), max(lensX, objectX), yA, '#64748b', 'a');
  if(showB) drawDoubleArrow(min(lensX, imgX), max(lensX, imgX), yB, (b>0 ? '#16a34a' : '#ef4444'), 'b');
}
function drawDoubleArrow(x1, x2, y, colorHex, label){
  push();
    stroke(colorHex); strokeWeight(2.2);
    line(x1, y, x2, y);
    drawHead(x1, y, -1, colorHex); drawHead(x2, y, +1, colorHex);
    noStroke(); fill(colorHex); textAlign(CENTER, BOTTOM); textSize(16);
    text(label, (x1+x2)/2, y-4);
  pop();
}
function drawHead(x, y, dir, colorHex){
  const ah = 11; push(); stroke(colorHex); strokeWeight(2.2);
  line(x, y, x + dir*ah, y - ah*0.6);
  line(x, y, x + dir*ah, y + ah*0.6); pop();
}

function updateKV(f, a, b, m, atInf, incomingLeft){
  const fmt = (v)=> (Number.isFinite(v) ? (Math.abs(v)>9999 ? v.toExponential(2) : v.toFixed(2)) : 'â€”');
  const sideIn  = incomingLeft ? 'ì…ì‚¬ì¸¡(ì¢Œ)' : 'ì…ì‚¬ì¸¡(ìš°)';
  const sideOut = incomingLeft ? 'ì¶œì‚¬ì¸¡(ìš°)' : 'ì¶œì‚¬ì¸¡(ì¢Œ)';

  ui.kv.f.textContent  = `${fmt(f)} px  ${f>0?'(ë³¼ë¡)':'(ì˜¤ëª©)'}`;
  ui.kv.do.textContent = `${fmt(a)} px ${sideIn}  â‰¡  a`;
  if(atInf){
    ui.kv.di.textContent = 'âˆ (í‰í–‰)  â‰¡  b';
    ui.kv.m.textContent  = 'â€”';
    ui.kv.kind.innerHTML = `a â‰ˆ f  â†’  <span class="badge real">ìƒì´ ë¬´í•œ ì›ê±°ë¦¬</span>`;
  }else{
    const real = b>0;
    ui.kv.di.textContent = `${fmt(b)} px ${real?sideOut:sideIn}  â‰¡  b`;
    ui.kv.m.textContent  = `${fmt(m)} ${m>0?'(ì •ë¦½)':'(ë„ì¹˜)'}`;
    const mag = Math.abs(m)>1 ? 'í™•ëŒ€' : (Math.abs(m)<1 ? 'ì¶•ì†Œ' : 'ë™ì¼');
    ui.kv.kind.innerHTML =
      `<span class="badge ${real?'real':'virtual'}">${real?'ì‹¤ìƒ':'í—ˆìƒ'}</span>`+
      `<span class="badge" style="background:#e8efff;border:1px solid #c7d7ff;color:#1e40af">`+(m>0?'ì •ë¦½':'ë„ì¹˜')+`</span>`+
      `<span class="badge" style="background:#f1f5f9;border:1px solid #e2e8f0;color:#334155">${mag}</span>`;
  }
}

function drawHandles(){
  push();
  noStroke();
  fill('#2563eb');
  circle(objectX, axisY, 11);
  circle(objectX, axisY - objectH, 11);
  fill('#60a5fa');
  rect(lensX-4, 18, 8, 22, 3);
  pop();
}

/* ===== ë“œë˜ê·¸ ===== */
function pointerPressed(px, py){
  // ë„ì „ ê²Œì„ ì¤‘ì—ëŠ” ë“œë˜ê·¸ë¡œ ê°’ ë³€ê²½ ë¶ˆê°€
  if (lensGameOn) return;

  if(px<0 || px>width || py<0 || py>height) return;

  if(Math.abs(px - lensX) < 10){
    dragging='lens'; dragOffsetX=px-lensX; return;
  }
  if(dist(px, py, objectX, axisY) < 12){
    dragging='obj-base'; dragOffsetX=px-objectX; return;
  }
  if(dist(px, py, objectX, axisY - objectH) < 12){
    dragging='obj-tip'; dragOffsetX=px-objectX; dragOffsetY=py-(axisY-objectH); return;
  }
}

function pointerDragged(px, py){
  if(!dragging) return;

  if(dragging==='lens'){
    lensX = constrain(px - dragOffsetX, 40, width-40);
    if(Math.abs(lensX - objectX) < 10) lensX = (lensX > objectX) ? objectX + 10 : objectX - 10;
  }else if(dragging==='obj-base'){
    objectX = constrain(px - dragOffsetX, 20, width-20);
    if(Math.abs(lensX - objectX) < 10) objectX = (objectX < lensX) ? lensX - 10 : lensX + 10;
  }else if(dragging==='obj-tip'){
    objectX = constrain(px - dragOffsetX, 20, width-20);
    if(Math.abs(lensX - objectX) < 10) objectX = (objectX < lensX) ? lensX - 10 : lensX + 10;

    const tipY = py - dragOffsetY;
    const maxH = 240;
    objectH = constrain(axisY - tipY, -maxH, maxH);
  }
}

function pointerReleased(){
  dragging = null;
}

/* --- ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ --- */
function mousePressed(){ pointerPressed(mouseX, mouseY); }
function mouseDragged(){ pointerDragged(mouseX, mouseY); }
function mouseReleased(){ pointerReleased(); }

/* --- í„°ì¹˜ ì´ë²¤íŠ¸ --- */
function isTouchOnUI(e){
  if(!e || !e.target) return false;

  // ì˜¤ë¥¸ìª½ ì„¤ì • íŒ¨ë„(.overlay), ë„ì „íŒ¨ë„(#lens-challenge), íŒíŠ¸(.hint) ìœ„ì—ì„œëŠ”
  // ë¸Œë¼ìš°ì €ê°€ ê¸°ë³¸ì ìœ¼ë¡œ "íƒ­=í´ë¦­/ì…€ë ‰íŠ¸"ë¥¼ ì²˜ë¦¬í•˜ë„ë¡ ë§¡ê¸´ë‹¤.
  return !!(
    e.target.closest('.overlay') ||
    e.target.closest('#lens-challenge') ||
    e.target.closest('.hint')
  );
}

/* --- í„°ì¹˜ ì´ë²¤íŠ¸ --- */
function touchStarted(e){
  if (isTouchOnUI(e)) return true; // âœ… UI í„°ì¹˜ëŠ” p5ê°€ ê°€ë¡œì±„ì§€ ì•ŠìŒ

  if(touches && touches.length){
    pointerPressed(touches[0].x, touches[0].y);
  }
  return false; // âœ… ìº”ë²„ìŠ¤ ì¡°ì‘ì¼ ë•Œë§Œ ìŠ¤í¬ë¡¤ ë°©ì§€
}

function touchMoved(e){
  if (isTouchOnUI(e)) return true; // âœ… UIì—ì„œ ìŠ¤ì™€ì´í”„/íƒ­ ë§‰ì§€ ì•ŠìŒ

  if(touches && touches.length){
    pointerDragged(touches[0].x, touches[0].y);
  }
  return false;
}

function touchEnded(e){
  if (isTouchOnUI(e)) return true;

  pointerReleased();
  return false;
}</script>

<!-- ===== ë Œì¦ˆ ë„ì „ ê²Œì„ ë¡œì§ (ì ìˆ˜/íŒì •) ===== -->
<script>
(function(){
  const elRound = document.getElementById('lens-round');
  const elScore = document.getElementById('lens-score');
  const elBest  = document.getElementById('lens-best');
  const elMsg   = document.getElementById('lens-msg');
  const btnStart  = document.getElementById('lens-start');
  const kindButtons = document.querySelectorAll('.cb-opt-kind');
  const sizeSection = document.querySelector('.cb-size-section');
  const sizeButtons = document.querySelectorAll('.cb-opt-size');

  let score = 0;
  let bestScore = 0;
  let answerKind = null;   // 'ë„ë¦½ì‹¤ìƒ' ë“±
  let answerSize = null;   // 'í™•ëŒ€','ë™ì¼','ì¶•ì†Œ' (9~10ë¼ìš´ë“œì—ì„œ ì‚¬ìš©)
  let selectedKind = null;
  let selectedSize = null;

  function updateBestScoreUI(animate){
    if(!elBest) return;
    elBest.textContent = bestScore;
    const badge = document.querySelector('#lens-challenge .best-badge');
    if(animate && badge){
      badge.classList.remove('best-bump');
      void badge.offsetWidth;            // reflow
      badge.classList.add('best-bump');  // ì• ë‹ˆë©”ì´ì…˜
    }
  }

  // Firebaseì—ì„œ ìµœê³ ì ìˆ˜ë¥¼ ë¶ˆëŸ¬ì™”ì„ ë•Œ í˜¸ì¶œë˜ëŠ” ì½œë°± (ìƒëŒ€ì„±ì´ë¡  íŒŒì¼ê³¼ ë™ì¼í•œ ì´ë¦„)
  window.setBestScoreFromFirebase = function(scoreFromDb){
    bestScore = Number(scoreFromDb) || 0;
    updateBestScoreUI(false);
  };

  function selectKind(kind){
    selectedKind = kind;
    kindButtons.forEach(btn=>{
      btn.classList.toggle('selected', btn.dataset.kind === kind);
    });
  }

  function selectSize(size){
    selectedSize = size;
    sizeButtons.forEach(btn=>{
      btn.classList.toggle('selected', btn.dataset.size === size);
    });
  }

  function resetGame(){
    score = 0;
    lensGameOn = false;
    lensGameRound = 0;
    lensRoundLocked = false;
    elRound.textContent = '-';
    elScore.textContent = '0';
    selectedKind = null;
    selectedSize = null;
    kindButtons.forEach(btn=>btn.classList.remove('selected'));
    sizeButtons.forEach(btn=>btn.classList.remove('selected'));
    sizeSection.style.display = 'none';
    elMsg.innerHTML =
      'ë„ì „ ë²„íŠ¼ì„ ëˆŒëŸ¬<br>ë Œì¦ˆ ë„ì „ ê²Œì„ì„ ì‹œì‘í•˜ì„¸ìš”.'+
      '<small>ì´ 10ë¼ìš´ë“œ, ì •ë‹µë§ˆë‹¤ +50ì  Â· ì˜¤ë‹µì€ 0ì </small>';
  }
  resetGame();

  function randomBetween(min, max){
    return min + Math.random() * (max - min);
  }

  // í˜„ì¬ ì„¤ì •ì—ì„œ ìƒì˜ ì¢…ë¥˜/í¬ê¸° ê³„ì‚°
  function computeImageState(type, f, lensXNow, objectXNow, objectHNow){
    const a = Math.abs(lensXNow - objectXNow);
    if(a < 5) return {valid:false};
    const denom = (1/f) - (1/a);
    if(!isFinite(denom) || Math.abs(denom) < 1e-4){
      return {valid:false, atInfinity:true};
    }
    const b = 1/denom;
    const m = -b/a;
    const isReal = (b > 0);

    let kindLabel = null;
    if (isReal && m < 0)      kindLabel = 'ë„ë¦½ì‹¤ìƒ';
    else if (isReal && m > 0) kindLabel = 'ì •ë¦½ì‹¤ìƒ';
    else if (!isReal && m < 0)kindLabel = 'ë„ë¦½í—ˆìƒ';
    else if (!isReal && m > 0)kindLabel = 'ì •ë¦½í—ˆìƒ';

    const mag = Math.abs(m);
    const tol = 0.08;
    let sizeLabel;
    if (mag > 1 + tol)      sizeLabel = 'í™•ëŒ€';
    else if (mag < 1 - tol) sizeLabel = 'ì¶•ì†Œ';
    else                    sizeLabel = 'ë™ì¼';

    return {valid:true, atInfinity:false, kindLabel, sizeLabel, m};
  }

  function setupRound(){
    lensGameOn = true;
    lensRoundLocked = false;
    elScore.textContent = String(score);
    elRound.textContent = lensGameRound + '/10';

    selectedKind = null;
    selectedSize = null;
    kindButtons.forEach(btn=>btn.classList.remove('selected'));
    sizeButtons.forEach(btn=>btn.classList.remove('selected'));

    const requiresSize = lensGameRound >= 9;
    sizeSection.style.display = requiresSize ? 'block' : 'none';

    // === ëœë¤ íŒŒë¼ë¯¸í„° ìƒì„± (ë Œì¦ˆ ì¢…ë¥˜, f, a, ë¬¼ì²´ ë†’ì´) ===
    const type = (Math.random() < 0.5) ? 'convex' : 'concave';
    ui.lensType.value = type;

    const fmag = randomBetween(60, 260);
    ui.focal.value = String(Math.round(fmag));
    const fSign = (type === 'convex') ? +1 : -1;
    const f = fSign * Math.round(fmag);

    const marginLeft = Math.max(40, W * 0.12);
    const marginRightOfObject = 40;
    const minObjectX = marginLeft;
    const maxObjectX = lensX - marginRightOfObject;
    const minH = 60;
    const maxH = 180;

    let trials = 0;
    answerKind = null;
    answerSize = null;

    while(trials < 80){
      objectX = randomBetween(minObjectX, maxObjectX);
      objectH = (Math.random() < 0.5 ? 1 : -1) * randomBetween(minH, maxH);

      // ë¬¼ì²´ ê¼­ì§“ì ì´ í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šë„ë¡ ë³´ì •
      let tipY = axisY - objectH;
      if (tipY < 40)  objectH = axisY - 40;
      if (tipY > H-40) objectH = axisY - (H-40);

      const state = computeImageState(type, f, lensX, objectX, objectH);
      if (!state.valid || state.atInfinity || !state.kindLabel) {
        trials++;
        continue;
      }
      // 9~10ë¼ìš´ë“œì—ëŠ” í¬ê¸°ë„ ëª…í™•í•˜ê²Œ êµ¬ë¶„ë˜ë„ë¡
      if (requiresSize && !state.sizeLabel) {
        trials++;
        continue;
      }
      answerKind = state.kindLabel;
      answerSize = requiresSize ? state.sizeLabel : null;
      break;
    }

    if(lensGameRound <= 5){
      elMsg.innerHTML =
        'ì™¼ìª½ ë¬¼ì²´ì™€ ë Œì¦ˆì—ì„œ ë§Œë“¤ì–´ì§„ ì˜¤ë¥¸ìª½ ìƒì„ ë³´ê³ <br>'+
        '<b>ìƒì´ ë„ë¦½/ì •ë¦½ & ì‹¤ìƒ/í—ˆìƒ</b>ì´<br>ì–´ë–¤ ì¡°í•©ì¸ì§€ ì„ íƒí•˜ì„¸ìš”.';
    }else if(lensGameRound <= 8){
      elMsg.innerHTML =
        'ë Œì¦ˆ ì¤‘ì‹¬ë¶€í„° ì˜¤ë¥¸ìª½ì´ ê°€ë ¤ì§„ ìƒíƒœì…ë‹ˆë‹¤.<br>'+
        'ê´‘ì„  ì§„í–‰ê³¼ ë Œì¦ˆ ê³µì‹ì„ ë– ì˜¬ë¦¬ë©°<br>'+
        '<b>ìƒì´ ë„ë¦½/ì •ë¦½ & ì‹¤ìƒ/í—ˆìƒ</b>ì„ ì¶”ë¡ í•´ ë³´ì„¸ìš”.';
    }else{
      elMsg.innerHTML =
        'ìƒì´ ë„ë¦½/ì •ë¦½ & ì‹¤ìƒ/í—ˆìƒì— ë”í•´<br>'+
        '<b>í¬ê¸°ê°€ í™•ëŒ€/ë™ì¼/ì¶•ì†Œ</b>ì¸ì§€ê¹Œì§€ í•¨ê»˜ ë§ì¶° ë³´ì„¸ìš”.';
    }
  }

  function startGame(){
    score = 0;
    elScore.textContent = '0';
    lensGameRound = 1;
    lensGameOn = true;
    updateBestScoreUI(false);
    setupRound();
  }

  function endGame(){
    lensGameOn = false;
    lensRoundLocked = false;
    const finalScore = score;
    lensGameRound = 0;
    elRound.textContent = '-';
    elMsg.innerHTML =
      `ê²Œì„ì´ ëë‚¬ìŠµë‹ˆë‹¤.<br>ìµœì¢… ì ìˆ˜: <b>${finalScore}ì </b>`;
  }

  function handleResult(isCorrect){
    lensRoundLocked = true;

    if(isCorrect){
      score += 50;
      elScore.textContent = String(score);
      if(score > bestScore){
        bestScore = score;
        updateBestScoreUI(true);
        if(window.saveBestScoreToFirebase){
          window.saveBestScoreToFirebase(bestScore);
        }
      }else{
        updateBestScoreUI(false);
      }
      elMsg.innerHTML =
        'âœ… ì •ë‹µì…ë‹ˆë‹¤! +50ì <br><small>ë‹¤ìŒ ë¼ìš´ë“œë¡œ ë„˜ì–´ê°‘ë‹ˆë‹¤.</small>';
    }else{
      elMsg.innerHTML =
        'âŒ ì˜¤ë‹µì…ë‹ˆë‹¤. ì´ë²ˆ ë¼ìš´ë“œëŠ” 0ì ì…ë‹ˆë‹¤.<br><small>ë‹¤ìŒ ë¼ìš´ë“œë¡œ ë„˜ì–´ê°‘ë‹ˆë‹¤.</small>';
    }

    if(lensGameRound >= 10){
      setTimeout(()=>{
        endGame();
      }, 600);
    }else{
      setTimeout(()=>{
        lensGameRound++;
        setupRound();
      }, 600);
    }
  }

  function checkAnswerAndAdvance(){
    if(!lensGameOn || lensGameRound === 0) return;
    if(!answerKind){
      elMsg.innerHTML = 'ë¼ìš´ë“œ ì„¸íŒ… ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë„ì „í•´ ì£¼ì„¸ìš”.';
      return;
    }

    const requiresSize = lensGameRound >= 9;
    const correctKind = (selectedKind === answerKind);
    let correctSize = true;

    if(requiresSize){
      if(!answerSize){
        elMsg.innerHTML = 'ë¼ìš´ë“œ ì„¸íŒ… ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë„ì „í•´ ì£¼ì„¸ìš”.';
        return;
      }
      correctSize = (selectedSize === answerSize);
    }

    const isCorrect = correctKind && correctSize;
    handleResult(isCorrect);
  }

  // ìƒì˜ ì¢…ë¥˜ ë²„íŠ¼: 1~8ë¼ìš´ë“œëŠ” ì´ ë²„íŠ¼ì„ ëˆ„ë¥´ëŠ” ìˆœê°„ ë°”ë¡œ ì±„ì ,
  // 9~10ë¼ìš´ë“œëŠ” í¬ê¸°ê¹Œì§€ ì„ íƒí•œ ë’¤ (í¬ê¸° ë²„íŠ¼ í´ë¦­ ì‹œ) ì±„ì 
  kindButtons.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      if (lensRoundLocked) return;
      selectKind(btn.dataset.kind);

      if(!lensGameOn || lensGameRound === 0){
        elMsg.innerHTML = 'ë¨¼ì € <b>ë„ì „</b> ë²„íŠ¼ì„ ëˆŒëŸ¬ ë¼ìš´ë“œë¥¼ ì‹œì‘í•´ ì£¼ì„¸ìš”.';
        return;
      }

      if(lensGameRound <= 8){
        // 1~8ë¼ìš´ë“œëŠ” ìƒì˜ ì¢…ë¥˜ë§Œìœ¼ë¡œ ì±„ì 
        checkAnswerAndAdvance();
      }else{
        // 9~10ë¼ìš´ë“œëŠ” í¬ê¸°ë„ í•„ìš” â†’ í¬ê¸°ê¹Œì§€ ì„ íƒë˜ë©´ ì±„ì 
        if(selectedSize){
          checkAnswerAndAdvance();
        }else{
          elMsg.innerHTML =
            'ì´ì œ <b>í¬ê¸°(í™•ëŒ€/ë™ì¼/ì¶•ì†Œ)</b>ë„ ì„ íƒí•´ ì£¼ì„¸ìš”.';
        }
      }
    });
  });

  // í¬ê¸° ë²„íŠ¼: 9~10ë¼ìš´ë“œì—ì„œë§Œ ì‚¬ìš©, ì´ ë²„íŠ¼ì„ ëˆ„ë¥´ëŠ” ìˆœê°„ ì±„ì 
  sizeButtons.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      if (lensRoundLocked) return;
      selectSize(btn.dataset.size);

      if(!lensGameOn || lensGameRound === 0){
        elMsg.innerHTML = 'ë¨¼ì € <b>ë„ì „</b> ë²„íŠ¼ì„ ëˆŒëŸ¬ ë¼ìš´ë“œë¥¼ ì‹œì‘í•´ ì£¼ì„¸ìš”.';
        return;
      }

      if(lensGameRound < 9){
        elMsg.innerHTML = '9~10ë¼ìš´ë“œì—ì„œë§Œ í¬ê¸°ë¥¼ í•¨ê»˜ ë§ì¶”ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.';
        return;
      }

      if(!selectedKind){
        elMsg.innerHTML =
          '<b>ìƒì˜ ì¢…ë¥˜</b>ë¥¼ ë¨¼ì € ì„ íƒí•œ ë’¤ í¬ê¸°ë¥¼ ì„ íƒí•´ ì£¼ì„¸ìš”.';
        return;
      }

      // 9~10ë¼ìš´ë“œ: ì¢…ë¥˜+í¬ê¸° ëª¨ë‘ ì„ íƒë˜ë©´ ë°”ë¡œ ì±„ì 
      checkAnswerAndAdvance();
    });
  });

  btnStart.addEventListener('click', startGame);
})();
</script>

<!-- ===== Firebase ì ìˆ˜ ì—°ë™ (ë Œì¦ˆ ë„ì „ ê²Œì„) ===== -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
  import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";
  import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCO36JgPpNz8swADxTMVJUFVALWM5o171w",
    authDomain: "simulation-67cd3.firebaseapp.com",
    projectId: "simulation-67cd3",
    storageBucket: "simulation-67cd3.appspot.com",
    messagingSenderId: "615983461615",
    appId: "1:615983461615:web:002e07bcea878eb6d5571a",
    measurementId: "G-9RGN7LYE5W"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  // ìƒëŒ€ì„±ì´ë¡  íŒŒì¼ê³¼ ë™ì¼í•œ êµ¬ì¡°: users/{uid}/simulations/{SIM_ID} ì— score í•„ë“œ ì €ì¥
  const SIM_ID = "ë Œì¦ˆ_êµ´ì ˆ_ë„ì „ê²Œì„";
  let firebaseUser = null;

  async function saveBestScore(score) {
    if (!firebaseUser) return;
    try {
      const ref = doc(db, "users", firebaseUser.uid, "simulations", SIM_ID);
      await setDoc(ref, { score: Number(score) || 0 }, { merge: true });
    } catch (err) {
      console.error("[ë Œì¦ˆ ë„ì „] ìµœê³  ì ìˆ˜ ì €ì¥ ì˜¤ë¥˜:", err);
    }
  }

  async function loadBestScore() {
    if (!firebaseUser) return;
    try {
      const ref = doc(db, "users", firebaseUser.uid, "simulations", SIM_ID);
      const snap = await getDoc(ref);
      if (snap.exists()) {
        const data = snap.data();
        const score = Number(data.score || 0) || 0;
        if (window.setBestScoreFromFirebase) {
          window.setBestScoreFromFirebase(score);
        }
      }
    } catch (err) {
      console.error("[ë Œì¦ˆ ë„ì „] ìµœê³  ì ìˆ˜ ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜:", err);
    }
  }

  // ìƒëŒ€ì„±ì´ë¡  íŒŒì¼ê³¼ ë™ì¼í•œ ì „ì—­ ì´ë¦„
  window.saveBestScoreToFirebase = saveBestScore;

  onAuthStateChanged(auth, async (user) => {
    firebaseUser = user;
    if (user) {
      await loadBestScore();
    }
  });
</script>

</body>
</html>
