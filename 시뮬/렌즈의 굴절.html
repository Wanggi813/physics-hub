<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>얇은 렌즈 시뮬레이터 · Fullscreen p5.js (값박스 토글)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="https://unpkg.com/p5@1.9.0/lib/p5.min.js"></script>
<style>
  :root{
    --bg1:#f7fbff; --bg2:#eef6ff; --ink:#0f172a; --sub:#546076; --axis:#2563eb;
    --accent:#2563eb; --good:#16a34a; --warn:#f59e0b; --bad:#ef4444;
    --panel:#ffffff; --line:#e6eef9; --shadow:0 12px 36px rgba(15,23,42,.12); --radius:14px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--ink);
    background: radial-gradient(1200px 800px at 10% -10%, var(--bg2) 0%, var(--bg1) 60%);
    font:16px/1.7 system-ui,-apple-system,Segoe UI,Roboto,Pretendard,'Noto Sans KR',sans-serif;
  }
  #sketch{position:fixed; inset:0}
  .overlay{
    position:fixed; top:14px; right:14px; z-index:10; width:min(380px, 92vw);
    background:var(--panel); border:1px solid var(--line); border-radius:var(--radius); box-shadow:var(--shadow);
    padding:14px 14px 12px;
  }
  .overlay h2{margin:0 0 8px; font-size:17px}
  .row{display:flex; align-items:center; gap:10px; margin:10px 0}
  label{font-size:14.5px; color:var(--sub)}
  select,input[type="range"]{width:100%; accent-color:var(--accent)}
  .kv{display:grid; grid-template-columns:1fr 1fr; gap:10px 14px; margin-top:10px}
  .kv div{background:#f7fafc; border:1px solid var(--line); border-radius:10px; padding:8px 10px; font-size:15px}
  .kv b{display:block; font-weight:700; color:#65748b; margin-bottom:3px; font-size:14px}
  .badge{display:inline-block; padding:3px 10px; border-radius:999px; font-size:13px; margin-right:6px}
  .real{background:#e8f7ee; border:1px solid #b7ebc3; color:#065f46}
  .virtual{background:#ffecec; border:1px solid #ffc6c6; color:#7f1d1d}
  .note{color:#65748b; font-size:14px; margin-top:8px}
  .hint{position:fixed; left:14px; bottom:14px; background:#ffffffcc; backdrop-filter: blur(4px);
        border:1px solid var(--line); border-radius:12px; padding:9px 12px; box-shadow:var(--shadow); font-size:14px}
  .hidden{display:none}
  canvas{display:block}
</style>
</head>
<body>
  <div id="sketch"></div>

  <div class="overlay">
    <h2>설정</h2>
    <div class="row">
      <label for="lensType">렌즈 종류</label>
      <select id="lensType">
        <option value="convex">볼록렌즈 (수렴, f &gt; 0)</option>
        <option value="concave">오목렌즈 (발산, f &lt; 0)</option>
      </select>
    </div>
    <div class="row">
      <label for="focal" style="min-width:110px">초점거리 |f| (px)</label>
      <input id="focal" type="range" min="40" max="300" value="160" />
    </div>
    <div class="row" style="gap:14px; flex-wrap:wrap">
      <label><input type="checkbox" id="showRays" checked /> 주광선</label>
      <label><input type="checkbox" id="showGrid" checked /> 격자</label>
      <label><input type="checkbox" id="showInfo" /> 값 표시</label>
      <label><input type="checkbox" id="showGuide" checked /> a,b & 허상 보조선</label>
    </div>

    <!-- ▼ 값 섹션 전체를 래핑: 토글로 통째로 숨김 -->
    <div id="kvSection">
      <h2>실시간 값</h2>
      <div class="kv" id="kv">
        <div><b>초점거리 f</b><span id="kv_f">—</span></div>
        <div><b>물체거리 d<sub>o</sub> (= a)</b><span id="kv_do">—</span></div>
        <div><b>상거리 d<sub>i</sub> (= b)</b><span id="kv_di">—</span></div>
        <div><b>배율 m</b><span id="kv_m">—</span></div>
        <div style="grid-column:1 / -1"><b>상의 성격</b><span id="kv_kind">—</span></div>
      </div>
      <p class="note">공식: <em>1/f = 1/a + 1/b, &nbsp; m = -b/a</em> (표준부호: a&gt;0, b&gt;0(실상)/b&lt;0(허상))</p>
    </div>
    <!-- ▲ 값 섹션 -->
  </div>

  <div class="hint">드래그: 렌즈 세로선, 물체 밑점 ●, 화살촉 ●</div>

<script>
/* ===== Fullscreen Lens Simulator (값 박스 토글) ===== */
let W, H, axisY;
let lensX;
let objectX, objectH;
let dragging = null;
let dragOffsetX = 0, dragOffsetY = 0;

let ui = {};
const EPS = 1e-4;
const GRID = 72;

function setup(){
  pixelDensity(1);
  createCanvas(windowWidth, windowHeight).parent('sketch');
  initLayout();

  ui.lensType = document.getElementById('lensType');
  ui.focal    = document.getElementById('focal');
  ui.showRays = document.getElementById('showRays');
  ui.showGrid = document.getElementById('showGrid');
  ui.showInfo = document.getElementById('showInfo');
  ui.showGuide= document.getElementById('showGuide');
  ui.kvSection= document.getElementById('kvSection');
  ui.kv = {
    f:  document.getElementById('kv_f'),
    do: document.getElementById('kv_do'),
    di: document.getElementById('kv_di'),
    m:  document.getElementById('kv_m'),
    kind: document.getElementById('kv_kind'),
  };

  // 값 표시 체크박스와 연동: 켜면 보이고, 끄면 섹션 통째로 숨김
  const applyKvVisibility = () => {
    if (ui.showInfo.checked) ui.kvSection.classList.remove('hidden');
    else                     ui.kvSection.classList.add('hidden');
  };
  ui.showInfo.addEventListener('change', applyKvVisibility);
  applyKvVisibility(); // 초기 적용(기본: 숨김)
}

function initLayout(){
  W = windowWidth; H = windowHeight;
  const rawAxis = H * 0.58;
  axisY = Math.round(rawAxis / GRID) * GRID;
  lensX = W * 0.5;
  objectX = W * 0.25;
  objectH = 120;
}

function windowResized(){
  resizeCanvas(windowWidth, windowHeight);
  W = windowWidth; H = windowHeight;
  const rawAxis = H * 0.58;
  axisY = Math.round(rawAxis / GRID) * GRID;
  lensX   = constrain(lensX, 40, W-40);
  objectX = constrain(objectX, 20, W-20);
}

function draw(){
  clear();
  noStroke(); fill(255,255,255,230); rect(0,0,width,height);

  const type = ui.lensType.value;
  const fmag = parseFloat(ui.focal.value);
  const f = (type==='convex') ? +fmag : -fmag;

  if(ui.showGrid.checked) drawGrid();

  stroke('#2563eb'); strokeWeight(2.2);
  line(0, axisY, width, axisY);

  drawLensSilhouette(lensX, f, type);

  const objTip = {x: objectX, y: axisY - objectH};
  drawArrow(objectX, axisY, objTip.x, objTip.y, color(37,99,235), true);

  const incomingLeft = objectX < lensX;
  const a = Math.abs(lensX - objectX);
  const denom = (1/f) - (1/a);
  let atInfinity = false, b, m;

  if(Math.abs(denom) < EPS){ atInfinity = true; b = Infinity; m = NaN; }
  else { b = 1/denom; m = -b/a; }

  const imgX = atInfinity ? (incomingLeft ? width-10 : 10)
                          : (incomingLeft ? lensX + b : lensX - b);
  const imgH = atInfinity ? 0 : objectH * m;
  const imgTip = {x: imgX, y: axisY - imgH};
  const isReal = !atInfinity && (b > 0);

  if(ui.showRays.checked){
    drawPrincipalRays({objTip, lensX, axisY, f, type, incomingLeft});
  }

  if(!atInfinity){
    const clr = isReal ? color(22,163,74) : color(239,68,68);
    drawArrow(imgX, axisY, imgTip.x, imgTip.y, clr, isReal, !isReal);
  }else{
    push(); noStroke(); fill('#f59e0b'); textAlign(CENTER, BOTTOM); textSize(16);
    text('a ≈ f  →  상이 무한 원거리(평행광)', width*0.5, 26); pop();
  }

  if(ui.showGuide.checked && !atInfinity && !isReal){
    const passPt = {x: lensX, y: objTip.y};
    push();
      stroke(100,116,139); strokeWeight(2);
      drawingContext.setLineDash([7,7]);
      line(passPt.x, passPt.y, imgTip.x, imgTip.y);
      drawingContext.setLineDash([]);
      noStroke(); fill(100,116,139);
      circle(passPt.x, passPt.y, 6);
      circle(imgTip.x, imgTip.y, 6);
    pop();
  }

  drawFoci(lensX, axisY, f);

  if(ui.showGuide.checked){
    drawMeasureAB({a, b, lensX, objectX, imgX, axisY, showB: !atInfinity});
  }

  drawHandles();

  // 값 패널 업데이트는 체크 시에만 수행
  if(ui.showInfo.checked){
    updateKV(f, a, b, m, atInfinity, incomingLeft);
  }
}

function drawGrid(){
  push();
  stroke('#e6eef9'); strokeWeight(1.2);
  for(let x=0; x<=width; x+=GRID) line(x,0,x,height);
  for(let y=axisY; y<=height; y+=GRID) line(0,y,width,y);
  for(let y=axisY-GRID; y>=0; y-=GRID) line(0,y,width,y);
  pop();
}

/* ===== 렌즈 실루엣 ===== */
function drawLensSilhouette(x, f, type){
  const top = 24, bot = height-24;
  const h = bot - top;
  const leftPts = [], rightPts = [];
  const steps = 64;

  for(let i=0;i<=steps;i++){
    const t = i/steps, y = top + t*h, s = Math.sin(t*Math.PI);
    let half;
    if(type==='convex'){ half = 6 + 18*s; } else { half = 18 - 12*s; }
    leftPts.push({x:x - half, y}); rightPts.push({x:x + half, y});
  }

  push();
    noStroke(); fill(37, 99, 235, 40);
    beginShape();
      for(const p of leftPts)  vertex(p.x, p.y);
      for(let i=rightPts.length-1;i>=0;i--) vertex(rightPts[i].x, rightPts[i].y);
    endShape(CLOSE);

    stroke('#2563eb'); strokeWeight(2.2); noFill();
    beginShape(); for(const p of leftPts)  vertex(p.x, p.y); endShape();
    beginShape(); for(const p of rightPts) vertex(p.x, p.y); endShape();

    stroke('#60a5fa'); strokeWeight(1.6);
    line(x, top, x, bot);

    noStroke(); fill('#475569'); textAlign(CENTER,TOP); textSize(16);
    text((type==='convex')?'볼록렌즈':'오목렌즈', x, 2);
  pop();
}

function drawFoci(x, y, f){
  push();
  stroke('#93c5fd'); strokeWeight(2);
  line(x+f, y-8, x+f, y+8);
  line(x-f, y-8, x-f, y+8);
  noStroke(); fill('#64748b'); textAlign(CENTER, BOTTOM); textSize(16);
  text('F', x+f, y-10); text('F', x-f, y-10);
  pop();
}

function drawArrow(baseX, baseY, tipX, tipY, clr, solid=true, dashed=false){
  push();
  stroke(clr); strokeWeight(3);
  drawingContext.setLineDash(dashed ? [8,7] : []);
  line(baseX, baseY, tipX, tipY);
  const ang = Math.atan2(tipY-baseY, tipX-baseX);
  const ah = 13, a1 = ang + Math.PI*0.9, a2 = ang - Math.PI*0.9;
  line(tipX, tipY, tipX + ah*Math.cos(a1), tipY + ah*Math.sin(a1));
  line(tipX, tipY, tipX + ah*Math.cos(a2), tipY + ah*Math.sin(a2));
  pop();
}

function drawPrincipalRays({objTip, lensX, axisY, f, type, incomingLeft}){
  const F_left  = {x:lensX - Math.abs(f), y:axisY};
  const F_right = {x:lensX + Math.abs(f), y:axisY};
  const F_in  = incomingLeft ? F_left  : F_right;
  const F_out = incomingLeft ? F_right : F_left;
  const center = {x:lensX, y:axisY};

  push();
  stroke(255, 193, 7, 230); strokeWeight(2.4);
  line(objTip.x, objTip.y, lensX, objTip.y);
  if(type==='convex'){
    extendFromThrough({x:lensX,y:objTip.y}, F_out, incomingLeft ? +1 : -1);
  }else{
    const dir = {x: lensX - F_in.x, y: objTip.y - F_in.y};
    extendFromDir({x:lensX,y:objTip.y}, dir, incomingLeft ? +1 : -1);
    drawingContext.setLineDash([6,6]); stroke(255,193,7,140);
    extendFromDir({x:lensX,y:objTip.y}, {x:-dir.x,y:-dir.y}, incomingLeft ? -1 : +1);
    drawingContext.setLineDash([]);
  }
  pop();

  push();
  stroke(56, 189, 248, 230); strokeWeight(2.4);
  line(objTip.x, objTip.y, center.x, center.y);
  const dirC = {x: center.x - objTip.x, y: center.y - objTip.y};
  extendFromDir(center, dirC, incomingLeft ? +1 : -1);
  pop();

  push();
  stroke(168, 85, 247, 230); strokeWeight(2.4);
  const hit2 = lineIntersectionWithX(objTip, F_in, lensX);
  if(hit2){ line(objTip.x, objTip.y, hit2.x, hit2.y); extendHorizontal(hit2, incomingLeft ? +1 : -1); }
  pop();
}

function extendFromThrough(P, Q, sideSign){ const dir = {x: Q.x - P.x, y: Q.y - P.y}; extendFromDir(P, dir, sideSign); }
function extendFromDir(P, dir, sideSign){
  let t;
  if(sideSign>0){
    if(Math.abs(dir.x) < 1e-6){ line(P.x, P.y, width, P.y); return; }
    t = (width - P.x)/dir.x; line(P.x, P.y, width, P.y + dir.y * t);
  }else{
    if(Math.abs(dir.x) < 1e-6){ line(P.x, P.y, 0, P.y); return; }
    t = (0 - P.x)/dir.x; line(P.x, P.y, 0, P.y + dir.y * t);
  }
}
function extendHorizontal(P, sideSign){ if(sideSign>0) line(P.x,P.y,width,P.y); else line(P.x,P.y,0,P.y); }
function lineIntersectionWithX(A, B, xLine){
  const dx = B.x - A.x; if(Math.abs(dx) < 1e-6) return null;
  const t = (xLine - A.x) / dx; return {x:xLine, y: A.y + (B.y - A.y)*t};
}

/* ===== 측정 화살표 a, b ===== */
function drawMeasureAB({a, b, lensX, objectX, imgX, axisY, showB}){
  const yA = axisY + 30, yB = axisY + 58;
  drawDoubleArrow(min(lensX, objectX), max(lensX, objectX), yA, '#64748b', 'a');
  if(showB) drawDoubleArrow(min(lensX, imgX), max(lensX, imgX), yB, (b>0 ? '#16a34a' : '#ef4444'), 'b');
}
function drawDoubleArrow(x1, x2, y, colorHex, label){
  push();
    stroke(colorHex); strokeWeight(2.2);
    line(x1, y, x2, y);
    drawHead(x1, y, -1, colorHex); drawHead(x2, y, +1, colorHex);
    noStroke(); fill(colorHex); textAlign(CENTER, BOTTOM); textSize(16);
    text(label, (x1+x2)/2, y-4);
  pop();
}
function drawHead(x, y, dir, colorHex){
  const ah = 11; push(); stroke(colorHex); strokeWeight(2.2);
  line(x, y, x + dir*ah, y - ah*0.6);
  line(x, y, x + dir*ah, y + ah*0.6); pop();
}

function updateKV(f, a, b, m, atInf, incomingLeft){
  const fmt = (v)=> (Number.isFinite(v) ? (Math.abs(v)>9999 ? v.toExponential(2) : v.toFixed(2)) : '—');
  const sideIn  = incomingLeft ? '입사측(좌)' : '입사측(우)';
  const sideOut = incomingLeft ? '출사측(우)' : '출사측(좌)';

  ui.kv.f.textContent  = `${fmt(f)} px  ${f>0?'(볼록)':'(오목)'}`;
  ui.kv.do.textContent = `${fmt(a)} px ${sideIn}  ≡  a`;
  if(atInf){
    ui.kv.di.textContent = '∞ (평행)  ≡  b';
    ui.kv.m.textContent  = '—';
    ui.kv.kind.innerHTML = `a ≈ f  →  <span class="badge real">상이 무한 원거리</span>`;
  }else{
    const real = b>0;
    ui.kv.di.textContent = `${fmt(b)} px ${real?sideOut:sideIn}  ≡  b`;
    ui.kv.m.textContent  = `${fmt(m)} ${m>0?'(정립)':'(도치)'}`;
    const mag = Math.abs(m)>1 ? '확대' : (Math.abs(m)<1 ? '축소' : '동일');
    ui.kv.kind.innerHTML =
      `<span class="badge ${real?'real':'virtual'}">${real?'실상':'허상'}</span>`+
      `<span class="badge" style="background:#e8efff;border:1px solid #c7d7ff;color:#1e40af">`+(m>0?'정립':'도치')+`</span>`+
      `<span class="badge" style="background:#f1f5f9;border:1px solid #e2e8f0;color:#334155">${mag}</span>`;
  }
}

function drawHandles(){
  push();
  noStroke();
  fill('#2563eb');
  circle(objectX, axisY, 11);
  circle(objectX, axisY - objectH, 11);
  fill('#60a5fa');
  rect(lensX-4, 18, 8, 22, 3);
  pop();
}

/* ===== 드래그 ===== */
function mousePressed(){
  if(mouseX<0 || mouseX>width || mouseY<0 || mouseY>height) return;
  if(Math.abs(mouseX - lensX) < 10){ dragging='lens'; dragOffsetX=mouseX-lensX; return; }
  if(dist(mouseX, mouseY, objectX, axisY) < 12){ dragging='obj-base'; dragOffsetX=mouseX-objectX; return; }
  if(dist(mouseX, mouseY, objectX, axisY - objectH) < 12){
    dragging='obj-tip'; dragOffsetX=mouseX-objectX; dragOffsetY=mouseY-(axisY-objectH); return;
  }
}
function mouseDragged(){
  if(!dragging) return;
  if(dragging==='lens'){
    lensX = constrain(mouseX - dragOffsetX, 40, width-40);
    if(Math.abs(lensX - objectX) < 10) lensX = (lensX > objectX) ? objectX + 10 : objectX - 10;
  }else if(dragging==='obj-base'){
    objectX = constrain(mouseX - dragOffsetX, 20, width-20);
    if(Math.abs(lensX - objectX) < 10) objectX = (objectX < lensX) ? lensX - 10 : lensX + 10;
  }else if(dragging==='obj-tip'){
    objectX = constrain(mouseX - dragOffsetX, 20, width-20);
    if(Math.abs(lensX - objectX) < 10) objectX = (objectX < lensX) ? lensX - 10 : lensX + 10;
    const tipY = mouseY - dragOffsetY; const maxH = 240;
    objectH = constrain(axisY - tipY, -maxH, maxH);
  }
}
function mouseReleased(){ dragging = null; }
</script>
</body>
</html>
