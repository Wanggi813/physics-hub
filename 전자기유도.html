<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ì§ë¥˜ ì „ë™ê¸° (í†µí•© ì—°ê²° ìˆ˜ì •ë³¸)</title>
  <style>
    :root{ --ink:#1e293b; --primary:#0ea5e9; --danger:#ef4444; --success:#22c55e; --warn:#f59e0b; }
    html,body{height:100%; margin:0; overflow:hidden;}
    
    body {
      color: var(--ink);
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at 50% 30%, #f0f9ff 0%, #cbd5e1 100%);
    }

    header {
      position: absolute; top:0; left:0; width:100%;
      padding: 10px 14px;
      display: flex; justify-content: space-between; align-items: center;
      z-index: 5;
    }
    .brand { font-weight: 700; font-size: 18px; color: #0f172a; text-shadow: 0 1px 0 rgba(255,255,255,0.5); }
    .small { font-size: 12px; color: #475569; }
    
    #scene { position: fixed; inset: 0; z-index: 0; }
    #scene canvas { display: block; width: 100vw; height: 100vh; outline: none; }

    /* HUD íŒ¨ë„ */
    .hud {
      position: fixed; left: 14px; top: 50px; width: 340px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.6);
      border-radius: 12px; padding: 16px; z-index: 10;
      box-shadow: 0 10px 25px -5px rgba(0,0,0,0.1);
      max-height: 85vh; overflow-y: auto;
    }
    .row { display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center; margin: 8px 0; }
    .row label { font-size: 14px; font-weight: 600; color: #334155; }
    
    input[type=range] { width: 100%; accent-color: var(--primary); cursor: pointer;}
    select { padding: 4px; border-radius: 4px; border: 1px solid #cbd5e1; }
    
    .status-box {
      margin-top: 12px; padding-top: 12px; 
      border-top: 1px solid #e2e8f0;
      font-size: 13px; color: #475569; line-height: 1.6;
    }
    .val-highlight { color: #0ea5e9; font-weight: bold; }

    /* ë²„íŠ¼ ê·¸ë£¹ */
    .control-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-top: 12px; }
    .btn {
      padding: 10px 6px; border-radius: 6px; border: none; cursor: pointer;
      font-size: 12px; font-weight: 600; color: white;
      background: #475569; transition: all 0.2s;
      display: flex; justify-content: center; align-items: center; text-align: center;
      line-height: 1.3;
    }
    .btn:hover { background: #334155; transform: translateY(-1px); }
    .btn.active { background: var(--primary); box-shadow: 0 0 0 2px #bae6fd; }
    
    .btn-magnet { background: #6366f1; } 
    .btn-current { background: #f59e0b; } 
    .btn-pause { background: var(--danger); } 
    .btn-pause.paused { background: var(--success); }
    
    .btn-slow { background: #10b981; grid-column: span 2; font-size: 13px; padding: 12px; }
    .btn-slow.active-mode { background: #059669; box-shadow: inset 0 2px 4px rgba(0,0,0,0.2); border: 2px solid #a7f3d0; }

    /* ê·¸ë˜í”„ */
    .graphbox {
      position: fixed; right: 14px; top: 50px; width: 300px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 12px; padding: 10px; z-index: 11;
      box-shadow: 0 10px 25px -5px rgba(0,0,0,0.1);
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

  <header>
    <div class="brand">ğŸ”· ì§ë¥˜ ì „ë™ê¸° ì‹¤í—˜ì‹¤</div>
    <div class="small">Connected: Coil-Commutator-Brush (Unified Z=7.0)</div>
  </header>

  <div id="scene"></div>

  <div class="hud">
    <div class="row">
      <label for="I_curr">ì „ë¥˜ í¬ê¸° (Current)</label>
      <span style="font-family:monospace; font-weight:bold;"><span id="Ival">0.16</span> A</span>
    </div>
    <input id="I_curr" type="range" min="0" max="0.32" step="0.01" value="0.16" />

    <div class="row">
      <label for="B_field">ìê¸°ì¥ ì„¸ê¸° (B)</label>
      <span style="font-family:monospace; font-weight:bold;"><span id="Bval">0.08</span> T</span>
    </div>
    <input id="B_field" type="range" min="0" max="0.16" step="0.01" value="0.08" />

    <div class="row">
      <label>ì½”ì¼ ê°œìˆ˜</label>
      <select id="coilCount">
        <option value="1">1ê°œ (ê¸°ë³¸)</option>
        <option value="2">2ê°œ (ì‹­ì)</option>
        <option value="4">4ê°œ (ì›í˜•)</option>
      </select>
    </div>

    <div class="control-grid">
      <button id="btnSlowToggle" class="btn btn-slow">ğŸ¢ 0.1ë°°ì† ëŠë¦¬ê²Œ ë³´ê¸° (OFF)</button>
      <button id="btnMagnetSwap" class="btn btn-magnet">ğŸ§² ìì„ ìœ„ì¹˜ ë³€ê²½<br>(N â†” S)</button>
      <button id="btnCurrentRev" class="btn btn-current">âš¡ ì „ë¥˜ ë°©í–¥ ë³€ê²½<br>(ì •ë°©í–¥)</button>
      <button id="toggleForce" class="btn active">í˜ í™”ì‚´í‘œ ë³´ê¸°</button>
      <button id="btnPause" class="btn btn-pause">â¸ ì¼ì‹œì •ì§€</button>
      <button id="resetCam" class="btn" style="grid-column: span 2;">ğŸ“· ì¹´ë©”ë¼ ë¦¬ì…‹</button>
    </div>

    <div class="status-box">
      <div>ì‹¤ì œ ì…ë ¥ ì „ë¥˜ = <span class="val-highlight" id="dispI">0.16</span> A</div>
      <div>ìê¸°ë ¥ F = <span class="val-highlight" id="Fval">0.00</span> N</div>
      <div>íšŒì „ ì†ë„ = <span class="val-highlight" id="RPMval">0</span> RPM</div>
    </div>
  </div>

  <div class="graphbox">
    <canvas id="graph" width="300" height="120"></canvas>
    <div style="text-align:right; font-size:11px; color:#64748b; margin-top:4px;">Time â†’</div>
  </div>

  <script>
  (function(){
    // 1. ë³€ìˆ˜ ì„¤ì •
    const elScene = document.getElementById('scene');
    const inputI = document.getElementById('I_curr');
    const inputB = document.getElementById('B_field');
    const selectCoils = document.getElementById('coilCount');
    
    const btnSlowToggle = document.getElementById('btnSlowToggle');
    const btnMagnetSwap = document.getElementById('btnMagnetSwap');
    const btnCurrentRev = document.getElementById('btnCurrentRev');
    const btnForce = document.getElementById('toggleForce');
    const btnPause = document.getElementById('btnPause');
    const btnResetCam = document.getElementById('resetCam');

    const dispIval = document.getElementById('Ival');
    const dispBval = document.getElementById('Bval');
    const dispI = document.getElementById('dispI');
    const dispFval = document.getElementById('Fval');
    const dispRPM = document.getElementById('RPMval');

    let angularVelocity = 0;
    let currentAngle = 0;
    
    let rawInputCurrent = 0.16; 
    let rawInputB = 0.08;
    
    let magnetDirection = 1; 
    let currentDirection = 1; 
    let isPaused = false;
    let showForceArrows = true;
    
    const NORMAL_SPEED_FACTOR = 1.0; 
    const SLOW_SPEED_FACTOR = 0.1;
    let currentSpeedFactor = NORMAL_SPEED_FACTOR;

    const gCanvas = document.getElementById('graph');
    const ctxG = gCanvas.getContext('2d');
    const gBuf = new Float32Array(300);
    let gIdx = 0;
    let maxGraphY = 10;

    // 2. 3D ì”¬ ì„¤ì •
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    elScene.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 1000);
    camera.position.set(20, 15, 30);
    camera.lookAt(0, 0, 0);

    class SimpleOrbit {
      constructor(cam, dom) {
        this.cam = cam; this.dom = dom;
        this.target = new THREE.Vector3(0,0,0);
        this.sph = new THREE.Spherical().setFromVector3(cam.position);
        this.dragging = false; this.last = {x:0, y:0};
        this.dom.addEventListener('mousedown', e=>{ this.dragging=true; this.last={x:e.clientX, y:e.clientY}; });
        window.addEventListener('mouseup', ()=>{ this.dragging=false; });
        this.dom.addEventListener('mousemove', e=>{
          if(!this.dragging) return;
          const dx = e.clientX - this.last.x;
          const dy = e.clientY - this.last.y;
          this.sph.theta -= dx * 0.005;
          this.sph.phi -= dy * 0.005;
          this.sph.phi = Math.max(0.05, Math.min(Math.PI-0.05, this.sph.phi));
          this.last={x:e.clientX, y:e.clientY};
          this.update();
        });
        this.dom.addEventListener('wheel', e=>{
          e.preventDefault();
          this.sph.radius = Math.max(10, Math.min(100, this.sph.radius + e.deltaY*0.05));
          this.update();
        }, {passive:false});
      }
      update() {
        const p = new THREE.Vector3().setFromSpherical(this.sph).add(this.target);
        this.cam.position.copy(p);
        this.cam.lookAt(this.target);
      }
    }
    const orbit = new SimpleOrbit(camera, renderer.domElement);

    const ambLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    const matCopper = new THREE.MeshStandardMaterial({ color: 0xb87333, roughness: 0.3, metalness: 0.7 });
    const matSteel = new THREE.MeshStandardMaterial({ color: 0xe0e0e0, roughness: 0.4, metalness: 0.5 });
    const matBrass = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.3, metalness: 0.8 });
    const matRed = new THREE.MeshPhongMaterial({ color: 0xff3333, shininess: 80 });
    const matBlue = new THREE.MeshPhongMaterial({ color: 0x3333ff, shininess: 80 });
    const matDark = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
    const matArrow = new THREE.MeshPhongMaterial({ color: 0x39ff14, emissive: 0x004400 });

    // 3. ê°ì²´ ìƒì„±
    let magnetL, magnetR;
    function createMagnetMesh(isN) {
      const g = new THREE.BoxGeometry(4, 10, 10);
      const m = new THREE.Mesh(g, isN ? matRed : matBlue);
      const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
      const ctx = cvs.getContext('2d');
      ctx.fillStyle = isN?'#b00':'#00b'; ctx.fillRect(0,0,64,64);
      ctx.fillStyle='white'; ctx.font='bold 40px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(isN?'N':'S', 32, 32);
      const tex = new THREE.CanvasTexture(cvs);
      const label = new THREE.Mesh(new THREE.PlaneGeometry(3,3), new THREE.MeshBasicMaterial({map:tex}));
      m.add(label);
      return m;
    }
    function initMagnets() {
      magnetL = createMagnetMesh(true); magnetL.position.set(-10, 0, 0);
      magnetL.children[0].position.x = 2.1; magnetL.children[0].rotation.y = Math.PI/2;
      scene.add(magnetL);
      magnetR = createMagnetMesh(false); magnetR.position.set(10, 0, 0);
      magnetR.children[0].position.x = -2.1; magnetR.children[0].rotation.y = -Math.PI/2;
      scene.add(magnetR);
    }
    initMagnets();

    function updateMagnetVisuals() {
      const isNormal = magnetDirection === 1; 
      magnetL.material = isNormal ? matRed : matBlue;
      updateMagnetLabel(magnetL, isNormal ? 'N' : 'S', isNormal ? '#b00' : '#00b');
      magnetR.material = isNormal ? matBlue : matRed;
      updateMagnetLabel(magnetR, isNormal ? 'S' : 'N', isNormal ? '#00b' : '#b00');
    }
    function updateMagnetLabel(mesh, text, bgColor) {
      const labelMesh = mesh.children[0];
      const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
      const ctx = cvs.getContext('2d');
      ctx.fillStyle = bgColor; ctx.fillRect(0,0,64,64);
      ctx.fillStyle='white'; ctx.font='bold 40px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(text, 32, 32);
      labelMesh.material.map = new THREE.CanvasTexture(cvs);
    }

    // --- [ìœ„ì¹˜ í†µí•© ì„¤ì • (í•µì‹¬ ìˆ˜ì •)] ---
    // ì‚¬ìš©ìê°€ ì›í•˜ëŠ” "Z=7.0"ì„ ê¸°ì¤€ìœ¼ë¡œ ëª¨ë“  ë¶€í’ˆì„ ì—°ë™í•©ë‹ˆë‹¤.
    const MAIN_Z = 7.0; 
    
    // 1) ë¸ŒëŸ¬ì‰¬ ìœ„ì¹˜: ì •í™•íˆ 7.0
    const BRUSH_Z = 7.4; 
    
    // 2) ì •ë¥˜ì ì¤‘ì‹¬ ìœ„ì¹˜: ì •í™•íˆ 7.0
    const COMM_CENTER_Z = MAIN_Z;
    
    // 3) ì½”ì¼ ë ìœ„ì¹˜: 7.0ë³´ë‹¤ ì‚´ì§ ì•ˆìª½(6.0)ê¹Œì§€ ë»—ì–´ì„œ ì •ë¥˜ìì™€ ê²¹ì¹˜ê²Œ í•¨ (ë¶„ë¦¬ ë°©ì§€)
    const COIL_END_Z = MAIN_Z - 1.0; 

    function createCurvedBrushGeo() {
      const shape = new THREE.Shape();
      const rIn = 1.3; 
      const rOut = 1.8; 
      const ang = Math.PI / 3; 

      shape.absarc(0, 0, rIn, -ang/2, ang/2, false);
      shape.absarc(0, 0, rOut, ang/2, -ang/2, true);
      
      const extrudeSettings = { depth: 2.0, bevelEnabled: false, curveSegments: 16 };
      const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      geo.translate(0, 0, -1.0); // ì¤‘ì‹¬ ë§ì¶¤
      return geo;
    }

    const brushGeo = createCurvedBrushGeo();
    const brushGroup = new THREE.Group(); 
    scene.add(brushGroup);

    // ì˜¤ë¥¸ìª½ ë¸ŒëŸ¬ì‹œ
    const brushR = new THREE.Mesh(brushGeo, matDark);
    brushR.position.set(0, 0, BRUSH_Z); 
    
    // ì™¼ìª½ ë¸ŒëŸ¬ì‹œ
    const brushL = new THREE.Mesh(brushGeo, matDark);
    brushL.position.set(0, 0, BRUSH_Z);
    brushL.rotation.z = Math.PI;

    brushGroup.add(brushL, brushR);

    // ì „ì„  ì—°ê²°
    const wireGeo = new THREE.CylinderGeometry(0.2, 0.2, 8); 
    
    const wireL = new THREE.Mesh(wireGeo, matRed);
    wireL.rotation.z = Math.PI/2; 
    wireL.position.set(-5.8, 0, BRUSH_Z); 
    
    const wireR = new THREE.Mesh(wireGeo, matBlue);
    wireR.rotation.z = Math.PI/2;
    wireR.position.set(5.8, 0, BRUSH_Z);

    brushGroup.add(wireL, wireR);


    // --- 4. ë¡œí„° ìƒì„± (íšŒì „ì²´ ê·¸ë£¹í™”) ---
    let rotorGroup = new THREE.Group();
    let arrows = []; 

    function createArrow() {
      const g = new THREE.Group();
      const cyl = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 1, 12), matArrow);
      cyl.position.y = 0.5;
      const cone = new THREE.Mesh(new THREE.ConeGeometry(0.5, 0.8, 12), matArrow);
      cone.position.y = 1.4;
      g.add(cyl, cone);
      return g;
    }

    function createRotor(n) {
      if(rotorGroup) scene.remove(rotorGroup);
      rotorGroup = new THREE.Group();
      scene.add(rotorGroup);
      arrows = [];

      // ì¶• (Shaft) - Zì¶• ì¤‘ì‹¬ì—ì„œ ê¸¸ê²Œ
      const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 26, 16), matSteel);
      shaft.rotation.x = Math.PI/2;
      rotorGroup.add(shaft);

      // ì •ë¥˜ì (Commutator) - MAIN_Z(7.0) ìœ„ì¹˜ì— ë°°ì¹˜
      const COMM_LEN = 4.0; 
      // ì •ë¥˜ì ì‹œì‘ Z = 7.0 - 2.0 = 5.0, ë Z = 7.0 + 2.0 = 9.0

      const segs = n * 2;
      const segmentArc = (Math.PI * 2) / segs; 
      const gapArc = 0.2; 
      const copperArc = segmentArc - gapArc; 
      const phaseFix = Math.PI / 2; 

      for(let i=0; i<segs; i++) {
        const centerAngle = i * segmentArc + phaseFix;
        const startAngle = centerAngle - (copperArc / 2);

        const geo = new THREE.CylinderGeometry(1.2, 1.2, COMM_LEN, 32, 1, false, startAngle, copperArc);
        const mesh = new THREE.Mesh(geo, matBrass);
        mesh.rotation.x = Math.PI/2; 
        mesh.position.z = COMM_CENTER_Z; // í†µí•© ë³€ìˆ˜ ì‚¬ìš© (7.0)
        rotorGroup.add(mesh);
      }

      // ì½”ì¼ ìƒì„±
      const angStep = Math.PI / n;

      for(let i=0; i<n; i++) {
        const cGroup = new THREE.Group();
        const w=5, l=12, t=0.25;
        
        // 1) ì™¼ìª½ íŒ”
        const sideL = new THREE.Mesh(new THREE.CylinderGeometry(t,t,l,8), matCopper); 
        sideL.rotation.x=Math.PI/2; 
        sideL.position.x = -w/2;
        
        // 2) ì˜¤ë¥¸ìª½ íŒ”
        const sideR = new THREE.Mesh(new THREE.CylinderGeometry(t,t,l,8), matCopper); 
        sideR.rotation.x=Math.PI/2; 
        sideR.position.x = w/2;
        
        // 3) ë’¤ìª½ ì—°ê²°
        const sideB = new THREE.Mesh(new THREE.CylinderGeometry(t,t,w,8), matCopper); 
        sideB.rotation.z=Math.PI/2; 
        sideB.position.z = -l/2;

        // 4) ì•ìª½ ì—°ê²° (ì •ë¥˜ìì™€ ë§Œë‚˜ëŠ” ë¶€ë¶„)
        const commR = 1.2;
        const armX = w/2; 
        const connLen = armX - commR; 
        const connCenter = commR + connLen/2; 

        // â˜… ì—°ê²°ì„  ìœ„ì¹˜ ìˆ˜ì •: COIL_END_Zê¹Œì§€ ë»—ì–´ì„œ ì •ë¥˜ìì™€ ê²¹ì¹˜ê²Œ í•¨
        // ì™¼ìª½ ì—°ê²°ì„ 
        const connL = new THREE.Mesh(new THREE.CylinderGeometry(t, t, connLen, 8), matCopper);
        connL.rotation.z = Math.PI/2; 
        connL.position.x = -connCenter; 
        connL.position.z = COIL_END_Z; 

        // ì˜¤ë¥¸ìª½ ì—°ê²°ì„ 
        const connR = new THREE.Mesh(new THREE.CylinderGeometry(t, t, connLen, 8), matCopper);
        connR.rotation.z = Math.PI/2; 
        connR.position.x = connCenter; 
        connR.position.z = COIL_END_Z;

        cGroup.add(sideL, sideR, sideB, connL, connR);

        const arrL = createArrow(); arrL.position.x = -w/2;
        const arrR = createArrow(); arrR.position.x = w/2;
        cGroup.add(arrL, arrR);

        cGroup.rotation.z = i * angStep;
        rotorGroup.add(cGroup);
        
        arrows.push({ group: cGroup, L: arrL, R: arrR, baseAng: i*angStep });
      }
    }

    // --- 5. ë¬¼ë¦¬ ì—…ë°ì´íŠ¸ ---
    function update() {
      rawInputCurrent = parseFloat(inputI.value);
      rawInputB = parseFloat(inputB.value);
      
      if(isPaused) return;

      const netDirection = currentDirection * magnetDirection; 
      let torqueSum = 0;
      
      arrows.forEach(obj => {
        const totalRot = rotorGroup.rotation.z + obj.baseAng;
        const normRot = totalRot % (Math.PI*2);
        const factor = Math.abs(Math.cos(normRot)); 
        const segmentTorque = factor * rawInputCurrent * rawInputB * netDirection;
        torqueSum += segmentTorque;

        if(showForceArrows && rawInputCurrent > 0.01) {
          const s = Math.abs(segmentTorque) * 20.0;
          if(s < 0.1) {
            obj.L.visible = false; obj.R.visible = false;
          } else {
            obj.L.visible = true; obj.R.visible = true;
            obj.L.scale.set(s, s, s);
            obj.R.scale.set(s, s, s);

            const radius = 2.5;
            const worldX_R = radius * Math.cos(totalRot);
            const worldX_L = radius * Math.cos(totalRot + Math.PI);

            const forceDirOnRightSide = (netDirection >= 0) ? 0 : Math.PI;
            const forceDirOnLeftSide = (forceDirOnRightSide === 0) ? Math.PI : 0;

            let targetR = (worldX_R >= 0) ? forceDirOnRightSide : forceDirOnLeftSide;
            let targetL = (worldX_L >= 0) ? forceDirOnRightSide : forceDirOnLeftSide;

            obj.R.rotation.z = -totalRot + targetR;
            obj.R.rotation.x = 0; 
            obj.L.rotation.z = -totalRot + targetL;
            obj.L.rotation.x = 0;
          }
        } else {
          obj.L.visible = false; obj.R.visible = false;
        }
      });

      if(rawInputCurrent < 0.01) torqueSum = 0;
      
      const frictionCoef = 0.045; 
      const friction = frictionCoef * angularVelocity; 
      const inertia = 0.5;
      
      const alpha = (torqueSum - friction) / inertia;
      angularVelocity += alpha * 0.1;

      const baseDt = 0.05; 
      const dt = baseDt * currentSpeedFactor; 
      
      currentAngle += angularVelocity * dt;
      rotorGroup.rotation.z = currentAngle;

      const rpm = Math.round((angularVelocity/(2*Math.PI))*60);
      dispIval.textContent = rawInputCurrent.toFixed(2);
      dispBval.textContent = rawInputB.toFixed(2);
      dispI.textContent = (rawInputCurrent * currentDirection).toFixed(2);
      dispFval.textContent = torqueSum.toFixed(2);
      dispRPM.textContent = rpm;

      gBuf[gIdx] = rpm;
      gIdx = (gIdx + 1) % 300;
    }

    function drawGraph() {
      ctxG.clearRect(0,0,300,120);
      ctxG.strokeStyle = 'rgba(200,200,200,0.5)'; ctxG.lineWidth=1;
      ctxG.beginPath(); ctxG.moveTo(0, 120); ctxG.lineTo(300, 120); ctxG.stroke();

      ctxG.strokeStyle = '#0ea5e9'; ctxG.lineWidth = 2;
      ctxG.beginPath();
      
      let curMax = 5;
      for(let i=0; i<300; i++) {
        const v = Math.abs(gBuf[i]);
        if(v > curMax) curMax = v;
      }
      maxGraphY = curMax + 1;

      for(let i=0; i<300; i++) {
        const idx = (gIdx + i) % 300;
        const val = gBuf[idx];
        const x = i;
        const y = 120 - (Math.abs(val) / maxGraphY) * 110; 
        if(i===0) ctxG.moveTo(x, y);
        else ctxG.lineTo(x, y);
      }
      ctxG.stroke();

      ctxG.fillStyle = "#0ea5e9";
      ctxG.font = "10px sans-serif";
      ctxG.fillText("Max: " + maxGraphY.toFixed(0) + " RPM", 5, 15);
    }

    function animate() {
      requestAnimationFrame(animate);
      update();
      drawGraph();
      orbit.update();
      renderer.render(scene, camera);
    }
    
    selectCoils.onchange = () => createRotor(parseInt(selectCoils.value));
    
    btnSlowToggle.onclick = () => {
      if(currentSpeedFactor === NORMAL_SPEED_FACTOR) {
        currentSpeedFactor = SLOW_SPEED_FACTOR;
        btnSlowToggle.textContent = "ğŸ¢ 0.1ë°°ì† ì ìš© ì¤‘ (í´ë¦­í•˜ì—¬ í•´ì œ)";
        btnSlowToggle.classList.add("active-mode");
      } else {
        currentSpeedFactor = NORMAL_SPEED_FACTOR;
        btnSlowToggle.textContent = "ğŸ¢ 0.1ë°°ì† ëŠë¦¬ê²Œ ë³´ê¸° (OFF)";
        btnSlowToggle.classList.remove("active-mode");
      }
    };

    btnForce.onclick = () => {
      showForceArrows = !showForceArrows;
      btnForce.classList.toggle('active');
    };
    
    btnResetCam.onclick = () => {
      camera.position.set(20, 15, 30);
      orbit.sph.setFromVector3(camera.position); orbit.update();
    }
    
    btnMagnetSwap.onclick = () => {
      magnetDirection *= -1; updateMagnetVisuals();
    };
    
    btnCurrentRev.onclick = () => {
      currentDirection *= -1;
      if(currentDirection === 1) {
        btnCurrentRev.innerHTML = "âš¡ ì „ë¥˜ ë°©í–¥ ë³€ê²½<br>(ì •ë°©í–¥)";
        btnCurrentRev.style.background = "#f59e0b";
      } else {
        btnCurrentRev.innerHTML = "âš¡ ì „ë¥˜ ë°©í–¥ ë³€ê²½<br>(ì—­ë°©í–¥)";
        btnCurrentRev.style.background = "#d97706";
      }
    };
    
    btnPause.onclick = () => {
      isPaused = !isPaused;
      if(isPaused) {
        btnPause.innerHTML = "â–¶ ì¬ìƒ"; btnPause.classList.add("paused");
      } else {
        btnPause.innerHTML = "â¸ ì¼ì‹œì •ì§€"; btnPause.classList.remove("paused");
      }
    };
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    createRotor(1);
    animate();

  })();
  </script>
</body>
</html>