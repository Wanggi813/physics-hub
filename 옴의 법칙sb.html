<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ì˜´ì˜ ë²•ì¹™ ì‹¤í—˜ì‹¤ - í„°ì¹˜ ê°œì„ íŒ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;500;700&family=Poppins:wght@500;700&display=swap');
        
        /* [ìˆ˜ì • 1] í„°ì¹˜ ë™ì‘ ì œì–´ (ìŠ¤í¬ë¡¤/ì¤Œ ë°©ì§€) */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #1a1a1a; 
            font-family: 'Noto Sans KR', sans-serif;
            touch-action: none; /* ë¸Œë¼ìš°ì € ê¸°ë³¸ í„°ì¹˜ ë™ì‘ ì°¨ë‹¨ */
            user-select: none; /* í…ìŠ¤íŠ¸ ì„ íƒ ë°©ì§€ */
        }
        
        #ui-panel {
            position: absolute; top: 25px; left: 25px; pointer-events: none;
            z-index: 10; display: flex; flex-direction: column; gap: 15px;
        }
        
        .control-box {
            background: rgba(30, 30, 30, 0.95); padding: 20px; border-radius: 12px;
            color: white; border: 1px solid rgba(255,255,255,0.1); pointer-events: auto;
            width: 260px; box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
        }
        
        .control-title { font-weight: 700; color: #ff6b81; margin-bottom: 12px; display: block; font-size: 1.1em; letter-spacing: -0.5px;}
        
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; cursor: pointer; }
        input[type=range]::-webkit-slider-runnable-track { background: #555; height: 6px; border-radius: 3px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; background: #ff6b81; height: 18px; width: 18px; border-radius: 50%; margin-top: -6px; box-shadow: 0 0 10px rgba(255, 107, 129, 0.8); transition: 0.2s;}
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.2); }
        
        .btn-group { display: flex; gap: 8px; margin-top: 15px; }
        button {
            flex: 1; padding: 12px; border: none; border-radius: 8px;
            font-weight: 700; cursor: pointer; color: white; transition: all 0.3s;
            font-family: 'Noto Sans KR', sans-serif; font-size: 0.95em;
        }
        .btn-10 { background: linear-gradient(145deg, #a0522d, #8b4513); border: 1px solid #5d2e0d; }
        .btn-20 { background: linear-gradient(145deg, #ff4757, #c0392b); border: 1px solid #922b21; }
        button:hover { filter: brightness(1.1); transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }

        .guide {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.8); background: rgba(0,0,0,0.8); padding: 10px 30px;
            border-radius: 30px; pointer-events: none; font-size: 14px; font-weight: 500;
            border: 1px solid rgba(255,255,255,0.1);
            white-space: nowrap; /* ì¤„ë°”ê¿ˆ ë°©ì§€ */
        }

        .return-btn {
            position: absolute; bottom: 25px; right: 25px; top: auto; left: auto;
            width: auto; padding: 12px 25px; pointer-events: auto;
            border-color: rgba(255, 255, 255, 0.1); cursor: pointer;
        }
        .return-btn:hover {
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0,0,0,0.6), 0 0 10px rgba(255,255,255,0.1);
            transform: translateY(-2px);
        }
    </style>
</head>
<body>

    <div id="ui-panel">
        <div class="control-box" 
             onmouseover="isUIActive=true" onmouseout="isUIActive=false"
             ontouchstart="isUIActive=true" ontouchend="isUIActive=false">
            <span class="control-title">âš¡ ì „ì•• ì¡°ì ˆ (Voltage)</span>
            <div style="display:flex; justify-content:space-between; margin-bottom:8px; font-size:0.95em;">
                <span>ì…ë ¥:</span>
                <span id="volt-display" style="color:#00ffff; font-weight:700;">5.0 V</span>
            </div>
            <input type="range" min="0" max="20" step="0.5" value="5" 
                   oninput="updateVoltage(this.value)" 
                   onmousedown="isUIActive=true" 
                   onmouseup="isUIActive=false"
                   ontouchstart="isUIActive=true" 
                   ontouchend="isUIActive=false">
        </div>

        <div class="control-box" 
             onmouseover="isUIActive=true" onmouseout="isUIActive=false"
             ontouchstart="isUIActive=true" ontouchend="isUIActive=false">
            <span class="control-title">ğŸ“Š íšŒë¡œ ì •ë³´</span>
            <div style="display:flex; justify-content:space-between; font-size:1.1em; color:#ddd; font-weight:bold;">
                <span>í•©ì„± ì €í•­:</span>
                <span id="total-r-display" style="color:#ffd700;">âˆ Î©</span>
            </div>
            <div style="display:flex; justify-content:space-between; margin-top:5px; font-size:0.9em; color:#aaa;">
                <span>ì „ì²´ ì „ë¥˜:</span>
                <span id="meter-amp">0.00 A</span>
            </div>
        </div>

        <div class="control-box" 
             onmouseover="isUIActive=true" onmouseout="isUIActive=false"
             ontouchstart="isUIActive=true" ontouchend="isUIActive=false">
            <span class="control-title">ğŸ“¦ ë¶€í’ˆ ìƒì</span>
            <div class="btn-group">
                <button class="btn-10" onclick="spawnResistor(10)">+ 10Î© ì €í•­</button>
                <button class="btn-20" onclick="spawnResistor(20)">+ 20Î© ì €í•­</button>
            </div>
        </div>
    </div>

    <div class="guide">â˜ï¸ ì›í„°ì¹˜ ë“œë˜ê·¸: í™”ë©´ íšŒì „ | ğŸ¤ í•€ì¹˜: ì¤Œ | ğŸ‘† ë¶€í’ˆ í„°ì¹˜: ì´ë™</div>

    <div class="control-box return-btn" onclick="location.href='./ì˜´ì˜ ë²•ì¹™.html'">
        <span class="control-title" style="color: white; margin-bottom: 0;">ğŸ”™ ì´ì „ ì‹¤í—˜ì‹¤</span>
    </div>

    <script>
        let resistors = [];
        let slots = [];
        let heldObj = null;
        let cam;
        let renderer;
        let isUIActive = false;
        let trashBinPos = { x: 350, y: 200, r: 40 };
        
        let trashIconTexture;
        let pgPower, pgAmp, pgVolt;
        let labelPower, labelAmp, labelVolt;

        let sourceVoltage = 5.0;
        let totalCurrent = 0;
        let totalResistance = Infinity;
        
        const ROWS = 4;
        const COLS = 4;
        const SLOT_GAP_X = 85; 
        const SLOT_GAP_Y = 65;

        function setup() {
            renderer = createCanvas(windowWidth, windowHeight, WEBGL);
            pixelDensity(2);
            cam = createCamera();
            cam.setPosition(0, -700, 800);
            cam.lookAt(0, 0, 0);
            
            trashIconTexture = createGraphics(128, 128);
            trashIconTexture.textAlign(CENTER, CENTER);
            trashIconTexture.textSize(80);
            trashIconTexture.text("ğŸ—‘ï¸", 64, 64);

            let createScreen = () => {
                let pg = createGraphics(200, 100);
                pg.textSize(40);
                pg.textAlign(CENTER, CENTER);
                return pg;
            };
            pgPower = createScreen();
            pgAmp = createScreen();
            pgVolt = createScreen();

            let createLabel = (text) => {
                let pg = createGraphics(200, 60);
                pg.textAlign(CENTER, CENTER);
                pg.textSize(32); 
                pg.fill(220);
                pg.textStyle(BOLD);
                pg.text(text, 100, 30);
                return pg;
            }
            labelPower = createLabel("ì „ì› ì¥ì¹˜");
            labelAmp = createLabel("ì „ë¥˜ê³„");
            labelVolt = createLabel("ì „ì••ê³„");
        
            let startX = -((COLS-1) * SLOT_GAP_X) / 2;
            let startY = -((ROWS-1) * SLOT_GAP_Y) / 2;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    slots.push({ row: r, col: c, x: startX + c * SLOT_GAP_X, y: startY + r * SLOT_GAP_Y, occupied: null });
                }
            }
        }

        function draw() {
            background(20);

            // [ìˆ˜ì • 2] ì¹´ë©”ë¼ ì œì–´ ì¡°ê±´: ë¬¼ì²´ë¥¼ ì¡ê³  ìˆì§€ ì•Šê³ , UIë¥¼ ê±´ë“œë¦¬ì§€ ì•Šì„ ë•Œë§Œ ë™ì‘
            if (!heldObj && !isUIActive) { 
                orbitControl(1.5, 1.5, 0.05); // ê°ë„ ì¡°ì ˆ
            }

            ambientLight(40);
            directionalLight(255, 250, 240, 0.6, -1, -0.8); 
            directionalLight(150, 150, 200, 0.3, 1, -0.5); 
            pointLight(255, 255, 255, 0, 0, 400);

            updateScreenTextures();
            drawEnvironment();
            drawLabBench(); 
            drawTrashBin(); 

            // [ìˆ˜ì • 3] ë¬¼ì²´ ì´ë™ ë¡œì§ ì œê±° (draw í•¨ìˆ˜ ë‚´ì—ì„œ ì›€ì§ì´ì§€ ì•Šê³  mouseDragged/touchMovedì—ì„œ ì§ì ‘ ì²˜ë¦¬)
            if (heldObj) {
                heldObj.z = 60; 
                let dTrash = dist(heldObj.x, heldObj.y, trashBinPos.x, trashBinPos.y);
                if (dTrash < trashBinPos.r + 20) {
                    push(); translate(trashBinPos.x, trashBinPos.y, 60);
                    noFill(); stroke(255, 0, 0); strokeWeight(5); ellipse(0, 0, 100, 100); pop();
                }
                let closest = getClosestSlot(heldObj);
                if (closest && !closest.occupied && dTrash > trashBinPos.r + 20) { drawSnapIndicator(closest); }
            }

            for (let s of slots) drawSlot(s);
            for (let r of resistors) {
                updateScreenPos(r);
                r.display();
            }

            drawCables();
            calculateCircuit();
        }

        /* --- [ì¶”ê°€] í„°ì¹˜ ë° ë§ˆìš°ìŠ¤ í†µí•© ì´ë²¤íŠ¸ í•¸ë“¤ë§ --- */
        
        // ê³µí†µ: ì…ë ¥ ì‹œì‘ (í´ë¦­ ë˜ëŠ” í„°ì¹˜ ì‹œì‘)
        function handleInputStart(inputX, inputY) {
            if (isUIActive) return false;
            if (!heldObj) {
                let closest = null; let minDist = 70; // í„°ì¹˜ ë²”ìœ„ë¥¼ ìœ„í•´ 60 -> 70ìœ¼ë¡œ ì•½ê°„ í™•ëŒ€
                for (let r of resistors) {
                    let d = dist(inputX, inputY, r.screenX, r.screenY);
                    if (d < minDist) { minDist = d; closest = r; }
                }
                if (closest) {
                    heldObj = closest; heldObj.isCarried = true;
                    if (heldObj.slot) { heldObj.slot.occupied = null; heldObj.slot = null; }
                    return true; // ë¬¼ì²´ë¥¼ ì¡ìŒ
                }
            }
            return false; // ë¬¼ì²´ë¥¼ ì¡ì§€ ì•ŠìŒ (ì¹´ë©”ë¼ íšŒì „ ë“±)
        }

        // ê³µí†µ: ì…ë ¥ ì´ë™ (ë“œë˜ê·¸)
        function handleInputMove(dx, dy) {
            if (heldObj) {
                // ì¹´ë©”ë¼ ì¤Œ ê±°ë¦¬ì— ë¹„ë¡€í•˜ì—¬ ì´ë™ ì†ë„ ë³´ì •
                let zoomFactor = cam.eyeZ / 700; 
                heldObj.x += dx * zoomFactor; 
                heldObj.y += dy * zoomFactor;
                return true; // ë¬¼ì²´ ì´ë™ ì²˜ë¦¬ë¨
            }
            return false;
        }

        // ê³µí†µ: ì…ë ¥ ì¢…ë£Œ (ë†“ê¸°)
        function handleInputEnd() {
            if (heldObj) {
                let dTrash = dist(heldObj.x, heldObj.y, trashBinPos.x, trashBinPos.y);
                if (dTrash < trashBinPos.r + 20) {
                    let idx = resistors.indexOf(heldObj);
                    if (idx > -1) resistors.splice(idx, 1);
                } else {
                    let target = getClosestSlot(heldObj);
                    if (target && !target.occupied) {
                        heldObj.x = target.x; heldObj.y = target.y; heldObj.z = 0; 
                        heldObj.slot = target; target.occupied = heldObj;
                    } else { heldObj.z = 5; }
                }
                heldObj.isCarried = false; 
                heldObj = null;
            }
        }

        // 1. ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
        function mousePressed() {
            if (mouseButton !== LEFT) return;
            handleInputStart(mouseX, mouseY);
        }
        
        function mouseDragged() {
            // p5.jsì—ì„œ ë§ˆìš°ìŠ¤ ë“œë˜ê·¸ ì‹œ ë¬¼ì²´ ì´ë™ ì²˜ë¦¬
            // movedX, movedY ì‚¬ìš©
            handleInputMove(movedX, movedY);
        }

        function mouseReleased() {
            handleInputEnd();
        }

        // 2. í„°ì¹˜ ì´ë²¤íŠ¸ (ì¤‘ìš”!)
        function touchStarted() {
            // í„°ì¹˜ ì‹œì‘ ì‹œ ë¬¼ì²´ ì„ íƒ ì‹œë„
            // touches[0]ì„ ì‚¬ìš©í•˜ì—¬ ë©€í‹°í„°ì¹˜ ì¤‘ ì²« ë²ˆì§¸ ì†ê°€ë½ ê¸°ì¤€
            if(touches.length > 0) {
                let hit = handleInputStart(touches[0].x, touches[0].y);
                if (hit) return false; // ë¬¼ì²´ë¥¼ ì¡ì•˜ìœ¼ë©´ ê¸°ë³¸ ë™ì‘ ì°¨ë‹¨
            }
            // ë¬¼ì²´ë¥¼ ì¡ì§€ ì•Šì•˜ìœ¼ë©´(ë¹ˆ ê³µê°„ í„°ì¹˜) trueë¥¼ ë°˜í™˜í•˜ì—¬ orbitControlì´ ë™ì‘í•˜ê²Œ í•¨
            return true; 
        }

        function touchMoved() {
            if (heldObj && touches.length > 0) {
                // ëª¨ë°”ì¼ì—ì„œ movedXê°€ ë¶ˆì•ˆì •í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì§ì ‘ ê³„ì‚°
                let dx = mouseX - pmouseX;
                let dy = mouseY - pmouseY;
                handleInputMove(dx, dy);
                return false; // ë“œë˜ê·¸ ì¤‘ ìŠ¤í¬ë¡¤ ë°©ì§€
            }
            return true; // ì¹´ë©”ë¼ íšŒì „ í—ˆìš©
        }

        function touchEnded() {
            handleInputEnd();
            // ëª¨ë“  ì†ê°€ë½ì´ ë–¼ì–´ì¡Œì„ ë•Œ
            if (touches.length === 0) {
                return false;
            }
        }

        /* ----------------------------------------------- */

        function updateScreenTextures() {
            pgPower.background(20); pgPower.fill(0, 255, 255);
            pgPower.text(sourceVoltage.toFixed(1) + "V", 100, 50);

            pgAmp.background(20); pgAmp.fill(34, 251, 153);
            pgAmp.text(totalCurrent.toFixed(2) + "A", 100, 50);

            pgVolt.background(20); pgVolt.fill(255, 204, 0);
            pgVolt.text(sourceVoltage.toFixed(1) + "V", 100, 50);
        }

        function drawEnvironment() {
            push(); translate(0, 0, -10); fill(25); noStroke();
            specularMaterial(30); shininess(10); box(2500, 2500, 2); pop();
        }

        function drawTrashBin() {
            push(); 
            translate(trashBinPos.x, trashBinPos.y, 0);
            noStroke(); fill(0, 100); circle(0, 0, 70); 
            
            push(); translate(0, 0, 30); rotateX(HALF_PI); 
            fill(200, 50, 50); specularMaterial(100); shininess(30); noStroke(); cylinder(trashBinPos.r, 60); pop();
            
            push(); translate(0, 0, 60.1); fill(10); circle(0, 0, trashBinPos.r * 1.8); pop();
            
            push();
            translate(0, 0, 95 + sin(frameCount * 0.05) * 5); 
            rotateX(0); 
            rotateY(frameCount * 0.02 + PI); 
            noStroke(); texture(trashIconTexture); plane(60, 60);
            pop();
            pop();
        }

        function drawLabBench() {
            drawFakeShadow(-350, -100, 0, 160, 130, 100); 
            drawFakeShadow(50, -280, 0, 160, 130, 100);  
            drawFakeShadow(350, -280, 0, 160, 130, 100); 
            drawFakeShadow(0, 0, 0, 430, 350, 80);       

            push(); translate(0, 0, -5); 
            fill(20, 40, 25); stroke(15, 30, 20); strokeWeight(1); specularMaterial(50); shininess(20);
            box(420, 340, 10); 
            noFill(); stroke(120); strokeWeight(2); translate(0,0,6); rect(-210,-170, 420, 340, 8);
            stroke(230, 160, 90); strokeWeight(6);
            line(-190, -155, 1, -190, 155, 1); line(190, -155, 1, 190, 155, 1);
            pop();

            drawInstrument(-350, -100, 90, labelPower, pgPower, [0, 255, 255]);
            drawInstrument(50, -280, 90, labelAmp, pgAmp, [34, 251, 153]);
            drawInstrument(350, -280, 90, labelVolt, pgVolt, [255, 204, 0]);
        }

        function drawInstrument(x, y, h, labelTex, screenTex, nColor) {
            push();
            translate(x, y, h/2); 
            fill(40, 45, 50); stroke(60); strokeWeight(1); specularMaterial(200); shininess(60);
            box(140, 120, h); 
            push(); translate(0, -25, h/2 + 1); fill(5); noStroke(); box(110, 45, 2); pop(); 
            push(); translate(0, -25, h/2 + 2.1); noStroke(); texture(screenTex); plane(100, 35); pop(); 
            push(); translate(0, 10, h/2 + 1); noStroke(); texture(labelTex); plane(120, 30); pop();
            push(); translate(-35, 40, h/2 + 2); drawSocket(nColor); pop();
            push(); translate(35, 40, h/2 + 2); drawSocket([20, 20, 20]); pop();
            pop();
        }

        function drawSocket(col) {
            fill(180); noStroke(); torus(11, 2.5);
            fill(col); circle(0, 0, 17);
            fill(0); circle(0, 0, 8);
        }

        function drawFakeShadow(x, y, z, w, h, opacity) {
            push(); translate(x, y, z - 0.1); noStroke();
            for(let i=0; i<5; i++){
                fill(0, opacity * (1 - i*0.2));
                ellipse(0, 0, w * (1 + i*0.1), h * (1 + i*0.1));
            }
            pop();
        }

        function drawCables() {
            noFill(); strokeWeight(4); 
            let wireD = -180; 

            stroke(255, 50, 80, 200); 
            drawPlug(-385, -60, 92, [220, 20, 20]); 
            drawPlug(15, -240, 92, [220, 20, 20]);
            drawUnderCurve(-385, -60, 92, 15, -240, 92, wireD);

            drawPlug(85, -240, 92, [20, 20, 20]); 
            drawUnderCurve(85, -240, 92, -190, -155, 10, wireD);

            stroke(60, 60, 60, 200); 
            drawPlug(-315, -60, 92, [20, 20, 20]);
            drawUnderCurve(-315, -60, 92, 190, -155, 10, wireD);

            stroke(255, 220, 50, 200); 
            drawPlug(315, -240, 92, [255, 200, 0]);
            drawUnderCurve(315, -240, 92, -190, 155, 10, wireD);
            
            stroke(80, 80, 80, 200); 
            drawPlug(385, -240, 92, [20, 20, 20]);
            drawUnderCurve(385, -240, 92, 190, 155, 10, wireD);
        }

        function drawUnderCurve(x1, y1, z1, x2, y2, z2, dropZ) {
            bezier(x1, y1, z1, x1, y1, dropZ, x2, y2, dropZ, x2, y2, z2);
        }

        function drawPlug(x, y, z, col) {
            push(); translate(x, y, z); rotateX(PI/2);
            noStroke(); fill(col); specularMaterial(200); shininess(80);
            cylinder(7, 18); translate(0, 11, 0); fill(180); cylinder(3, 10);
            pop();
        }

        function drawSlot(s) {
            push(); translate(s.x, s.y, 2);
            fill(10); stroke(120); strokeWeight(1.5); ellipse(0,0,15,15); 
            fill(5); noStroke(); ellipse(0,0,8,8); 
            stroke(230, 160, 90, 80); strokeWeight(2);
            if (s.col < COLS-1) line(8, 0, SLOT_GAP_X-8, 0);
            pop();
        }

        function drawSnapIndicator(slot) {
            push(); translate(slot.x, slot.y, 5);
            noFill(); stroke(0, 255, 100, 180); strokeWeight(2);
            ellipse(0, 0, 28, 28); stroke(0, 255, 100, 100); line(0,-15, 0,15); line(-15,0, 15,0);
            pop();
        }

        function updateVoltage(val) {
            sourceVoltage = parseFloat(val);
            document.getElementById('volt-display').innerText = sourceVoltage.toFixed(1) + " V";
        }

        function spawnResistor(val) {
            let r = new Resistor(random(-100, 100), 250, val); resistors.push(r);
        }

        function calculateCircuit() {
            let totalConductance = 0; let activeRows = 0;
            for (let r = 0; r < ROWS; r++) {
                let rowR = 0; let count = 0;
                for (let c = 0; c < COLS; c++) {
                    let s = slots[r*COLS + c];
                    if (s.occupied) { rowR += s.occupied.val; count++; }
                }
                if (count > 0) { activeRows++; totalConductance += (1 / rowR); }
            }
            
            if (activeRows > 0) {
                totalResistance = 1 / totalConductance;
                document.getElementById('total-r-display').innerText = totalResistance.toFixed(2) + " Î©";
                totalCurrent = sourceVoltage / totalResistance;
            } else {
                totalResistance = Infinity;
                document.getElementById('total-r-display').innerText = "âˆ Î© (ë‹¨ì„ )";
                totalCurrent = 0;
            }
            let ampEl = document.getElementById('meter-amp');
            if(ampEl) ampEl.innerText = totalCurrent.toFixed(2) + " A";
        }

        function updateScreenPos(obj) {
            let mv = renderer.uMVMatrix.mat4; let pr = renderer.uPMatrix.mat4;
            let cx = mv[0]*obj.x + mv[4]*obj.y + mv[8]*obj.z + mv[12];
            let cy = mv[1]*obj.x + mv[5]*obj.y + mv[9]*obj.z + mv[13];
            let cz = mv[2]*obj.x + mv[6]*obj.y + mv[10]*obj.z + mv[14];
            let cw = mv[3]*obj.x + mv[7]*obj.y + mv[11]*obj.z + mv[15];
            let px = pr[0]*cx + pr[4]*cy + pr[8]*cz + pr[12]*cw;
            let py = pr[1]*cx + pr[5]*cy + pr[9]*cz + pr[13]*cw;
            let pw = pr[3]*cx + pr[7]*cy + pr[11]*cz + pr[15]*cw;
            if (pw !== 0) { px /= pw; py /= pw; }
            obj.screenX = (px + 1) * 0.5 * width; obj.screenY = (1 - py) * 0.5 * height;
        }

        function getClosestSlot(obj) {
            let closest = null; let minDist = 45;
            for (let s of slots) {
                let d = dist(obj.x, obj.y, s.x, s.y);
                if (d < minDist) { minDist = d; closest = s; }
            }
            return closest;
        }

        class Resistor {
            constructor(x, y, val) {
                this.x = x; this.y = y; this.z = 5;
                this.val = val; this.slot = null; this.isCarried = false;
                this.screenX = 0; this.screenY = 0;
                this.b1 = (val===10)?color(100,50,20):color(200,30,30);
                this.b2 = color(10); this.b3 = color(10);
            }
            
            display() {
                if (!this.slot || this.isCarried) {
                    let shwW = this.isCarried ? 70 : 50;
                    push(); translate(this.x, this.y, 0); rotateZ(PI/2);
                    drawFakeShadow(0, 0, 1, shwW, 25, this.isCarried ? 40 : 60);
                    pop();
                } else if (this.slot) {
                    drawFakeShadow(this.x - 38, this.y, 1, 15, 15, 70);
                    drawFakeShadow(this.x + 38, this.y, 1, 15, 15, 70);
                }

                push(); translate(this.x, this.y, this.z);
                if (this.isCarried) { rotateX(frameCount*0.05); scale(1.2); }
                else { rotateZ(PI/2); if(this.slot) translate(0, 0, 18); }

                noStroke(); fill(235, 220, 190); specularMaterial(100); shininess(20);
                
                let len = 40; 
                let baseR = 7;
                let detailX = 20; 
                let detailY = 20; 
                let endR = baseR + 4.0;

                for(let i=0; i<detailY; i++) {
                    beginShape(TRIANGLE_STRIP);
                    for(let j=0; j<=detailX; j++) {
                        let u = j/detailX;
                        let theta = u * TWO_PI;
                        let v1 = i/detailY; let v2 = (i+1)/detailY;
                        let y1 = map(v1, 0, 1, -len/2, len/2); let y2 = map(v2, 0, 1, -len/2, len/2);
                        let ny1 = map(v1, 0, 1, -1, 1); let ny2 = map(v2, 0, 1, -1, 1);
                        let r1 = baseR + 4.0 * pow(ny1, 6); 
                        let r2 = baseR + 4.0 * pow(ny2, 6);
                        normal(cos(theta), 0, sin(theta)); 
                        vertex(r1 * cos(theta), y1, r1 * sin(theta));
                        vertex(r2 * cos(theta), y2, r2 * sin(theta));
                    }
                    endShape();
                }

                push(); translate(0, len/2, 0); sphere(endR); pop(); 
                push(); translate(0, -len/2, 0); sphere(endR); pop(); 

                stroke(200); strokeWeight(3); noFill(); specularMaterial(255); shininess(100);
                if (this.slot && !this.isCarried) {
                    beginShape(); vertex(0, -20, 0); vertex(0, -42, 0); vertex(0, -42, -18); endShape();
                    beginShape(); vertex(0, 20, 0); vertex(0, 42, 0); vertex(0, 42, -18); endShape();
                } else {
                    line(0, -50, 0, 0, 50, 0);
                }

                specularMaterial(200); shininess(50);
                let drawBand = (col, t_center) => {
                    noStroke(); fill(col);
                    let bandW = 0.08; 
                    let v_start = t_center - bandW/2; let v_end = t_center + bandW/2;
                    beginShape(TRIANGLE_STRIP);
                    for(let j=0; j<=detailX; j++) {
                        let theta = j/detailX * TWO_PI;
                        let y1 = map(v_start, 0, 1, -len/2, len/2); let y2 = map(v_end, 0, 1, -len/2, len/2);
                        let ny1 = map(v_start, 0, 1, -1, 1); let ny2 = map(v_end, 0, 1, -1, 1);
                        let r1 = baseR + 4.0 * pow(ny1, 6) + 0.3;
                        let r2 = baseR + 4.0 * pow(ny2, 6) + 0.3;
                        normal(cos(theta), 0, sin(theta));
                        vertex(r1*cos(theta), y1, r1*sin(theta));
                        vertex(r2*cos(theta), y2, r2*sin(theta));
                    }
                    endShape();
                };

                drawBand(this.b1, 0.30); 
                drawBand(this.b2, 0.40);
                drawBand(this.b3, 0.60); 
                drawBand(color(218, 165, 32), 0.70); 

                pop();
            }
        }

        function windowResized() { resizeCanvas(windowWidth, windowHeight); }
    </script>
</body>
</html>