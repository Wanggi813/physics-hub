<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
<title>í¬ë¬¼ì„  ìš´ë™</title>
<style>
  :root{
    --ink:#0e1628; --bg:#e9f5ff; --panel:#ffffffd6; --accent:#2563eb;
    --pe:#7c3aed; --ke:#0ea5e9; --te:#fb7185; --grid:#bcd3f2; --ground:#2fa36a;
    --radius:14px; --shadow:0 10px 24px rgba(2,6,23,.18);
  }
  *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Pretendard,Malgun Gothic,sans-serif}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);overflow:hidden;overscroll-behavior:none}
  #sim{position:fixed; inset:0; width:100vw; height:100vh; display:block; background:#d9eeff; touch-action:none}

  .hint{
    position:fixed; left:calc(16px + env(safe-area-inset-left)); top:calc(16px + env(safe-area-inset-top));
    background:var(--panel); color:#1e293b;
    padding:10px 12px; border:1px solid #d0def5; border-radius:10px; font-size:13px; z-index:3; box-shadow:var(--shadow)
  }
  .streak{
    position:fixed; left:50%; transform:translateX(-50%);
    top:calc(16px + env(safe-area-inset-top));
    background:var(--panel); border:1px solid #d0def5; border-radius:10px; padding:8px 12px;
    box-shadow:var(--shadow); font-size:14px; color:#0b1220; z-index:3;
  }
  .panel{
    position:fixed; right:calc(16px + env(safe-area-inset-right)); top:calc(16px + env(safe-area-inset-top));
    width:min(380px,92vw);
    background:var(--panel); backdrop-filter: blur(6px);
    border:1px solid #d0def5; border-radius:var(--radius); box-shadow:var(--shadow);
    padding:12px 14px; color:#0b1220; z-index:3
  }
  h1{margin:0 0 6px; font-size:18px}
  .controls .row{display:grid;grid-template-columns:120px 1fr 64px;gap:8px;align-items:center;margin:8px 0}
  input[type="range"]{width:100%; height:28px}
  .btns{display:flex;gap:8px;margin-top:6px;flex-wrap:wrap}
  button{padding:12px 14px;border-radius:12px;border:1px solid #b9c8ea;background:#e7efff;color:#0b1220;cursor:pointer;min-height:44px}
  button.primary{background:var(--accent);border-color:var(--accent);color:#fff}
  button:disabled{opacity:.45;cursor:not-allowed}
  label.chk{user-select:none;display:inline-flex;gap:8px;align-items:center;color:#334155;margin-top:4px}

  input[type="range"]{-webkit-appearance:none; appearance:none; background:transparent}
  input[type="range"]::-webkit-slider-runnable-track{height:8px;background:#cfe0ff;border-radius:999px}
  input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none; width:22px;height:22px;border-radius:50%;background:#2563eb;border:2px solid #fff;margin-top:-7px;box-shadow:0 2px 6px rgba(0,0,0,.2)}
  input[type="range"]::-moz-range-track{height:8px;background:#cfe0ff;border-radius:999px}
  input[type="range"]::-moz-range-thumb{width:22px;height:22px;border-radius:50%;background:#2563eb;border:2px solid #fff;box-shadow:0 2px 6px rgba(0,0,0,.2)}

  .bars{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;height:140px;align-items:end;margin-top:8px}
  .bar{position:relative;background:#f5f8ff;border:1px solid #d0def5;border-radius:10px;overflow:hidden}
  .fill{position:absolute;left:0;right:0;bottom:0;height:0%}
  .fill.pe{background:linear-gradient(180deg,#c084fc,#7c3aed)}
  .fill.ke{background:linear-gradient(180deg,#67e8f9,#0ea5e9)}
  .fill.te{background:linear-gradient(180deg,#fca5a5,#fb7185)}
  .bar .label{position:absolute;inset:auto 0 6px 0;text-align:center;font-size:12px;color:#0b1220;font-weight:700}

  .theory{
    position:fixed; left:50%; transform:translateX(-50%);
    bottom:calc(16px + env(safe-area-inset-bottom));
    background:var(--panel); border:1px solid #d0def5; border-radius:10px; padding:10px 12px;
    box-shadow:var(--shadow); font-size:14px; color:#1e293b; z-index:3; display:none;
  }
  .legend{font-size:12px;color:#334155;margin-top:6px}
  .chip{display:inline-flex;gap:6px;align-items:center}
  .dot{width:10px;height:10px;border-radius:50%}
  .pe{background:var(--pe)} .ke{background:var(--ke)} .te{background:var(--te)}

  @media (max-width: 820px) {
    .panel{
    left:calc(10px + env(safe-area-inset-left));
    right:calc(10px + env(safe-area-inset-right));
    bottom:calc(10px + env(safe-area-inset-bottom));
    top:auto;
    width:auto;

    /* ğŸ”¥ í•µì‹¬: íŒ¨ë„ì´ í™”ë©´ì„ ë„ˆë¬´ ë§ì´ ë®ì§€ ì•Šê²Œ */
    max-height: 38vh;
    overflow:auto;

    /* ë³´ê¸° ì¢‹ê²Œ */
    border-radius: 16px;
  }

  /* ì—ë„ˆì§€ ë°”ê°€ í° í¸ì´ë¼ ë” ë®ìŠµë‹ˆë‹¤ â†’ ëª¨ë°”ì¼ì—ì„œ ì¤„ì´ê¸° */
  .bars{ height: 90px; }
}
</style>
</head>
<body>
  <canvas id="sim" aria-label="í¬ë¬¼ì„  ìš´ë™ ì‹œë®¬ë ˆì´ì…˜ (ëª¨ë°”ì¼ ëŒ€ì‘)"></canvas>

  <div class="hint" id="mission">ğŸ¯ íŠ¹ìˆ˜ê° ë¯¸ì…˜ ì¤€ë¹„ ì¤‘...</div>
  <div class="streak" id="streakBox">ì—°ì† ì„±ê³µ: <b>0</b></div>

  <div class="panel">
    <h1>ê¶¤ë„ ë§ˆìŠ¤í„°: í¬ë¬¼ì„  ìš´ë™ ì‹œë®¬ë ˆì´í„°</h1>
    <div class="legend">
      <span class="chip"><span class="dot pe"></span>PE</span> Â·
      <span class="chip"><span class="dot ke"></span>KE</span> Â·
      <span class="chip"><span class="dot te"></span>Total</span>
      â€” ì €í•­ OFF: Total ì¼ì • / ON: ê°ì†Œ
    </div>
    <div class="controls">
      <div class="row">
        <span>ë°œì‚¬ ê°ë„ (Â°)</span>
        <input id="angle" type="range" min="0" max="90" step="1" value="45" />
        <span id="angleVal">45</span>
      </div>
      <div class="row">
        <span>ì´ˆê¸° ì†ë ¥ (m/s)</span>
        <input id="speed" type="range" min="1" max="100" step="1" value="50" />
        <span id="speedVal">50</span>
      </div>
      <label class="chk"><input id="air" type="checkbox" /> ê³µê¸° ì €í•­ ì ìš©</label>
      <div class="btns">
        <button id="fire" class="primary">ë°œì‚¬</button>
        <button id="reset">ì´ˆê¸°í™”(ìƒˆ ë¯¸ì…˜)</button>
      </div>
    </div>
    <div class="bars">
      <div class="bar"><div class="fill pe" id="peBar"></div><div class="label">PE</div></div>
      <div class="bar"><div class="fill ke" id="keBar"></div><div class="label">KE</div></div>
      <div class="bar"><div class="fill te" id="teBar"></div><div class="label">Total</div></div>
    </div>
  </div>

  <div class="theory" id="theoryBox">Hmax: 0.00 m Â· Rmax: 0.00 m</div>

<script>
/* =============== ê¸°ë³¸ ì…‹ì—… =============== */
const canvas = document.getElementById('sim');
const ctx = canvas.getContext('2d', { alpha: true });

const angleSl = document.getElementById('angle');
const speedSl = document.getElementById('speed');
const airChk  = document.getElementById('air');
const angleVal = document.getElementById('angleVal');
const speedVal = document.getElementById('speedVal');
const fireBtn  = document.getElementById('fire');
const resetBtn = document.getElementById('reset');
const missionEl= document.getElementById('mission');
const theoryBox= document.getElementById('theoryBox');
const streakBox= document.getElementById('streakBox');

const peBar = document.getElementById('peBar');
const keBar = document.getElementById('keBar');
const teBar = document.getElementById('teBar');

let DPR = 1;
function resizeCanvas(){
  DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
  canvas.width  = Math.floor(cssW * DPR);
  canvas.height = Math.floor(cssH * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  computeScale();
  draw();
}
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', resizeCanvas);

/* =============== ë¬¼ë¦¬ íŒŒë¼ë¯¸í„° =============== */
const g = 9.8, m = 1.0, kBase = 0.08, dt = 1/60;

/* ì›”ë“œ ìŠ¤ì¼€ì¼ (í™”ë©´ì— ê½‰ ì°¨ê²Œ + ëŒ€í¬ ì˜ ë³´ì´ê²Œ) */
let Wx = 180;   // ğŸ”¥ ì¤Œì¸(ê¸°ì¡´ 240 â†’ 180)
let Wy = 90;    // ğŸ”¥ ì„¸ë¡œë„ ê°™ì´ ì¤Œì¸
let scale = 1;
const marginTop = 20;

function computeScale(){
  const W = canvas.width / DPR;
  const H = canvas.height / DPR;

  // ê°€ë¡œ/ì„¸ë¡œ ë‘˜ ë‹¤ "ì›”ë“œê°€ í™”ë©´ ì•ˆì— ë“¤ì–´ì˜¤ë„ë¡" ë” ì‘ì€ ìŠ¤ì¼€ì¼ì„ ì‚¬ìš©
  const scaleX = W / Wx;
  const scaleY = (H - marginTop) / Wy;
  scale = Math.min(scaleX, scaleY);

  // (ì„ íƒ) í™”ë©´ë¹„ê°€ ê·¹ë‹¨ì´ë©´ Wx/Wyë¥¼ ì¡°ê¸ˆ ìë™ ë³´ì •í•˜ê³  ì‹¶ìœ¼ë©´ ì—¬ê¸°ì„œ ì¡°ì • ê°€ëŠ¥
}
/* ì¢Œí‘œ ë³€í™˜ */
function worldToCanvas(wx, wy){
  return { x: wx*scale, y: (canvas.height/DPR) - marginTop - wy*scale };
}
function canvasToWorld(cx, cy){
  return { x: cx/scale, y: ((canvas.height/DPR) - marginTop - cy)/scale };
}

/* =============== ê°ì²´ =============== */
const cannon = { x: 14, y: 0, barrelLen: 12, angleDeg: 45 };
const projectile = { x:cannon.x, y:cannon.y, vx:0, vy:0, r:1.6, flying:false, path:[], t:0 };
const target = { x: 150, y: 4, r: 6 };

let animId = null, E_init = 1e-6;

/* íŠ¹ìˆ˜ê° */
const SPECIAL_ANGLES = [30,45,60];
let missionAngle = 45;

/* ê²°ê³¼ ì œì–´ */
let showResults = false;
let lastShot = { v:0, th:0 };
let lastResult = { Hmax:0, Rmax:0, xApex:0, empirical:false }; // empirical = ì €í•­ ONì¼ ë•Œ ì‹¤ì¸¡

/* ìŠ¤íŠ¸ë¦­ + ì ìˆ˜ */
let streak = 0;
let currentScore = 0;
let bestScore = 0;
function updateStreakUI(){
  streakBox.innerHTML = `ì—°ì† ì„±ê³µ: <b>${streak}</b> Â· ìµœê³  ì ìˆ˜: <b>${bestScore}</b>`;
}
// Firebaseì—ì„œ ìµœê³  ì ìˆ˜ë¥¼ ë¶ˆëŸ¬ì˜¨ ê²½ìš° UI ë°˜ì˜ìš©
window.setBestScoreFromFirebase = function(score){
  bestScore = Number(score) || 0;
  updateStreakUI();
};

/* =============== ìœ í‹¸ =============== */
const clamp = (v,min,max)=> Math.max(min, Math.min(max, v));
const clamp01 = v => clamp(v,0,1);
const fmt = n => Number.isFinite(n) ? n.toFixed(2) : '0.00';

/* =============== ë¯¸ì…˜ ë°°ì¹˜ (ì´ˆê¸°í™” ë•Œë§Œ) =============== */
function placeTargetBySpecialAngle(){
  // 1) íŠ¹ìˆ˜ê°ì„ ë¬´ì‘ìœ„ë¡œ ì„ íƒ
  missionAngle = SPECIAL_ANGLES[Math.floor(Math.random()*SPECIAL_ANGLES.length)];

  // 2) ì†ë ¥ë„ ë„“ì€ ë²”ìœ„ì—ì„œ ë¬´ì‘ìœ„ (ìŠ¬ë¼ì´ë” min/maxë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©)
  const vMin = Number(speedSl.min || 1);
  const vMax = Number(speedSl.max || 100);
  const v = Math.round(vMin + Math.random()*(vMax - vMin));
  speedSl.value = v;
  speedVal.textContent = String(v);

  // 3) ì´ ì†ë ¥ê³¼ ê°ë„ë¡œ ì‚¬ê±°ë¦¬ ê³„ì‚° â†’ ê³¼ë… ë°°ì¹˜
  const R = (v*v*Math.sin(2*missionAngle*Math.PI/180))/g;
  const maxX = Wx * 0.92, minX = Wx * 0.25;
  target.x = clamp(cannon.x + R, minX, maxX);
  target.y = 4;

  // 4) ë¯¸ì…˜ ì•ˆë‚´
  missionEl.innerHTML = `ğŸ¯ íŠ¹ìˆ˜ê° ë„ì „: <b>${missionAngle}Â°</b> (ê³¼ë…ì€ ì´ˆê¸°í™” ì‹œì  ì†ë ¥ ê¸°ì¤€) Â· í¬ì‹ ì„ <b>ë“œë˜ê·¸</b>í•´ ê°ë„ ì¡°ì ˆ`;
}


/* =============== í•´ì„/ì‹¤ì¸¡ ê²°ê³¼ =============== */
function theoryValues(v, th){
  const Hmax = (v*v*Math.sin(th)*Math.sin(th))/(2*g);
  const Rmax = (v*v*Math.sin(2*th))/g;
  const xApex = (v*v*Math.sin(2*th))/(2*g);
  return {Hmax, Rmax, xApex};
}
function setResultBox(){
  const suffix = airChk.checked ? ' (ì‹¤ì¸¡)' : ' (ì´ë¡ )';
  theoryBox.textContent = `Hmax: ${fmt(lastResult.Hmax)} m Â· Rmax: ${fmt(lastResult.Rmax)} m${suffix}`;
  theoryBox.style.display = showResults ? 'block' : 'none';
}

/* =============== ì´ˆê¸°í™”/ë°œì‚¬/ë£¨í”„ =============== */
function resetAll(newMission=true){
  cancelAnim();
  Object.assign(projectile, {x:cannon.x,y:cannon.y,vx:0,vy:0,flying:false,path:[],t:0});
  E_init = 1e-6;
  showResults = false;
  lastResult = {Hmax:0,Rmax:0,xApex:0,empirical:false};
  theoryBox.style.display = 'none';
  if(newMission) placeTargetBySpecialAngle();
  updateBars(0,0,0);
  draw();
}

function fire(){
  if(projectile.flying) return;
  const v = Number(speedSl.value);
  const th = cannon.angleDeg * Math.PI/180;
  projectile.vx = v*Math.cos(th);
  projectile.vy = v*Math.sin(th);
  projectile.flying = true;
  projectile.t = 0;
  projectile.path = [{x:projectile.x, y:projectile.y}];
  lastShot = { v, th };
  showResults = false;
  theoryBox.style.display = 'none';

  const KE0 = 0.5*m*(projectile.vx**2 + projectile.vy**2);
  const PE0 = m*g*projectile.y;
  E_init = KE0 + PE0;

  // ì‹¤ì¸¡ ì¶”ì  ë³€ìˆ˜(ì €í•­ ONì¼ ë•Œ ì‚¬ìš©)
  track.maxY = 0;
  track.xAtMaxY = projectile.x;
  track.impactX = null;

  loop();
}

function loop(){
  stepPhysics(); draw();
  if(projectile.flying) animId = requestAnimationFrame(loop);
}
function cancelAnim(){ if(animId){ cancelAnimationFrame(animId); animId=null; }}

/* =============== ë¬¼ë¦¬ ì—…ë°ì´íŠ¸ =============== */
let pathStep = 0;
const track = { maxY:0, xAtMaxY:0, impactX:null };

function stepPhysics(){
  const k = airChk.checked ? kBase : 0;
  const ax = -k*projectile.vx;
  const ay = -g - k*projectile.vy;

  projectile.vx += ax*dt;
  projectile.vy += ay*dt;
  projectile.x  += projectile.vx*dt;
  projectile.y  += projectile.vy*dt;
  projectile.t  += dt;

  // ê¶¤ì  ì €ì¥(ê°„í—)
  if((pathStep++ % 2) === 0){
    projectile.path.push({x:projectile.x, y:projectile.y});
    if(projectile.path.length > 2000) projectile.path.shift();
  }

  // ì‹¤ì¸¡ ìµœê³ ì  ì¶”ì 
  if(projectile.y > track.maxY){
    track.maxY = projectile.y;
    track.xAtMaxY = projectile.x;
  }

  let finished = false;
  let hit = false;

  // ì§€ë©´ ì¶©ëŒ: impactX ê¸°ë¡
  if(projectile.y <= 0){
    // ì„ í˜• ë³´ê°„ìœ¼ë¡œ ì°©ì§€ xë¥¼ ì¡°ê¸ˆ ë” ì •í™•íˆ
    const n = projectile.path.length;
    if(n >= 2){
      const p1 = projectile.path[n-2];
      const p2 = projectile.path[n-1];
      const t = (0 - p1.y) / ((p2.y - p1.y)||1e-6);
      track.impactX = p1.x + (p2.x - p1.x)*t;
    } else {
      track.impactX = projectile.x;
    }
    projectile.y=0; projectile.flying=false; finished = true;
  }

  // ê³¼ë… íˆíŠ¸
  const dx = projectile.x-target.x, dy = projectile.y-target.y;
  if(Math.hypot(dx,dy) <= (projectile.r + target.r)){ projectile.flying=false; finished = true; hit = true; }

  // í™”ë©´ ì´íƒˆ
  if(projectile.x > Wx+2 || projectile.y > Wy+2){ projectile.flying=false; finished = true; }

  // ì—ë„ˆì§€ ë§‰ëŒ€
  const KE = 0.5*m*(projectile.vx**2 + projectile.vy**2);
  const PE = m*g*Math.max(0, projectile.y);
  updateBars(PE, KE, KE+PE);

  // ë¹„í–‰ ì¢…ë£Œ â†’ ê²°ê³¼ í™•ì •
  if(finished){
    if(airChk.checked){
      // ì‹¤ì¸¡ê°’ ì‚¬ìš©
      lastResult = {
        Hmax: Math.max(0, track.maxY),
        Rmax: Math.max(0, track.impactX ?? projectile.x),
        xApex: track.xAtMaxY,
        empirical: true
      };
    }else{
      // ì´ë¡ ê°’ ì‚¬ìš©
      lastResult = { ...theoryValues(lastShot.v, lastShot.th), empirical:false };
    }

    showResults = true;
    setResultBox();
    if (hit) {
      // ëª…ì¤‘í•  ë•Œë§ˆë‹¤ 100ì ì”© ëˆ„ì ë˜ëŠ” í˜„ì¬ ì ìˆ˜ (ì—°ì† ì„±ê³µ ê¸°ì¤€)
      streak += 1;
      currentScore = streak * 100;
      if (currentScore > bestScore) {
        bestScore = currentScore;
        // Firebaseì— ìµœê³  ì ìˆ˜ ì €ì¥ (ë¡œê·¸ì¸ ë˜ì–´ ìˆê³  í•¨ìˆ˜ê°€ ì •ì˜ëœ ê²½ìš°)
        if (window.saveBestScoreToFirebase) {
          window.saveBestScoreToFirebase(bestScore);
        }
      }
    } else {
      // ì‹¤íŒ¨í•˜ë©´ ì—°ì† ì„±ê³µë§Œ 0ìœ¼ë¡œ ì´ˆê¸°í™”, ìµœê³  ì ìˆ˜ëŠ” ìœ ì§€
      streak = 0;
    }
    updateStreakUI();
  }
}

/* =============== UI/ê·¸ë˜í”„ =============== */
function updateBars(PE,KE,TE){
  const denom = Math.max(E_init, 1e-6);
  peBar.style.height = (clamp01(PE/denom)*100).toFixed(2)+'%';
  keBar.style.height = (clamp01(KE/denom)*100).toFixed(2)+'%';
  teBar.style.height = (clamp01(TE/denom)*100).toFixed(2)+'%';
}

/* =============== ë Œë”ë§ =============== */
function draw(){
  const W = canvas.width/DPR, H = canvas.height/DPR;

  // í•˜ëŠ˜(ë‚®)
  const sky = ctx.createLinearGradient(0,0,0,H);
  sky.addColorStop(0,'#bfe6ff'); sky.addColorStop(0.6,'#d9f1ff'); sky.addColorStop(1,'#ecf7ff');
  ctx.fillStyle = sky; ctx.fillRect(0,0,W,H);

  // ì‚°/ìˆ²
  drawMountains(W,H);
  drawTreeLine(W,H, 0.78, '#79c483', 0.35, 18);
  drawTreeLine(W,H, 0.70, '#4fb46a', 0.5, 22);
  drawTreeLine(W,H, 0.64, '#2fa36a', 0.7, 26);

  // ê·¸ë¦¬ë“œ/ì§€ë©´
  drawGrid(W,H);
  drawGround(W,H);

  // ê²°ê³¼ ë§ˆì»¤ & ê¹ƒë°œ
  if(showResults){ drawResultMarkers(lastResult); }

  // ê³¼ë…/í¬ëŒ€/ê¶¤ì /í¬íƒ„
  drawTarget();
  drawCannon();
  drawPath();
  drawProjectile();

  // ë°°ë„ˆ
  if(!projectile.flying && projectile.path.length>1){
    const last = projectile.path.at(-1);
    const hit = Math.hypot(last.x-target.x, last.y-target.y) <= (projectile.r + target.r) + 0.05;
    drawBanner(hit ? "ëª…ì¤‘!" : "ì°©ì§€");
  }
}

function drawMountains(W,H){
  ctx.save();
  ctx.fillStyle = '#b9d9f4';
  const baseY = H*0.62;
  ctx.beginPath(); ctx.moveTo(0,baseY);
  const peaks = [
    {x: W*0.08, y: baseY-90},{x: W*0.2, y: baseY-50},
    {x: W*0.34, y: baseY-120},{x: W*0.52, y: baseY-70},
    {x: W*0.7, y: baseY-130},{x: W*0.88, y: baseY-60}
  ];
  peaks.forEach(p=>{ ctx.lineTo(p.x,p.y); ctx.lineTo(p.x+48, baseY); });
  ctx.lineTo(W,baseY); ctx.lineTo(W,H); ctx.lineTo(0,H); ctx.closePath();
  ctx.globalAlpha=0.65; ctx.fill();
  ctx.restore();
}
function drawTreeLine(W,H, yRatio, color, alpha, count){
  ctx.save();
  const groundY = worldToCanvas(0,0).y;
  const y = H*yRatio;
  ctx.globalAlpha = alpha;
  for(let i=0;i<count;i++){
    const x = (i+0.5)*(W/count) + (i%2?12:-12);
    const h = 38 + (i%3)*16 + (1+Math.sin(i*1.3))*6;
    drawPine(x,y,h,color);
  }
  ctx.fillStyle='rgba(47,163,106,0.25)'; ctx.fillRect(0,y+8,W, groundY-(y+8));
  ctx.restore();
}
function drawPine(cx, baseY, h, color){
  ctx.save(); ctx.fillStyle=color;
  const levels=[h*0.5,h*0.3,h*0.2]; let y=baseY;
  for(let i=0;i<3;i++){
    const w=(i===0?h*0.5:i===1?h*0.38:h*0.3);
    ctx.beginPath(); ctx.moveTo(cx-w,y); ctx.lineTo(cx,y-levels[i]); ctx.lineTo(cx+w,y);
    ctx.closePath(); ctx.fill(); y-=levels[i]*0.7;
  }
  ctx.fillStyle='#7b5b3a'; ctx.fillRect(cx-2, baseY, 4, 10);
  ctx.restore();
}
function drawGrid(W,H){
  ctx.save(); ctx.strokeStyle='rgba(60,110,170,0.15)'; ctx.lineWidth=1;
  for(let x=0;x<=Wx;x+=10){ const p=worldToCanvas(x,0); ctx.beginPath(); ctx.moveTo(p.x,0); ctx.lineTo(p.x,H); ctx.stroke(); }
  for(let y=10;y<=Wy;y+=10){ const p=worldToCanvas(0,y); ctx.beginPath(); ctx.moveTo(0,p.y); ctx.lineTo(W,p.y); ctx.stroke(); }
  ctx.restore();
}
function drawGround(W,H){
  const p0=worldToCanvas(0,0), p1=worldToCanvas(Wx,0);
  ctx.save();
  ctx.strokeStyle=varGet('--ground','#2fa36a'); ctx.lineWidth=4;
  ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.stroke();
  const g=ctx.createLinearGradient(0,p0.y,0,H);
  g.addColorStop(0,'#bff3cf'); g.addColorStop(1,'#93e0b9');
  ctx.fillStyle=g; ctx.fillRect(0,p0.y,W,H-p0.y);
  ctx.restore();
}
function varGet(name,fallback){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim()||fallback; }

/* --- ê²°ê³¼ ë§ˆì»¤(ì´ë¡ /ì‹¤ì¸¡ ê³µí†µ) --- */
function drawResultMarkers(res){
  const groundY = worldToCanvas(0,0).y;

  // ìµœê³ ì 
  const apexP = worldToCanvas(cannon.x + res.xApex, res.Hmax);
  ctx.save();
  ctx.strokeStyle = 'rgba(37,99,235,0.9)'; ctx.lineWidth = 2;
  ctx.setLineDash([5,5]);
  ctx.beginPath(); ctx.moveTo(apexP.x, groundY); ctx.lineTo(apexP.x, apexP.y); ctx.stroke();
  ctx.setLineDash([]); drawTag(apexP.x+6, apexP.y-6, `Hmax ${fmt(res.Hmax)} m${res.empirical?'(ì‹¤ì¸¡)':'(ì´ë¡ )'}`); ctx.restore();

  // ì‚¬ê±°ë¦¬ + ê¹ƒë°œ
  const rangeP = worldToCanvas(cannon.x + res.Rmax, 0);
  ctx.save();
  ctx.strokeStyle = 'rgba(234,88,12,0.9)'; ctx.lineWidth = 2;
  ctx.setLineDash([5,5]); ctx.beginPath(); ctx.moveTo(rangeP.x, groundY); ctx.lineTo(rangeP.x, groundY-50); ctx.stroke();
  ctx.setLineDash([]); drawFlag(rangeP.x, groundY-50); drawTag(rangeP.x+8, groundY-56, `Rmax ${fmt(res.Rmax)} m${res.empirical?'(ì‹¤ì¸¡)':'(ì´ë¡ )'}`); ctx.restore();
}

function drawFlag(x, yTop){
  ctx.save();
  ctx.strokeStyle = '#0b1220'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(x, yTop); ctx.lineTo(x, yTop+28); ctx.stroke();
  ctx.fillStyle = '#ef4444';
  ctx.beginPath(); ctx.moveTo(x, yTop+4); ctx.lineTo(x+18, yTop+10); ctx.lineTo(x, yTop+16); ctx.closePath(); ctx.fill();
  ctx.restore();
}
function drawTag(x,y,text){
  ctx.save();
  ctx.font='12px system-ui, sans-serif';
  const w = ctx.measureText(text).width + 10;
  ctx.fillStyle = 'rgba(255,255,255,0.95)';
  ctx.fillRect(x,y-14,w,18);
  ctx.strokeStyle='#93b6f0'; ctx.strokeRect(x,y-14,w,18);
  ctx.fillStyle='#0b1220'; ctx.fillText(text, x+5, y);
  ctx.restore();
}

function drawCannon(){
  const theta = cannon.angleDeg * Math.PI/180;
  const base = worldToCanvas(cannon.x, cannon.y);
  const tipW = { x: cannon.x + cannon.barrelLen*Math.cos(theta),
                 y: cannon.y + cannon.barrelLen*Math.sin(theta) };
  const tip = worldToCanvas(tipW.x, tipW.y);

  ctx.save();
  ctx.fillStyle = '#36507a';
  ctx.beginPath(); ctx.arc(base.x, base.y, 18, Math.PI, 0); ctx.fill();

  ctx.strokeStyle = '#0b1220'; ctx.lineWidth = 10; ctx.lineCap = 'round';
  ctx.beginPath(); ctx.moveTo(base.x, base.y); ctx.lineTo(tip.x, tip.y); ctx.stroke();

  ctx.setLineDash([8,6]); ctx.lineWidth=2; ctx.strokeStyle='rgba(37,99,235,.9)';
  ctx.beginPath(); ctx.moveTo(tip.x, tip.y); ctx.lineTo(tip.x + 70*Math.cos(theta), tip.y - 70*Math.sin(-theta)); ctx.stroke();

  ctx.setLineDash([]); ctx.fillStyle='#2563eb'; ctx.strokeStyle='#93b6f0'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.arc(tip.x, tip.y, 9, 0, Math.PI*2); ctx.fill(); ctx.stroke();
  ctx.restore();
}

function drawTarget(){
  const p = worldToCanvas(target.x, target.y);
  const R = target.r * scale;
  ctx.save();
  ctx.fillStyle='#7b5b3a'; ctx.fillRect(p.x-6, p.y, 12, 20);
  for(let i=3;i>=1;i--){
    ctx.beginPath(); ctx.arc(p.x, p.y, R*(i/3), 0, Math.PI*2);
    ctx.fillStyle = i===1 ? '#ef4444' : (i===2 ? '#f59e0b' : '#10b981');
    ctx.globalAlpha=0.95; ctx.fill();
  }
  ctx.restore();
}
function drawProjectile(){
  const p = worldToCanvas(projectile.x, projectile.y);
  const R = projectile.r * scale;
  ctx.save(); ctx.fillStyle='#0b1220';
  ctx.beginPath(); ctx.arc(p.x, p.y, R, 0, Math.PI*2); ctx.fill(); ctx.restore();
}
function drawPath(){
  if(projectile.path.length<2) return;
  ctx.save(); ctx.lineWidth=3; ctx.strokeStyle='rgba(14,165,233,.95)';
  ctx.beginPath();
  let p0=worldToCanvas(projectile.path[0].x, projectile.path[0].y);
  ctx.moveTo(p0.x,p0.y);
  for(let i=1;i<projectile.path.length;i++){
    const pi=worldToCanvas(projectile.path[i].x, projectile.path[i].y);
    ctx.lineTo(pi.x,pi.y);
  }
  ctx.stroke(); ctx.restore();
}
function drawBanner(text){
  const W=canvas.width/DPR;
  ctx.save(); ctx.font='bold 24px system-ui, sans-serif';
  const w=ctx.measureText(text).width+24; const x=W/2-w/2, y=36;
  ctx.fillStyle='rgba(255,255,255,.95)'; ctx.fillRect(x,y,w,36);
  ctx.strokeStyle='#2563eb'; ctx.lineWidth=2; ctx.strokeRect(x,y,w,36);
  ctx.fillStyle='#0b1220'; ctx.fillText(text, x+12, y+26);
  ctx.restore();
}

/* =============== ë“œë˜ê·¸ =============== */
let draggingAngle=false;
function pointerPos(e){
  const r=canvas.getBoundingClientRect();
  const cx=(e.touches?e.touches[0].clientX:e.clientX)-r.left;
  const cy=(e.touches?e.touches[0].clientY:e.clientY)-r.top;
  return {cx,cy};
}
function startDrag(e){
  const {cx,cy}=pointerPos(e);
  const base=worldToCanvas(cannon.x,cannon.y);
  const theta=cannon.angleDeg*Math.PI/180;
  const tip=worldToCanvas(cannon.x+cannon.barrelLen*Math.cos(theta),cannon.y+cannon.barrelLen*Math.sin(theta));
  const dBase=Math.hypot(cx-base.x,cy-base.y);
  const dTip =Math.hypot(cx-tip.x, cy-tip.y);
  if(dBase<32 || dTip<28){ draggingAngle=true; updateAngleFromPointer(cx,cy); e.preventDefault(); }
}
function moveDrag(e){
  if(!draggingAngle) return;
  const {cx,cy}=pointerPos(e);
  updateAngleFromPointer(cx,cy); e.preventDefault();
}
function endDrag(){ draggingAngle=false; }
function updateAngleFromPointer(cx,cy){
  const baseC=worldToCanvas(cannon.x,cannon.y);
  const dx=cx-baseC.x, dy=baseC.y-cy;
  let deg=Math.atan2(Math.max(0,dy), Math.max(0.0001,dx))*180/Math.PI;
  deg=Math.max(0, Math.min(90, deg));
  cannon.angleDeg=deg;
  angleSl.value=Math.round(deg);
  angleVal.textContent=Math.round(deg);
  showResults=false; theoryBox.style.display='none'; draw();
}

/* =============== ì´ë²¤íŠ¸ =============== */
angleSl.addEventListener('input', ()=>{
  cannon.angleDeg=Number(angleSl.value);
  angleVal.textContent=angleSl.value;
  showResults=false; theoryBox.style.display='none'; draw();
});
speedSl.addEventListener('input', ()=>{
  speedVal.textContent=speedSl.value;
  showResults=false; theoryBox.style.display='none';
});
airChk.addEventListener('change', ()=>{ draw(); });

fireBtn.addEventListener('click', ()=>{ fire(); fireBtn.disabled=true; });
resetBtn.addEventListener('click', ()=>{ resetAll(true); fireBtn.disabled=false; });

canvas.addEventListener('pointerdown', startDrag, {passive:false});
canvas.addEventListener('pointermove',  moveDrag,  {passive:false});
window.addEventListener('pointerup',    endDrag,   {passive:false});
canvas.addEventListener('touchstart', startDrag, {passive:false});
canvas.addEventListener('touchmove',  moveDrag,  {passive:false});
canvas.addEventListener('touchend',   endDrag);

/* =============== ì‹œì‘ =============== */
resizeCanvas();
updateStreakUI();
cannon.angleDeg = Number(angleSl.value);
speedVal.textContent = speedSl.value;
resetAll(true);
draw();
</script>

<!-- ===== Firebase ì ìˆ˜ ì—°ë™ (í¬ë¬¼ì„  ìš´ë™) ===== -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
  import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";
  import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";

  // ë©”ì¸ í—ˆë¸Œ(index.html)ì™€ ë™ì¼í•œ Firebase ì„¤ì •
  const firebaseConfig = {
    apiKey: "AIzaSyCO36JgPpNz8swADxTMVJUFVALWM5o171w",
    authDomain: "simulation-67cd3.firebaseapp.com",
    projectId: "simulation-67cd3",
    storageBucket: "simulation-67cd3.appspot.com",
    messagingSenderId: "615983461615",
    appId: "1:615983461615:web:002e07bcea878eb6d5571a",
    measurementId: "G-9RGN7LYE5W"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  const SIM_ID = "í¬ë¬¼ì„ _ìš´ë™";

  let firebaseUser = null;

  // ìµœê³  ì ìˆ˜ Firestoreì— ì €ì¥
  async function saveBestScore(score) {
    if (!firebaseUser) return;
    try {
      const ref = doc(db, "users", firebaseUser.uid, "simulations", SIM_ID);
      await setDoc(ref, { score: Number(score) || 0 }, { merge: true });
    } catch (err) {
      console.error("[í¬ë¬¼ì„  ìš´ë™] ìµœê³  ì ìˆ˜ ì €ì¥ ì˜¤ë¥˜:", err);
    }
  }

  // ìµœì´ˆ ì ‘ì† ì‹œ ê¸°ì¡´ ìµœê³  ì ìˆ˜ ë¡œë“œ
  async function loadBestScore() {
    if (!firebaseUser) return;
    try {
      const ref = doc(db, "users", firebaseUser.uid, "simulations", SIM_ID);
      const snap = await getDoc(ref);
      if (snap.exists()) {
        const data = snap.data();
        const score = Number(data.score || 0) || 0;
        // ë©”ì¸ ìŠ¤í¬ë¦½íŠ¸ì— ì „ë‹¬ (UIì™€ ë‚´ë¶€ ë³€ìˆ˜ ë™ê¸°í™”)
        if (window.setBestScoreFromFirebase) {
          window.setBestScoreFromFirebase(score);
        }
      }
    } catch (err) {
      console.error("[í¬ë¬¼ì„  ìš´ë™] ìµœê³  ì ìˆ˜ ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜:", err);
    }
  }

  // ì „ì—­ì—ì„œ í˜¸ì¶œí•  ìˆ˜ ìˆë„ë¡ ë…¸ì¶œ
  window.saveBestScoreToFirebase = saveBestScore;

  // ë¡œê·¸ì¸ ìƒíƒœ ë³€í™” ê°ì§€ â†’ í•´ë‹¹ ID ê¸°ì¤€ ìµœê³  ì ìˆ˜ ì—°ë™
  onAuthStateChanged(auth, async (user) => {
    firebaseUser = user;
    if (user) {
      await loadBestScore();
    }
  });
</script>

</body>
</html>
