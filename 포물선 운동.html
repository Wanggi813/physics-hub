<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
<title>궤도 마스터 — 공기저항 실측 Hmax/Rmax 반영</title>
<style>
  :root{
    --ink:#0e1628; --bg:#e9f5ff; --panel:#ffffffd6; --accent:#2563eb;
    --pe:#7c3aed; --ke:#0ea5e9; --te:#fb7185; --grid:#bcd3f2; --ground:#2fa36a;
    --radius:14px; --shadow:0 10px 24px rgba(2,6,23,.18);
  }
  *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Pretendard,Malgun Gothic,sans-serif}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);overflow:hidden;overscroll-behavior:none}
  #sim{position:fixed; inset:0; width:100vw; height:100vh; display:block; background:#d9eeff; touch-action:none}

  .hint{
    position:fixed; left:calc(16px + env(safe-area-inset-left)); top:calc(16px + env(safe-area-inset-top));
    background:var(--panel); color:#1e293b;
    padding:10px 12px; border:1px solid #d0def5; border-radius:10px; font-size:13px; z-index:3; box-shadow:var(--shadow)
  }
  .streak{
    position:fixed; left:50%; transform:translateX(-50%);
    top:calc(16px + env(safe-area-inset-top));
    background:var(--panel); border:1px solid #d0def5; border-radius:10px; padding:8px 12px;
    box-shadow:var(--shadow); font-size:14px; color:#0b1220; z-index:3;
  }
  .panel{
    position:fixed; right:calc(16px + env(safe-area-inset-right)); top:calc(16px + env(safe-area-inset-top));
    width:min(380px,92vw);
    background:var(--panel); backdrop-filter: blur(6px);
    border:1px solid #d0def5; border-radius:var(--radius); box-shadow:var(--shadow);
    padding:12px 14px; color:#0b1220; z-index:3
  }
  h1{margin:0 0 6px; font-size:18px}
  .controls .row{display:grid;grid-template-columns:120px 1fr 64px;gap:8px;align-items:center;margin:8px 0}
  input[type="range"]{width:100%; height:28px}
  .btns{display:flex;gap:8px;margin-top:6px;flex-wrap:wrap}
  button{padding:12px 14px;border-radius:12px;border:1px solid #b9c8ea;background:#e7efff;color:#0b1220;cursor:pointer;min-height:44px}
  button.primary{background:var(--accent);border-color:var(--accent);color:#fff}
  button:disabled{opacity:.45;cursor:not-allowed}
  label.chk{user-select:none;display:inline-flex;gap:8px;align-items:center;color:#334155;margin-top:4px}

  input[type="range"]{-webkit-appearance:none; appearance:none; background:transparent}
  input[type="range"]::-webkit-slider-runnable-track{height:8px;background:#cfe0ff;border-radius:999px}
  input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none; width:22px;height:22px;border-radius:50%;background:#2563eb;border:2px solid #fff;margin-top:-7px;box-shadow:0 2px 6px rgba(0,0,0,.2)}
  input[type="range"]::-moz-range-track{height:8px;background:#cfe0ff;border-radius:999px}
  input[type="range"]::-moz-range-thumb{width:22px;height:22px;border-radius:50%;background:#2563eb;border:2px solid #fff;box-shadow:0 2px 6px rgba(0,0,0,.2)}

  .bars{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;height:140px;align-items:end;margin-top:8px}
  .bar{position:relative;background:#f5f8ff;border:1px solid #d0def5;border-radius:10px;overflow:hidden}
  .fill{position:absolute;left:0;right:0;bottom:0;height:0%}
  .fill.pe{background:linear-gradient(180deg,#c084fc,#7c3aed)}
  .fill.ke{background:linear-gradient(180deg,#67e8f9,#0ea5e9)}
  .fill.te{background:linear-gradient(180deg,#fca5a5,#fb7185)}
  .bar .label{position:absolute;inset:auto 0 6px 0;text-align:center;font-size:12px;color:#0b1220;font-weight:700}

  .theory{
    position:fixed; left:50%; transform:translateX(-50%);
    bottom:calc(16px + env(safe-area-inset-bottom));
    background:var(--panel); border:1px solid #d0def5; border-radius:10px; padding:10px 12px;
    box-shadow:var(--shadow); font-size:14px; color:#1e293b; z-index:3; display:none;
  }
  .legend{font-size:12px;color:#334155;margin-top:6px}
  .chip{display:inline-flex;gap:6px;align-items:center}
  .dot{width:10px;height:10px;border-radius:50%}
  .pe{background:var(--pe)} .ke{background:var(--ke)} .te{background:var(--te)}

  @media (max-width: 820px) {
    .panel{
      left:calc(10px + env(safe-area-inset-left));
      right:calc(10px + env(safe-area-inset-right));
      bottom:calc(10px + env(safe-area-inset-bottom));
      top:auto; width:auto;
      padding-bottom: max(12px, env(safe-area-inset-bottom));
    }
    .controls .row{grid-template-columns:110px 1fr 56px}
    h1{font-size:16px}
    .hint{left:calc(10px + env(safe-area-inset-left)); top:calc(10px + env(safe-area-inset-top)); font-size:12px}
    .streak{top:calc(10px + env(safe-area-inset-top)); font-size:13px}
    .bars{height:120px}
  }
</style>
</head>
<body>
  <canvas id="sim" aria-label="포물선 운동 시뮬레이션 (모바일 대응)"></canvas>

  <div class="hint" id="mission">🎯 특수각 미션 준비 중...</div>
  <div class="streak" id="streakBox">연속 성공: <b>0</b></div>

  <div class="panel">
    <h1>궤도 마스터: 포물선 운동 시뮬레이터</h1>
    <div class="legend">
      <span class="chip"><span class="dot pe"></span>PE</span> ·
      <span class="chip"><span class="dot ke"></span>KE</span> ·
      <span class="chip"><span class="dot te"></span>Total</span>
      — 저항 OFF: Total 일정 / ON: 감소
    </div>
    <div class="controls">
      <div class="row">
        <span>발사 각도 (°)</span>
        <input id="angle" type="range" min="0" max="90" step="1" value="45" />
        <span id="angleVal">45</span>
      </div>
      <div class="row">
        <span>초기 속력 (m/s)</span>
        <input id="speed" type="range" min="1" max="100" step="1" value="50" />
        <span id="speedVal">50</span>
      </div>
      <label class="chk"><input id="air" type="checkbox" /> 공기 저항 적용</label>
      <div class="btns">
        <button id="fire" class="primary">발사</button>
        <button id="reset">초기화(새 미션)</button>
      </div>
    </div>
    <div class="bars">
      <div class="bar"><div class="fill pe" id="peBar"></div><div class="label">PE</div></div>
      <div class="bar"><div class="fill ke" id="keBar"></div><div class="label">KE</div></div>
      <div class="bar"><div class="fill te" id="teBar"></div><div class="label">Total</div></div>
    </div>
  </div>

  <div class="theory" id="theoryBox">Hmax: 0.00 m · Rmax: 0.00 m</div>

<script>
/* =============== 기본 셋업 =============== */
const canvas = document.getElementById('sim');
const ctx = canvas.getContext('2d', { alpha: true });

const angleSl = document.getElementById('angle');
const speedSl = document.getElementById('speed');
const airChk  = document.getElementById('air');
const angleVal = document.getElementById('angleVal');
const speedVal = document.getElementById('speedVal');
const fireBtn  = document.getElementById('fire');
const resetBtn = document.getElementById('reset');
const missionEl= document.getElementById('mission');
const theoryBox= document.getElementById('theoryBox');
const streakBox= document.getElementById('streakBox');

const peBar = document.getElementById('peBar');
const keBar = document.getElementById('keBar');
const teBar = document.getElementById('teBar');

let DPR = 1;
function resizeCanvas(){
  DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
  canvas.width  = Math.floor(cssW * DPR);
  canvas.height = Math.floor(cssH * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  computeScale();
  draw();
}
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', resizeCanvas);

/* =============== 물리 파라미터 =============== */
const g = 9.8, m = 1.0, kBase = 0.08, dt = 1/60;

/* 월드 스케일 (가시성↑) */
let Wx = 240;
let Wy = 120;
let scale = 1;
const marginTop = 20;
function computeScale(){
  scale = (canvas.width / DPR) / Wx;
  Wy = ((canvas.height / DPR) - marginTop) / scale;
}

/* 좌표 변환 */
function worldToCanvas(wx, wy){
  return { x: wx*scale, y: (canvas.height/DPR) - marginTop - wy*scale };
}
function canvasToWorld(cx, cy){
  return { x: cx/scale, y: ((canvas.height/DPR) - marginTop - cy)/scale };
}

/* =============== 객체 =============== */
const cannon = { x: 14, y: 0, barrelLen: 12, angleDeg: 45 };
const projectile = { x:cannon.x, y:cannon.y, vx:0, vy:0, r:1.6, flying:false, path:[], t:0 };
const target = { x: 150, y: 4, r: 6 };

let animId = null, E_init = 1e-6;

/* 특수각 */
const SPECIAL_ANGLES = [30,45,60];
let missionAngle = 45;

/* 결과 제어 */
let showResults = false;
let lastShot = { v:0, th:0 };
let lastResult = { Hmax:0, Rmax:0, xApex:0, empirical:false }; // empirical = 저항 ON일 때 실측

/* 스트릭 */
let streak = 0;
function updateStreakUI(){ streakBox.innerHTML = `연속 성공: <b>${streak}</b>`; }

/* =============== 유틸 =============== */
const clamp = (v,min,max)=> Math.max(min, Math.min(max, v));
const clamp01 = v => clamp(v,0,1);
const fmt = n => Number.isFinite(n) ? n.toFixed(2) : '0.00';

/* =============== 미션 배치 (초기화 때만) =============== */
function placeTargetBySpecialAngle(){
  const v = Number(speedSl.value);
  const maxX = Wx*0.92, minX = Wx*0.25;

  const candidates = SPECIAL_ANGLES.map(ang=>{
    const R = (v*v*Math.sin(2*ang*Math.PI/180))/g;
    return {ang, x:cannon.x + R};
  }).filter(c => c.x >= minX && c.x <= maxX);

  let pick;
  if(candidates.length){
    pick = candidates.sort((a,b)=> Math.abs(a.x - Wx*0.6) - Math.abs(b.x - Wx*0.6))[0];
  }else{
    pick = SPECIAL_ANGLES.map(ang=>{
      const R = (v*v*Math.sin(2*ang*Math.PI/180))/g;
      return {ang, x: clamp(cannon.x+R, minX, maxX)};
    }).sort((a,b)=> Math.abs(a.x - Wx*0.6) - Math.abs(b.x - Wx*0.6))[0];
  }
  missionAngle = pick.ang;
  target.x = pick.x; target.y = 4;
  missionEl.innerHTML = `🎯 특수각 도전: <b>${missionAngle}°</b> (과녁은 초기화 시점 속력 기준) · 포신을 <b>드래그</b>해 각도 조절`;
}

/* =============== 해석/실측 결과 =============== */
function theoryValues(v, th){
  const Hmax = (v*v*Math.sin(th)*Math.sin(th))/(2*g);
  const Rmax = (v*v*Math.sin(2*th))/g;
  const xApex = (v*v*Math.sin(2*th))/(2*g);
  return {Hmax, Rmax, xApex};
}
function setResultBox(){
  const suffix = airChk.checked ? ' (실측)' : ' (이론)';
  theoryBox.textContent = `Hmax: ${fmt(lastResult.Hmax)} m · Rmax: ${fmt(lastResult.Rmax)} m${suffix}`;
  theoryBox.style.display = showResults ? 'block' : 'none';
}

/* =============== 초기화/발사/루프 =============== */
function resetAll(newMission=true){
  cancelAnim();
  Object.assign(projectile, {x:cannon.x,y:cannon.y,vx:0,vy:0,flying:false,path:[],t:0});
  E_init = 1e-6;
  showResults = false;
  lastResult = {Hmax:0,Rmax:0,xApex:0,empirical:false};
  theoryBox.style.display = 'none';
  if(newMission) placeTargetBySpecialAngle();
  updateBars(0,0,0);
  draw();
}

function fire(){
  if(projectile.flying) return;
  const v = Number(speedSl.value);
  const th = cannon.angleDeg * Math.PI/180;
  projectile.vx = v*Math.cos(th);
  projectile.vy = v*Math.sin(th);
  projectile.flying = true;
  projectile.t = 0;
  projectile.path = [{x:projectile.x, y:projectile.y}];
  lastShot = { v, th };
  showResults = false;
  theoryBox.style.display = 'none';

  const KE0 = 0.5*m*(projectile.vx**2 + projectile.vy**2);
  const PE0 = m*g*projectile.y;
  E_init = KE0 + PE0;

  // 실측 추적 변수(저항 ON일 때 사용)
  track.maxY = 0;
  track.xAtMaxY = projectile.x;
  track.impactX = null;

  loop();
}

function loop(){
  stepPhysics(); draw();
  if(projectile.flying) animId = requestAnimationFrame(loop);
}
function cancelAnim(){ if(animId){ cancelAnimationFrame(animId); animId=null; }}

/* =============== 물리 업데이트 =============== */
let pathStep = 0;
const track = { maxY:0, xAtMaxY:0, impactX:null };

function stepPhysics(){
  const k = airChk.checked ? kBase : 0;
  const ax = -k*projectile.vx;
  const ay = -g - k*projectile.vy;

  projectile.vx += ax*dt;
  projectile.vy += ay*dt;
  projectile.x  += projectile.vx*dt;
  projectile.y  += projectile.vy*dt;
  projectile.t  += dt;

  // 궤적 저장(간헐)
  if((pathStep++ % 2) === 0){
    projectile.path.push({x:projectile.x, y:projectile.y});
    if(projectile.path.length > 2000) projectile.path.shift();
  }

  // 실측 최고점 추적
  if(projectile.y > track.maxY){
    track.maxY = projectile.y;
    track.xAtMaxY = projectile.x;
  }

  let finished = false;
  let hit = false;

  // 지면 충돌: impactX 기록
  if(projectile.y <= 0){
    // 선형 보간으로 착지 x를 조금 더 정확히
    const n = projectile.path.length;
    if(n >= 2){
      const p1 = projectile.path[n-2];
      const p2 = projectile.path[n-1];
      const t = (0 - p1.y) / ((p2.y - p1.y)||1e-6);
      track.impactX = p1.x + (p2.x - p1.x)*t;
    } else {
      track.impactX = projectile.x;
    }
    projectile.y=0; projectile.flying=false; finished = true;
  }

  // 과녁 히트
  const dx = projectile.x-target.x, dy = projectile.y-target.y;
  if(Math.hypot(dx,dy) <= (projectile.r + target.r)){ projectile.flying=false; finished = true; hit = true; }

  // 화면 이탈
  if(projectile.x > Wx+2 || projectile.y > Wy+2){ projectile.flying=false; finished = true; }

  // 에너지 막대
  const KE = 0.5*m*(projectile.vx**2 + projectile.vy**2);
  const PE = m*g*Math.max(0, projectile.y);
  updateBars(PE, KE, KE+PE);

  // 비행 종료 → 결과 확정
  if(finished){
    if(airChk.checked){
      // 실측값 사용
      lastResult = {
        Hmax: Math.max(0, track.maxY),
        Rmax: Math.max(0, track.impactX ?? projectile.x),
        xApex: track.xAtMaxY,
        empirical: true
      };
    }else{
      // 이론값 사용
      lastResult = { ...theoryValues(lastShot.v, lastShot.th), empirical:false };
    }

    showResults = true;
    setResultBox();
    if(hit){ streak += 1; } else { streak = 0; }
    updateStreakUI();
  }
}

/* =============== UI/그래프 =============== */
function updateBars(PE,KE,TE){
  const denom = Math.max(E_init, 1e-6);
  peBar.style.height = (clamp01(PE/denom)*100).toFixed(2)+'%';
  keBar.style.height = (clamp01(KE/denom)*100).toFixed(2)+'%';
  teBar.style.height = (clamp01(TE/denom)*100).toFixed(2)+'%';
}

/* =============== 렌더링 =============== */
function draw(){
  const W = canvas.width/DPR, H = canvas.height/DPR;

  // 하늘(낮)
  const sky = ctx.createLinearGradient(0,0,0,H);
  sky.addColorStop(0,'#bfe6ff'); sky.addColorStop(0.6,'#d9f1ff'); sky.addColorStop(1,'#ecf7ff');
  ctx.fillStyle = sky; ctx.fillRect(0,0,W,H);

  // 산/숲
  drawMountains(W,H);
  drawTreeLine(W,H, 0.78, '#79c483', 0.35, 18);
  drawTreeLine(W,H, 0.70, '#4fb46a', 0.5, 22);
  drawTreeLine(W,H, 0.64, '#2fa36a', 0.7, 26);

  // 그리드/지면
  drawGrid(W,H);
  drawGround(W,H);

  // 결과 마커 & 깃발
  if(showResults){ drawResultMarkers(lastResult); }

  // 과녁/포대/궤적/포탄
  drawTarget();
  drawCannon();
  drawPath();
  drawProjectile();

  // 배너
  if(!projectile.flying && projectile.path.length>1){
    const last = projectile.path.at(-1);
    const hit = Math.hypot(last.x-target.x, last.y-target.y) <= (projectile.r + target.r) + 0.05;
    drawBanner(hit ? "명중!" : "착지");
  }
}

function drawMountains(W,H){
  ctx.save();
  ctx.fillStyle = '#b9d9f4';
  const baseY = H*0.62;
  ctx.beginPath(); ctx.moveTo(0,baseY);
  const peaks = [
    {x: W*0.08, y: baseY-90},{x: W*0.2, y: baseY-50},
    {x: W*0.34, y: baseY-120},{x: W*0.52, y: baseY-70},
    {x: W*0.7, y: baseY-130},{x: W*0.88, y: baseY-60}
  ];
  peaks.forEach(p=>{ ctx.lineTo(p.x,p.y); ctx.lineTo(p.x+48, baseY); });
  ctx.lineTo(W,baseY); ctx.lineTo(W,H); ctx.lineTo(0,H); ctx.closePath();
  ctx.globalAlpha=0.65; ctx.fill();
  ctx.restore();
}
function drawTreeLine(W,H, yRatio, color, alpha, count){
  ctx.save();
  const groundY = worldToCanvas(0,0).y;
  const y = H*yRatio;
  ctx.globalAlpha = alpha;
  for(let i=0;i<count;i++){
    const x = (i+0.5)*(W/count) + (i%2?12:-12);
    const h = 38 + (i%3)*16 + (1+Math.sin(i*1.3))*6;
    drawPine(x,y,h,color);
  }
  ctx.fillStyle='rgba(47,163,106,0.25)'; ctx.fillRect(0,y+8,W, groundY-(y+8));
  ctx.restore();
}
function drawPine(cx, baseY, h, color){
  ctx.save(); ctx.fillStyle=color;
  const levels=[h*0.5,h*0.3,h*0.2]; let y=baseY;
  for(let i=0;i<3;i++){
    const w=(i===0?h*0.5:i===1?h*0.38:h*0.3);
    ctx.beginPath(); ctx.moveTo(cx-w,y); ctx.lineTo(cx,y-levels[i]); ctx.lineTo(cx+w,y);
    ctx.closePath(); ctx.fill(); y-=levels[i]*0.7;
  }
  ctx.fillStyle='#7b5b3a'; ctx.fillRect(cx-2, baseY, 4, 10);
  ctx.restore();
}
function drawGrid(W,H){
  ctx.save(); ctx.strokeStyle='rgba(60,110,170,0.15)'; ctx.lineWidth=1;
  for(let x=0;x<=Wx;x+=10){ const p=worldToCanvas(x,0); ctx.beginPath(); ctx.moveTo(p.x,0); ctx.lineTo(p.x,H); ctx.stroke(); }
  for(let y=10;y<=Wy;y+=10){ const p=worldToCanvas(0,y); ctx.beginPath(); ctx.moveTo(0,p.y); ctx.lineTo(W,p.y); ctx.stroke(); }
  ctx.restore();
}
function drawGround(W,H){
  const p0=worldToCanvas(0,0), p1=worldToCanvas(Wx,0);
  ctx.save();
  ctx.strokeStyle=varGet('--ground','#2fa36a'); ctx.lineWidth=4;
  ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.stroke();
  const g=ctx.createLinearGradient(0,p0.y,0,H);
  g.addColorStop(0,'#bff3cf'); g.addColorStop(1,'#93e0b9');
  ctx.fillStyle=g; ctx.fillRect(0,p0.y,W,H-p0.y);
  ctx.restore();
}
function varGet(name,fallback){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim()||fallback; }

/* --- 결과 마커(이론/실측 공통) --- */
function drawResultMarkers(res){
  const groundY = worldToCanvas(0,0).y;

  // 최고점
  const apexP = worldToCanvas(cannon.x + res.xApex, res.Hmax);
  ctx.save();
  ctx.strokeStyle = 'rgba(37,99,235,0.9)'; ctx.lineWidth = 2;
  ctx.setLineDash([5,5]);
  ctx.beginPath(); ctx.moveTo(apexP.x, groundY); ctx.lineTo(apexP.x, apexP.y); ctx.stroke();
  ctx.setLineDash([]); drawTag(apexP.x+6, apexP.y-6, `Hmax ${fmt(res.Hmax)} m${res.empirical?'(실측)':'(이론)'}`); ctx.restore();

  // 사거리 + 깃발
  const rangeP = worldToCanvas(cannon.x + res.Rmax, 0);
  ctx.save();
  ctx.strokeStyle = 'rgba(234,88,12,0.9)'; ctx.lineWidth = 2;
  ctx.setLineDash([5,5]); ctx.beginPath(); ctx.moveTo(rangeP.x, groundY); ctx.lineTo(rangeP.x, groundY-50); ctx.stroke();
  ctx.setLineDash([]); drawFlag(rangeP.x, groundY-50); drawTag(rangeP.x+8, groundY-56, `Rmax ${fmt(res.Rmax)} m${res.empirical?'(실측)':'(이론)'}`); ctx.restore();
}

function drawFlag(x, yTop){
  ctx.save();
  ctx.strokeStyle = '#0b1220'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(x, yTop); ctx.lineTo(x, yTop+28); ctx.stroke();
  ctx.fillStyle = '#ef4444';
  ctx.beginPath(); ctx.moveTo(x, yTop+4); ctx.lineTo(x+18, yTop+10); ctx.lineTo(x, yTop+16); ctx.closePath(); ctx.fill();
  ctx.restore();
}
function drawTag(x,y,text){
  ctx.save();
  ctx.font='12px system-ui, sans-serif';
  const w = ctx.measureText(text).width + 10;
  ctx.fillStyle = 'rgba(255,255,255,0.95)';
  ctx.fillRect(x,y-14,w,18);
  ctx.strokeStyle='#93b6f0'; ctx.strokeRect(x,y-14,w,18);
  ctx.fillStyle='#0b1220'; ctx.fillText(text, x+5, y);
  ctx.restore();
}

function drawCannon(){
  const theta = cannon.angleDeg * Math.PI/180;
  const base = worldToCanvas(cannon.x, cannon.y);
  const tipW = { x: cannon.x + cannon.barrelLen*Math.cos(theta),
                 y: cannon.y + cannon.barrelLen*Math.sin(theta) };
  const tip = worldToCanvas(tipW.x, tipW.y);

  ctx.save();
  ctx.fillStyle = '#36507a';
  ctx.beginPath(); ctx.arc(base.x, base.y, 18, Math.PI, 0); ctx.fill();

  ctx.strokeStyle = '#0b1220'; ctx.lineWidth = 10; ctx.lineCap = 'round';
  ctx.beginPath(); ctx.moveTo(base.x, base.y); ctx.lineTo(tip.x, tip.y); ctx.stroke();

  ctx.setLineDash([8,6]); ctx.lineWidth=2; ctx.strokeStyle='rgba(37,99,235,.9)';
  ctx.beginPath(); ctx.moveTo(tip.x, tip.y); ctx.lineTo(tip.x + 70*Math.cos(theta), tip.y - 70*Math.sin(-theta)); ctx.stroke();

  ctx.setLineDash([]); ctx.fillStyle='#2563eb'; ctx.strokeStyle='#93b6f0'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.arc(tip.x, tip.y, 9, 0, Math.PI*2); ctx.fill(); ctx.stroke();
  ctx.restore();
}

function drawTarget(){
  const p = worldToCanvas(target.x, target.y);
  const R = target.r * scale;
  ctx.save();
  ctx.fillStyle='#7b5b3a'; ctx.fillRect(p.x-6, p.y, 12, 20);
  for(let i=3;i>=1;i--){
    ctx.beginPath(); ctx.arc(p.x, p.y, R*(i/3), 0, Math.PI*2);
    ctx.fillStyle = i===1 ? '#ef4444' : (i===2 ? '#f59e0b' : '#10b981');
    ctx.globalAlpha=0.95; ctx.fill();
  }
  ctx.restore();
}
function drawProjectile(){
  const p = worldToCanvas(projectile.x, projectile.y);
  const R = projectile.r * scale;
  ctx.save(); ctx.fillStyle='#0b1220';
  ctx.beginPath(); ctx.arc(p.x, p.y, R, 0, Math.PI*2); ctx.fill(); ctx.restore();
}
function drawPath(){
  if(projectile.path.length<2) return;
  ctx.save(); ctx.lineWidth=3; ctx.strokeStyle='rgba(14,165,233,.95)';
  ctx.beginPath();
  let p0=worldToCanvas(projectile.path[0].x, projectile.path[0].y);
  ctx.moveTo(p0.x,p0.y);
  for(let i=1;i<projectile.path.length;i++){
    const pi=worldToCanvas(projectile.path[i].x, projectile.path[i].y);
    ctx.lineTo(pi.x,pi.y);
  }
  ctx.stroke(); ctx.restore();
}
function drawBanner(text){
  const W=canvas.width/DPR;
  ctx.save(); ctx.font='bold 24px system-ui, sans-serif';
  const w=ctx.measureText(text).width+24; const x=W/2-w/2, y=36;
  ctx.fillStyle='rgba(255,255,255,.95)'; ctx.fillRect(x,y,w,36);
  ctx.strokeStyle='#2563eb'; ctx.lineWidth=2; ctx.strokeRect(x,y,w,36);
  ctx.fillStyle='#0b1220'; ctx.fillText(text, x+12, y+26);
  ctx.restore();
}

/* =============== 드래그 =============== */
let draggingAngle=false;
function pointerPos(e){
  const r=canvas.getBoundingClientRect();
  const cx=(e.touches?e.touches[0].clientX:e.clientX)-r.left;
  const cy=(e.touches?e.touches[0].clientY:e.clientY)-r.top;
  return {cx,cy};
}
function startDrag(e){
  const {cx,cy}=pointerPos(e);
  const base=worldToCanvas(cannon.x,cannon.y);
  const theta=cannon.angleDeg*Math.PI/180;
  const tip=worldToCanvas(cannon.x+cannon.barrelLen*Math.cos(theta),cannon.y+cannon.barrelLen*Math.sin(theta));
  const dBase=Math.hypot(cx-base.x,cy-base.y);
  const dTip =Math.hypot(cx-tip.x, cy-tip.y);
  if(dBase<32 || dTip<28){ draggingAngle=true; updateAngleFromPointer(cx,cy); e.preventDefault(); }
}
function moveDrag(e){
  if(!draggingAngle) return;
  const {cx,cy}=pointerPos(e);
  updateAngleFromPointer(cx,cy); e.preventDefault();
}
function endDrag(){ draggingAngle=false; }
function updateAngleFromPointer(cx,cy){
  const baseC=worldToCanvas(cannon.x,cannon.y);
  const dx=cx-baseC.x, dy=baseC.y-cy;
  let deg=Math.atan2(Math.max(0,dy), Math.max(0.0001,dx))*180/Math.PI;
  deg=Math.max(0, Math.min(90, deg));
  cannon.angleDeg=deg;
  angleSl.value=Math.round(deg);
  angleVal.textContent=Math.round(deg);
  showResults=false; theoryBox.style.display='none'; draw();
}

/* =============== 이벤트 =============== */
angleSl.addEventListener('input', ()=>{
  cannon.angleDeg=Number(angleSl.value);
  angleVal.textContent=angleSl.value;
  showResults=false; theoryBox.style.display='none'; draw();
});
speedSl.addEventListener('input', ()=>{
  speedVal.textContent=speedSl.value;
  showResults=false; theoryBox.style.display='none';
});
airChk.addEventListener('change', ()=>{ draw(); });

fireBtn.addEventListener('click', ()=>{ fire(); fireBtn.disabled=true; });
resetBtn.addEventListener('click', ()=>{ resetAll(true); fireBtn.disabled=false; });

canvas.addEventListener('pointerdown', startDrag, {passive:false});
canvas.addEventListener('pointermove',  moveDrag,  {passive:false});
window.addEventListener('pointerup',    endDrag,   {passive:false});
canvas.addEventListener('touchstart', startDrag, {passive:false});
canvas.addEventListener('touchmove',  moveDrag,  {passive:false});
canvas.addEventListener('touchend',   endDrag);

/* =============== 시작 =============== */
resizeCanvas();
updateStreakUI();
cannon.angleDeg = Number(angleSl.value);
speedVal.textContent = speedSl.value;
resetAll(true);
draw();
</script>
</body>
</html>
